{
  "id": 2455055213,
  "repo_owner": "elastic",
  "repo_name": "elasticsearch",
  "number": 126739,
  "title": "Update sparse_vector field mapping to include default setting for token pruning",
  "created_at": "2025-04-12T01:05:31",
  "updated_at": "2025-04-29T01:15:40",
  "state": "open",
  "user_login": "markjhoy",
  "diffs": "diff --git a/docs/reference/elasticsearch/mapping-reference/sparse-vector.md b/docs/reference/elasticsearch/mapping-reference/sparse-vector.md\nindex f8bfe69310600..465bf55efeb6f 100644\n--- a/docs/reference/elasticsearch/mapping-reference/sparse-vector.md\n+++ b/docs/reference/elasticsearch/mapping-reference/sparse-vector.md\n@@ -24,6 +24,27 @@ PUT my-index\n }\n ```\n \n+With optional `index_options` for pruning:\n+```console\n+PUT my-index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"text.tokens\": {\n+        \"type\": \"sparse_vector\",\n+        \"index_options\": {\n+          \"prune\": true,\n+          \"pruning_config\": {\n+            \"tokens_freq_ratio_threshold\": 5,\n+            \"tokens_weight_threshold: 0.4\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n See [semantic search with ELSER](docs-content://solutions/search/semantic-search/semantic-search-elser-ingest-pipelines.md) for a complete example on adding documents to a `sparse_vector` mapped field using ELSER.\n \n ## Parameters for `sparse_vector` fields [sparse-vectors-params]\n@@ -36,6 +57,28 @@ The following parameters are accepted by `sparse_vector` fields:\n     * Exclude the field from [_source](/reference/elasticsearch/rest-apis/retrieve-selected-fields.md#source-filtering).\n     * Use [synthetic `_source`](/reference/elasticsearch/mapping-reference/mapping-source-field.md#synthetic-source).\n \n+index_options\n+:    (Optional, object) You can set index options for your  `sparse_vector` field to determine if you should prune tokens, and the parameter configurations for the token pruning. If the pruning options are not set for your `sparse_query` vector on the field, Elasticsearch will use the defaults if set here for the field. The available options for the index options are:\n+\n+Parameters for `index_options` are:\n+\n+`prune`\n+:   (Optional, boolean) [preview] Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance. If `prune` is true but the `pruning_config` is not specified, pruning will occur but default values will be used. Default: true.\n+\n+`pruning_config`\n+:   (Optional, object) [preview] Optional pruning configuration. If enabled, this will omit non-significant tokens from the query in order to improve query performance. This is only used if `prune` is set to `true`. If `prune` is set to `true` but `pruning_config` is not specified, default values will be used.\n+\n+    Parameters for `pruning_config` include:\n+\n+    `tokens_freq_ratio_threshold`\n+    :   (Optional, integer) [preview] Tokens whose frequency is more than `tokens_freq_ratio_threshold` times the average frequency of all tokens in the specified field are considered outliers and pruned. This value must between 1 and 100. Default: `5`.\n+\n+    `tokens_weight_threshold`\n+    :   (Optional, float) [preview] Tokens whose weight is less than `tokens_weight_threshold` are considered insignificant and pruned. This value must be between 0 and 1. Default: `0.4`.\n+\n+    ::::{note}\n+    The default values for `tokens_freq_ratio_threshold` and `tokens_weight_threshold` were chosen based on tests using ELSERv2 that provided the most optimal results.\n+    ::::\n \n \n ## Multi-value sparse vectors [index-multi-value-sparse-vectors]\ndiff --git a/server/src/main/java/org/elasticsearch/TransportVersions.java b/server/src/main/java/org/elasticsearch/TransportVersions.java\nindex eaf3549bc83b1..e6007b85cafe2 100644\n--- a/server/src/main/java/org/elasticsearch/TransportVersions.java\n+++ b/server/src/main/java/org/elasticsearch/TransportVersions.java\n@@ -228,6 +228,7 @@ static TransportVersion def(int id) {\n     public static final TransportVersion DENSE_VECTOR_OFF_HEAP_STATS = def(9_062_00_0);\n     public static final TransportVersion RANDOM_SAMPLER_QUERY_BUILDER = def(9_063_0_00);\n     public static final TransportVersion SETTINGS_IN_DATA_STREAMS = def(9_064_0_00);\n+    public static final TransportVersion SPARSE_VECTOR_FIELD_PRUNING_OPTIONS = def(9_065_0_00);\n \n     /*\n      * STOP! READ THIS FIRST! No, really,\ndiff --git a/server/src/main/java/org/elasticsearch/index/IndexVersions.java b/server/src/main/java/org/elasticsearch/index/IndexVersions.java\nindex 96386ceca6c9f..996d49506418d 100644\n--- a/server/src/main/java/org/elasticsearch/index/IndexVersions.java\n+++ b/server/src/main/java/org/elasticsearch/index/IndexVersions.java\n@@ -162,6 +162,7 @@ private static Version parseUnchecked(String version) {\n     public static final IndexVersion UPGRADE_TO_LUCENE_10_2_0 = def(9_022_00_0, Version.LUCENE_10_2_0);\n     public static final IndexVersion UPGRADE_TO_LUCENE_10_2_1 = def(9_023_00_0, Version.LUCENE_10_2_1);\n     public static final IndexVersion DEFAULT_OVERSAMPLE_VALUE_FOR_BBQ = def(9_024_0_00, Version.LUCENE_10_2_1);\n+    public static final IndexVersion SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT = def(9_025_0_00, Version.LUCENE_10_2_1);\n     /*\n      * STOP! READ THIS FIRST! No, really,\n      *        ____ _____ ___  ____  _        ____  _____    _    ____    _____ _   _ ___ ____    _____ ___ ____  ____ _____ _\ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java\nindex fdbb03f51743e..ed46b126ab324 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java\n@@ -22,6 +22,8 @@\n import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.common.logging.DeprecationCategory;\n import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.core.Nullable;\n import org.elasticsearch.index.IndexVersion;\n import org.elasticsearch.index.IndexVersions;\n import org.elasticsearch.index.analysis.NamedAnalyzer;\n@@ -31,6 +33,8 @@\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.MapperBuilderContext;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MappingParserContext;\n import org.elasticsearch.index.mapper.SourceLoader;\n import org.elasticsearch.index.mapper.SourceValueFetcher;\n import org.elasticsearch.index.mapper.TextSearchInfo;\n@@ -38,6 +42,7 @@\n import org.elasticsearch.index.query.SearchExecutionContext;\n import org.elasticsearch.search.fetch.StoredFieldsSpec;\n import org.elasticsearch.search.lookup.Source;\n+import org.elasticsearch.xcontent.ToXContent;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentParser.Token;\n \n@@ -46,6 +51,7 @@\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.stream.Stream;\n \n import static org.elasticsearch.index.query.AbstractQueryBuilder.DEFAULT_BOOST;\n@@ -57,6 +63,7 @@\n public class SparseVectorFieldMapper extends FieldMapper {\n \n     public static final String CONTENT_TYPE = \"sparse_vector\";\n+    public static final String SPARSE_VECTOR_INDEX_OPTIONS = \"index_options\";\n \n     static final String ERROR_MESSAGE_7X = \"[sparse_vector] field type in old 7.x indices is allowed to \"\n         + \"contain [sparse_vector] fields, but they cannot be indexed or searched.\";\n@@ -65,6 +72,9 @@ public class SparseVectorFieldMapper extends FieldMapper {\n \n     static final IndexVersion NEW_SPARSE_VECTOR_INDEX_VERSION = IndexVersions.NEW_SPARSE_VECTOR;\n     static final IndexVersion SPARSE_VECTOR_IN_FIELD_NAMES_INDEX_VERSION = IndexVersions.SPARSE_VECTOR_IN_FIELD_NAMES_SUPPORT;\n+    static final IndexVersion SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_VERSION = IndexVersions.SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT;\n+\n+    private final SparseVectorFieldMapper.IndexOptions indexOptions;\n \n     private static SparseVectorFieldMapper toType(FieldMapper in) {\n         return (SparseVectorFieldMapper) in;\n@@ -73,9 +83,23 @@ private static SparseVectorFieldMapper toType(FieldMapper in) {\n     public static class Builder extends FieldMapper.Builder {\n         private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType().isStored(), false);\n         private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<IndexOptions> indexOptions;\n \n         public Builder(String name) {\n             super(name);\n+            this.indexOptions = new Parameter<>(\n+                SPARSE_VECTOR_INDEX_OPTIONS,\n+                true,\n+                () -> null,\n+                (n, c, o) -> o == null ? getDefaultIndexOptions(c) : parseIndexOptions(c, o),\n+                m -> toType(m).fieldType().indexOptions,\n+                (b, n, v) -> {\n+                    if (v != null) {\n+                        b.field(n, v);\n+                    }\n+                },\n+                Objects::toString\n+            );\n         }\n \n         public Builder setStored(boolean value) {\n@@ -85,19 +109,63 @@ public Builder setStored(boolean value) {\n \n         @Override\n         protected Parameter<?>[] getParameters() {\n-            return new Parameter<?>[] { stored, meta };\n+            return new Parameter<?>[] { stored, meta, indexOptions };\n         }\n \n         @Override\n         public SparseVectorFieldMapper build(MapperBuilderContext context) {\n+            IndexOptions buildIndexOptions = indexOptions.getValue();\n+\n+            if (buildIndexOptions == null) {\n+                buildIndexOptions = new IndexOptions(\n+                    true,\n+                    new PruningConfig(PruningConfig.DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD, PruningConfig.DEFAULT_TOKENS_WEIGHT_THRESHOLD)\n+                );\n+            }\n+\n             return new SparseVectorFieldMapper(\n                 leafName(),\n-                new SparseVectorFieldType(context.buildFullName(leafName()), stored.getValue(), meta.getValue()),\n-                builderParams(this, context)\n+                new SparseVectorFieldType(context.buildFullName(leafName()), stored.getValue(), meta.getValue(), buildIndexOptions),\n+                builderParams(this, context),\n+                buildIndexOptions\n             );\n         }\n     }\n \n+    public IndexOptions getIndexOptions() {\n+        return this.indexOptions;\n+    }\n+\n+    private static SparseVectorFieldMapper.IndexOptions getDefaultIndexOptions(MappingParserContext context) {\n+        if (context.indexVersionCreated().before(SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_VERSION)) {\n+            // don't set defaults if this index was created before\n+            // we added this functionality in, so it will\n+            // not change current index behaviour\n+            return new IndexOptions(false, null);\n+        }\n+\n+        // index options are not set - for new indices, we\n+        // need to set pruning to true by default\n+        // with a default pruning configuration\n+        return new IndexOptions(\n+            true,\n+            new PruningConfig(PruningConfig.DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD, PruningConfig.DEFAULT_TOKENS_WEIGHT_THRESHOLD)\n+        );\n+    }\n+\n+    private static SparseVectorFieldMapper.IndexOptions parseIndexOptions(MappingParserContext context, Object propNode) {\n+        Map<String, Object> indexOptionsMap = XContentMapValues.nodeMapValue(propNode, SPARSE_VECTOR_INDEX_OPTIONS);\n+\n+        Boolean prune = IndexOptions.parseIndexOptionsPruneValue(indexOptionsMap);\n+        PruningConfig pruningConfig = IndexOptions.parseIndexOptionsPruningConfig(prune, indexOptionsMap);\n+\n+        if (prune == null && pruningConfig == null) {\n+            return getDefaultIndexOptions(context);\n+        }\n+\n+        return new SparseVectorFieldMapper.IndexOptions(prune, pruningConfig);\n+    }\n+\n     public static final TypeParser PARSER = new TypeParser((n, c) -> {\n         if (c.indexVersionCreated().before(PREVIOUS_SPARSE_VECTOR_INDEX_VERSION)) {\n             deprecationLogger.warn(DeprecationCategory.MAPPINGS, \"sparse_vector\", ERROR_MESSAGE_7X);\n@@ -109,9 +177,21 @@ public SparseVectorFieldMapper build(MapperBuilderContext context) {\n     }, notInMultiFields(CONTENT_TYPE));\n \n     public static final class SparseVectorFieldType extends MappedFieldType {\n+        private final IndexOptions indexOptions;\n \n         public SparseVectorFieldType(String name, boolean isStored, Map<String, String> meta) {\n             super(name, true, isStored, false, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);\n+            this.indexOptions = null;\n+        }\n+\n+        public SparseVectorFieldType(\n+            String name,\n+            boolean isStored,\n+            Map<String, String> meta,\n+            @Nullable SparseVectorFieldMapper.IndexOptions indexOptions\n+        ) {\n+            super(name, true, isStored, false, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);\n+            this.indexOptions = indexOptions;\n         }\n \n         @Override\n@@ -157,8 +237,14 @@ private static String indexedValueForSearch(Object value) {\n         }\n     }\n \n-    private SparseVectorFieldMapper(String simpleName, MappedFieldType mappedFieldType, BuilderParams builderParams) {\n+    private SparseVectorFieldMapper(\n+        String simpleName,\n+        MappedFieldType mappedFieldType,\n+        BuilderParams builderParams,\n+        @Nullable IndexOptions indexOptions\n+    ) {\n         super(simpleName, mappedFieldType, builderParams);\n+        this.indexOptions = indexOptions;\n     }\n \n     @Override\n@@ -364,4 +450,227 @@ public void reset() {\n         }\n     }\n \n+    public static class IndexOptions implements ToXContent {\n+        public static final String PRUNE_FIELD_NAME = \"prune\";\n+        public static final String PRUNING_CONFIG_FIELD_NAME = \"pruning_config\";\n+\n+        final Boolean prune;\n+        final PruningConfig pruningConfig;\n+\n+        IndexOptions(@Nullable Boolean prune, @Nullable PruningConfig pruningConfig) {\n+            this.prune = prune;\n+            this.pruningConfig = pruningConfig;\n+        }\n+\n+        public Boolean getPrune() {\n+            return prune;\n+        }\n+\n+        public PruningConfig getPruningConfig() {\n+            return pruningConfig;\n+        }\n+\n+        @Override\n+        public final boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+            if (other instanceof IndexOptions otherOptions) {\n+                return Objects.equals(prune, otherOptions.prune) && Objects.equals(pruningConfig, otherOptions.pruningConfig);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public final int hashCode() {\n+            return Objects.hash(prune, pruningConfig);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (prune == null && pruningConfig == null) {\n+                return builder;\n+            }\n+\n+            builder.startObject();\n+            if (prune != null) {\n+                builder.field(PRUNE_FIELD_NAME, prune);\n+            }\n+            if (pruningConfig != null) {\n+                builder.field(PRUNING_CONFIG_FIELD_NAME, pruningConfig);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        public static Boolean parseIndexOptionsPruneValue(Map<String, Object> indexOptionsMap) {\n+            Object shouldPrune = indexOptionsMap.remove(IndexOptions.PRUNE_FIELD_NAME);\n+            if (shouldPrune == null) {\n+                return null;\n+            }\n+\n+            if ((shouldPrune instanceof Boolean) == false) {\n+                throw new MapperParsingException(\"[index_options] field [prune] should be true or false\");\n+            }\n+\n+            return ((Boolean) shouldPrune);\n+        }\n+\n+        public static PruningConfig parseIndexOptionsPruningConfig(Boolean prune, Map<String, Object> indexOptionsMap) {\n+            Object pruningConfiguration = indexOptionsMap.remove(IndexOptions.PRUNING_CONFIG_FIELD_NAME);\n+            if (pruningConfiguration == null) {\n+                return null;\n+            }\n+            if ((pruningConfiguration instanceof Map) == false) {\n+                throw new MapperParsingException(\"[index_options] field [pruning_config] should be a map\");\n+            }\n+\n+            if (prune != null && prune == false) {\n+                throw new MapperParsingException(\"[index_options] field [pruning_config] should not be set if [prune] is false\");\n+            }\n+\n+            return PruningConfig.parsePruningConfig(pruningConfiguration);\n+        }\n+    }\n+\n+    public static class PruningConfig implements ToXContent {\n+        public static final String TOKENS_FREQ_RATIO_THRESHOLD_FIELD_NAME = \"tokens_freq_ratio_threshold\";\n+        public static final String TOKENS_WEIGHT_THRESHOLD_FIELD_NAME = \"tokens_weight_threshold\";\n+\n+        public static float DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD = 5;\n+        public static float MIN_TOKENS_FREQ_RATIO_THRESHOLD = 1;\n+        public static float MAX_TOKENS_FREQ_RATIO_THRESHOLD = 100;\n+\n+        public static float DEFAULT_TOKENS_WEIGHT_THRESHOLD = 0.4f;\n+        public static float MIN_TOKENS_WEIGHT_THRESHOLD = 0.0f;\n+        public static float MAX_TOKENS_WEIGHT_THRESHOLD = 1.0f;\n+\n+        final Float tokens_freq_ratio_threshold;\n+        final Float tokens_weight_threshold;\n+\n+        PruningConfig(@Nullable Float tokens_freq_ratio_threshold, @Nullable Float tokens_weight_threshold) {\n+            this.tokens_freq_ratio_threshold = tokens_freq_ratio_threshold;\n+            this.tokens_weight_threshold = tokens_weight_threshold;\n+        }\n+\n+        public float getTokensFreqRatioThresholdOrDefault() {\n+            if (tokens_freq_ratio_threshold == null) {\n+                return DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD;\n+            }\n+            return tokens_freq_ratio_threshold;\n+        }\n+\n+        public float getTokensWeightThresholdOrDefault() {\n+            if (tokens_weight_threshold == null) {\n+                return DEFAULT_TOKENS_WEIGHT_THRESHOLD;\n+            }\n+            return tokens_weight_threshold;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            if (tokens_freq_ratio_threshold != null) {\n+                builder.field(TOKENS_FREQ_RATIO_THRESHOLD_FIELD_NAME, tokens_freq_ratio_threshold);\n+            }\n+            if (tokens_weight_threshold != null) {\n+                builder.field(TOKENS_WEIGHT_THRESHOLD_FIELD_NAME, tokens_weight_threshold);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public final boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+            if (other instanceof PruningConfig otherConfig) {\n+                return Objects.equals(tokens_freq_ratio_threshold, otherConfig.tokens_freq_ratio_threshold)\n+                    && Objects.equals(tokens_weight_threshold, otherConfig.tokens_weight_threshold);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public final int hashCode() {\n+            return Objects.hash(tokens_freq_ratio_threshold, tokens_weight_threshold);\n+        }\n+\n+        public static PruningConfig parsePruningConfig(Object pruningConfiguration) {\n+            Map<String, Object> pruningConfigMap = XContentMapValues.nodeMapValue(pruningConfiguration, SPARSE_VECTOR_INDEX_OPTIONS);\n+\n+            Object mappedTokensFreqRatioThreshold = pruningConfigMap.remove(TOKENS_FREQ_RATIO_THRESHOLD_FIELD_NAME);\n+            Object mappedTokensWeightThreshold = pruningConfigMap.remove(TOKENS_WEIGHT_THRESHOLD_FIELD_NAME);\n+\n+            if (pruningConfigMap.isEmpty() == false) {\n+                throw new MapperParsingException(\"[index_options] field [pruning_config] has unknown fields\");\n+            }\n+\n+            Float tokensFreqRatioThreshold = parseTokensFreqRatioThreshold(mappedTokensFreqRatioThreshold);\n+            Float tokensWeightThreshold = parseTokensWeightThreshold(mappedTokensWeightThreshold);\n+\n+            if (tokensFreqRatioThreshold != null || tokensWeightThreshold != null) {\n+                return new PruningConfig(tokensFreqRatioThreshold, tokensWeightThreshold);\n+            }\n+\n+            return null;\n+        }\n+\n+        private static Float parseFloatNumberFromObject(Object numberObject) {\n+            if (numberObject instanceof Integer intValue) {\n+                return (float) intValue;\n+            } else if (numberObject instanceof Float floatValue) {\n+                return floatValue;\n+            } else if (numberObject instanceof Double doubleValue) {\n+                return ((Double) numberObject).floatValue();\n+            }\n+            return null;\n+        }\n+\n+        private static Float parseTokensWeightThreshold(Object mappedTokensWeightThreshold) {\n+            if (mappedTokensWeightThreshold == null) {\n+                return null;\n+            }\n+\n+            Float tokensWeightThreshold = parseFloatNumberFromObject(mappedTokensWeightThreshold);\n+\n+            if (tokensWeightThreshold == null) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\"\n+                );\n+            }\n+\n+            if (tokensWeightThreshold < PruningConfig.MIN_TOKENS_WEIGHT_THRESHOLD\n+                || tokensWeightThreshold > PruningConfig.MAX_TOKENS_WEIGHT_THRESHOLD) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\"\n+                );\n+            }\n+            return tokensWeightThreshold;\n+        }\n+\n+        private static Float parseTokensFreqRatioThreshold(Object mappedTokensFreqRatioThreshold) {\n+            if (mappedTokensFreqRatioThreshold == null) {\n+                return null;\n+            }\n+\n+            Float tokensFreqRatioThreshold = parseFloatNumberFromObject(mappedTokensFreqRatioThreshold);\n+\n+            if (tokensFreqRatioThreshold == null) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\"\n+                );\n+            }\n+\n+            if (tokensFreqRatioThreshold < PruningConfig.MIN_TOKENS_FREQ_RATIO_THRESHOLD\n+                || tokensFreqRatioThreshold > PruningConfig.MAX_TOKENS_FREQ_RATIO_THRESHOLD) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\"\n+                );\n+            }\n+\n+            return tokensFreqRatioThreshold;\n+        }\n+    }\n }\ndiff --git a/server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java b/server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java\nindex b2379ba579204..693c5d626f15d 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java\n@@ -67,6 +67,34 @@ protected void minimalMapping(XContentBuilder b) throws IOException {\n         b.field(\"type\", \"sparse_vector\");\n     }\n \n+    protected void mappingWithDefaultIndexOptions(XContentBuilder b) throws IOException {\n+        b.field(\"type\", \"sparse_vector\");\n+        b.startObject(\"index_options\");\n+        b.field(\"prune\", true);\n+        b.startObject(\"pruning_config\");\n+        b.field(\"tokens_freq_ratio_threshold\", SparseVectorFieldMapper.PruningConfig.DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD);\n+        b.field(\"tokens_weight_threshold\", SparseVectorFieldMapper.PruningConfig.DEFAULT_TOKENS_WEIGHT_THRESHOLD);\n+        b.endObject();\n+        b.endObject();\n+    }\n+\n+    protected void mappingWithIndexOptionsPrune(XContentBuilder b) throws IOException {\n+        b.field(\"type\", \"sparse_vector\");\n+        b.startObject(\"index_options\");\n+        b.field(\"prune\", true);\n+        b.endObject();\n+    }\n+\n+    protected void mappingWithIndexOptionsPruningConfig(XContentBuilder b) throws IOException {\n+        b.field(\"type\", \"sparse_vector\");\n+        b.startObject(\"index_options\");\n+        b.startObject(\"pruning_config\");\n+        b.field(\"tokens_freq_ratio_threshold\", 5.0);\n+        b.field(\"tokens_weight_threshold\", 0.4);\n+        b.endObject();\n+        b.endObject();\n+    }\n+\n     @Override\n     protected boolean supportsStoredFields() {\n         return false;\n@@ -96,7 +124,59 @@ private static int getFrequency(TokenStream tk) throws IOException {\n \n     public void testDefaults() throws Exception {\n         DocumentMapper mapper = createDocumentMapper(fieldMapping(this::minimalMapping));\n-        assertEquals(Strings.toString(fieldMapping(this::minimalMapping)), mapper.mappingSource().toString());\n+        assertEquals(Strings.toString(fieldMapping(this::mappingWithDefaultIndexOptions)), mapper.mappingSource().toString());\n+\n+        ParsedDocument doc1 = mapper.parse(source(this::writeField));\n+\n+        List<IndexableField> fields = doc1.rootDoc().getFields(\"field\");\n+        assertEquals(2, fields.size());\n+        assertThat(fields.get(0), Matchers.instanceOf(XFeatureField.class));\n+        XFeatureField featureField1 = null;\n+        XFeatureField featureField2 = null;\n+        for (IndexableField field : fields) {\n+            if (field.stringValue().equals(\"ten\")) {\n+                featureField1 = (XFeatureField) field;\n+            } else if (field.stringValue().equals(\"twenty\")) {\n+                featureField2 = (XFeatureField) field;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        int freq1 = getFrequency(featureField1.tokenStream(null, null));\n+        int freq2 = getFrequency(featureField2.tokenStream(null, null));\n+        assertTrue(freq1 < freq2);\n+    }\n+\n+    public void testWithIndexOptionsPrune() throws Exception {\n+        DocumentMapper mapper = createDocumentMapper(fieldMapping(this::mappingWithIndexOptionsPrune));\n+        assertEquals(Strings.toString(fieldMapping(this::mappingWithIndexOptionsPrune)), mapper.mappingSource().toString());\n+\n+        ParsedDocument doc1 = mapper.parse(source(this::writeField));\n+\n+        List<IndexableField> fields = doc1.rootDoc().getFields(\"field\");\n+        assertEquals(2, fields.size());\n+        assertThat(fields.get(0), Matchers.instanceOf(XFeatureField.class));\n+        XFeatureField featureField1 = null;\n+        XFeatureField featureField2 = null;\n+        for (IndexableField field : fields) {\n+            if (field.stringValue().equals(\"ten\")) {\n+                featureField1 = (XFeatureField) field;\n+            } else if (field.stringValue().equals(\"twenty\")) {\n+                featureField2 = (XFeatureField) field;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        int freq1 = getFrequency(featureField1.tokenStream(null, null));\n+        int freq2 = getFrequency(featureField2.tokenStream(null, null));\n+        assertTrue(freq1 < freq2);\n+    }\n+\n+    public void testWithIndexOptionsPruningConfig() throws Exception {\n+        DocumentMapper mapper = createDocumentMapper(fieldMapping(this::mappingWithIndexOptionsPruningConfig));\n+        assertEquals(Strings.toString(fieldMapping(this::mappingWithIndexOptionsPruningConfig)), mapper.mappingSource().toString());\n \n         ParsedDocument doc1 = mapper.parse(source(this::writeField));\n \n@@ -202,6 +282,108 @@ public void testCannotBeUsedInMultiFields() {\n         assertThat(e.getMessage(), containsString(\"Field [feature] of type [sparse_vector] can't be used in multifields\"));\n     }\n \n+    public void testPruneMustBeBoolean() {\n+        Exception e = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.field(\"prune\", \"othervalue\");\n+            b.endObject();\n+        })));\n+        assertThat(e.getMessage(), containsString(\"[index_options] field [prune] should be true or false\"));\n+    }\n+\n+    public void testPruningConfigurationIsMap() {\n+        Exception e = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.field(\"pruning_config\", \"this_is_not_a_map\");\n+            b.endObject();\n+        })));\n+        assertThat(e.getMessage(), containsString(\"index_options] field [pruning_config] should be a map\"));\n+    }\n+\n+    public void testTokensFreqRatioCorrect() {\n+        Exception eTestInteger = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_freq_ratio_threshold\", \"notaninteger\");\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestInteger.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\")\n+        );\n+\n+        Exception eTestRangeLower = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_freq_ratio_threshold\", -2);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeLower.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\")\n+        );\n+\n+        Exception eTestRangeHigher = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_freq_ratio_threshold\", 101);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeHigher.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\")\n+        );\n+    }\n+\n+    public void testTokensWeightThresholdCorrect() {\n+        Exception eTestDouble = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_weight_threshold\", \"notadouble\");\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestDouble.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\")\n+        );\n+\n+        Exception eTestRangeLower = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_weight_threshold\", -0.1);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeLower.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\")\n+        );\n+\n+        Exception eTestRangeHigher = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_weight_threshold\", 1.1);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeHigher.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\")\n+        );\n+    }\n+\n     public void testStoreIsNotUpdateable() throws IOException {\n         var mapperService = createMapperService(fieldMapping(this::minimalMapping));\n         XContentBuilder mapping = jsonBuilder().startObject()\ndiff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java\nindex 35cba890e5e0c..64b85b0718c3d 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java\n@@ -18,6 +18,10 @@\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.core.Nullable;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.Mapping;\n+import org.elasticsearch.index.mapper.RootObjectMapper;\n+import org.elasticsearch.index.mapper.vectors.SparseVectorFieldMapper;\n import org.elasticsearch.index.query.AbstractQueryBuilder;\n import org.elasticsearch.index.query.QueryBuilder;\n import org.elasticsearch.index.query.QueryRewriteContext;\n@@ -61,7 +65,7 @@ public class SparseVectorQueryBuilder extends AbstractQueryBuilder<SparseVectorQ\n     private final List<WeightedToken> queryVectors;\n     private final String inferenceId;\n     private final String query;\n-    private final boolean shouldPruneTokens;\n+    private final Boolean shouldPruneTokens;\n \n     private final SetOnce<TextExpansionResults> weightedTokensSupplier;\n \n@@ -81,13 +85,11 @@ public SparseVectorQueryBuilder(\n         @Nullable TokenPruningConfig tokenPruningConfig\n     ) {\n         this.fieldName = Objects.requireNonNull(fieldName, \"[\" + NAME + \"] requires a [\" + FIELD_FIELD.getPreferredName() + \"]\");\n-        this.shouldPruneTokens = (shouldPruneTokens != null ? shouldPruneTokens : DEFAULT_PRUNE);\n+        this.shouldPruneTokens = shouldPruneTokens;\n         this.queryVectors = queryVectors;\n         this.inferenceId = inferenceId;\n         this.query = query;\n-        this.tokenPruningConfig = (tokenPruningConfig != null\n-            ? tokenPruningConfig\n-            : (this.shouldPruneTokens ? new TokenPruningConfig() : null));\n+        this.tokenPruningConfig = tokenPruningConfig;\n         this.weightedTokensSupplier = null;\n \n         // Preserve BWC error messaging\n@@ -124,7 +126,11 @@ public SparseVectorQueryBuilder(\n     public SparseVectorQueryBuilder(StreamInput in) throws IOException {\n         super(in);\n         this.fieldName = in.readString();\n-        this.shouldPruneTokens = in.readBoolean();\n+        if (in.getTransportVersion().onOrAfter(TransportVersions.SPARSE_VECTOR_FIELD_PRUNING_OPTIONS)) {\n+            this.shouldPruneTokens = in.readOptionalBoolean();\n+        } else {\n+            this.shouldPruneTokens = in.readBoolean();\n+        }\n         this.queryVectors = in.readOptionalCollectionAsList(WeightedToken::new);\n         this.inferenceId = in.readOptionalString();\n         this.query = in.readOptionalString();\n@@ -159,7 +165,7 @@ public String getQuery() {\n     }\n \n     public boolean shouldPruneTokens() {\n-        return shouldPruneTokens;\n+        return shouldPruneTokens != null ? shouldPruneTokens : DEFAULT_PRUNE;\n     }\n \n     public TokenPruningConfig getTokenPruningConfig() {\n@@ -173,7 +179,11 @@ protected void doWriteTo(StreamOutput out) throws IOException {\n         }\n \n         out.writeString(fieldName);\n-        out.writeBoolean(shouldPruneTokens);\n+        if (out.getTransportVersion().onOrAfter(TransportVersions.SPARSE_VECTOR_FIELD_PRUNING_OPTIONS)) {\n+            out.writeOptionalBoolean(shouldPruneTokens);\n+        } else {\n+            out.writeBoolean(shouldPruneTokens != null && shouldPruneTokens);\n+        }\n         out.writeOptionalCollection(queryVectors);\n         out.writeOptionalString(inferenceId);\n         out.writeOptionalString(query);\n@@ -196,7 +206,9 @@ protected void doXContent(XContentBuilder builder, Params params) throws IOExcep\n             }\n             builder.field(QUERY_FIELD.getPreferredName(), query);\n         }\n-        builder.field(PRUNE_FIELD.getPreferredName(), shouldPruneTokens);\n+        if (shouldPruneTokens != null) {\n+            builder.field(PRUNE_FIELD.getPreferredName(), shouldPruneTokens);\n+        }\n         if (tokenPruningConfig != null) {\n             builder.field(PRUNING_CONFIG_FIELD.getPreferredName(), tokenPruningConfig);\n         }\n@@ -222,8 +234,14 @@ protected Query doToQuery(SearchExecutionContext context) throws IOException {\n             );\n         }\n \n-        return (shouldPruneTokens)\n-            ? WeightedTokensUtils.queryBuilderWithPrunedTokens(fieldName, tokenPruningConfig, queryVectors, ft, context)\n+        // if the query options for pruning are not set,\n+        // we need to check the index options for this field\n+        // and use those if set.\n+        SparseVectorFieldMapper sparseVectorFieldMapper = getSparseVectorFieldMapperForSearchExecution(fieldName, context);\n+        TokenPruningSet pruningOptions = setPruningConfigFromIndexIfNeeded(shouldPruneTokens, tokenPruningConfig, sparseVectorFieldMapper);\n+\n+        return pruningOptions.pruneTokens\n+            ? WeightedTokensUtils.queryBuilderWithPrunedTokens(fieldName, pruningOptions.pruningConfig, queryVectors, ft, context)\n             : WeightedTokensUtils.queryBuilderWithAllTokens(fieldName, queryVectors, ft, context);\n     }\n \n@@ -231,19 +249,31 @@ protected Query doToQuery(SearchExecutionContext context) throws IOException {\n     protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) {\n         if (queryVectors != null) {\n             return this;\n-        } else if (weightedTokensSupplier != null) {\n+        }\n+\n+        if (weightedTokensSupplier != null) {\n             TextExpansionResults textExpansionResults = weightedTokensSupplier.get();\n             if (textExpansionResults == null) {\n                 return this; // No results yet\n             }\n \n+            // if the query options for pruning are not set,\n+            // we need to check the index options for this field\n+            // and use those if set.\n+            SparseVectorFieldMapper sparseVectorFieldMapper = getSparseVectorFieldMapperForQueryRewrite(fieldName, queryRewriteContext);\n+            TokenPruningSet pruningOptions = setPruningConfigFromIndexIfNeeded(\n+                shouldPruneTokens,\n+                tokenPruningConfig,\n+                sparseVectorFieldMapper\n+            );\n+\n             return new SparseVectorQueryBuilder(\n                 fieldName,\n                 textExpansionResults.getWeightedTokens(),\n                 null,\n                 null,\n-                shouldPruneTokens,\n-                tokenPruningConfig\n+                pruningOptions.pruneTokens,\n+                pruningOptions.pruningConfig\n             );\n         } else if (inferenceId == null) {\n             // Edge case, where inference_id was not specified in the request,\n@@ -378,4 +408,72 @@ public static SparseVectorQueryBuilder fromXContent(XContentParser parser) {\n             throw new ParsingException(parser.getTokenLocation(), e.getMessage(), e);\n         }\n     }\n+\n+    private record IndexFieldPruningSettings(@Nullable Boolean prune, @Nullable TokenPruningConfig pruningConfig) {}\n+\n+    private IndexFieldPruningSettings getIndexFieldPruningSettings(SparseVectorFieldMapper sparseVectorFieldMapper) {\n+        if (sparseVectorFieldMapper == null) {\n+            return new IndexFieldPruningSettings(null, null);\n+        }\n+\n+        SparseVectorFieldMapper.IndexOptions indexOptions = sparseVectorFieldMapper.getIndexOptions();\n+        if (indexOptions == null) {\n+            return new IndexFieldPruningSettings(null, null);\n+        }\n+\n+        Boolean indexOptionsPrune = indexOptions.getPrune();\n+\n+        SparseVectorFieldMapper.PruningConfig indexPruningConfig = indexOptions.getPruningConfig();\n+        TokenPruningConfig indexTokenPruningConfig = indexPruningConfig != null\n+            ? new TokenPruningConfig(\n+                indexPruningConfig.getTokensFreqRatioThresholdOrDefault(),\n+                indexPruningConfig.getTokensWeightThresholdOrDefault(),\n+                false\n+            )\n+            : null;\n+\n+        return new IndexFieldPruningSettings(indexOptionsPrune, indexTokenPruningConfig);\n+    }\n+\n+    private SparseVectorFieldMapper getSparseVectorFieldMapper(String fieldName, Mapping fieldMapping) {\n+        RootObjectMapper rootMapping = fieldMapping.getRoot();\n+        Mapper thisMapper = rootMapping.getMapper(fieldName);\n+        if (thisMapper instanceof SparseVectorFieldMapper) {\n+            return (SparseVectorFieldMapper) thisMapper;\n+        }\n+\n+        return null;\n+    }\n+\n+    private SparseVectorFieldMapper getSparseVectorFieldMapperForSearchExecution(String fieldName, SearchExecutionContext context) {\n+        return getSparseVectorFieldMapper(fieldName, context.getMappingLookup().getMapping());\n+    }\n+\n+    private SparseVectorFieldMapper getSparseVectorFieldMapperForQueryRewrite(String fieldName, QueryRewriteContext context) {\n+        return getSparseVectorFieldMapper(fieldName, context.getMappingLookup().getMapping());\n+    }\n+\n+    private record TokenPruningSet(boolean pruneTokens, TokenPruningConfig pruningConfig) {}\n+\n+    private TokenPruningSet setPruningConfigFromIndexIfNeeded(\n+        Boolean queryPruneTokens,\n+        TokenPruningConfig queryPruningConfig,\n+        SparseVectorFieldMapper fieldMapper\n+    ) {\n+        boolean doPruneTokens = false;\n+        TokenPruningConfig setTokenPruningConfig = queryPruningConfig;\n+        if (queryPruneTokens == null || queryPruningConfig == null) {\n+            IndexFieldPruningSettings indexPruningSettings = getIndexFieldPruningSettings(fieldMapper);\n+            if (shouldPruneTokens == null && indexPruningSettings.prune != null && indexPruningSettings.prune) {\n+                doPruneTokens = true;\n+            }\n+            if (setTokenPruningConfig == null && indexPruningSettings.pruningConfig != null) {\n+                setTokenPruningConfig = indexPruningSettings.pruningConfig;\n+            }\n+        } else {\n+            doPruneTokens = queryPruneTokens;\n+        }\n+\n+        return new TokenPruningSet(doPruneTokens, setTokenPruningConfig);\n+    }\n }\ndiff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java\nindex af557ed6b7f82..b8fb33feb7bf4 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java\n@@ -46,6 +46,7 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n \n import static org.elasticsearch.xpack.core.ml.search.SparseVectorQueryBuilder.QUERY_VECTOR_FIELD;\n import static org.hamcrest.CoreMatchers.instanceOf;\n@@ -58,6 +59,8 @@ public class SparseVectorQueryBuilderTests extends AbstractQueryTestCase<SparseV\n     private static final List<WeightedToken> WEIGHTED_TOKENS = List.of(new WeightedToken(\"foo\", .42f));\n     private static final int NUM_TOKENS = WEIGHTED_TOKENS.size();\n \n+    private boolean testWithSparseVectorFieldIndexOptions = false;\n+\n     @Override\n     protected SparseVectorQueryBuilder doCreateTestQueryBuilder() {\n         TokenPruningConfig tokenPruningConfig = randomBoolean()\n@@ -144,6 +147,11 @@ protected Object simulateMethod(Method method, Object[] args) {\n \n     @Override\n     protected void initializeAdditionalMappings(MapperService mapperService) throws IOException {\n+        if (testWithSparseVectorFieldIndexOptions) {\n+            addSparseVectorIndexOptionsMapping(mapperService);\n+            return;\n+        }\n+\n         mapperService.merge(\n             \"_doc\",\n             new CompressedXContent(Strings.toString(PutMappingRequest.simpleMapping(SPARSE_VECTOR_FIELD, \"type=sparse_vector\"))),\n@@ -151,6 +159,15 @@ protected void initializeAdditionalMappings(MapperService mapperService) throws\n         );\n     }\n \n+    private void addSparseVectorIndexOptionsMapping(MapperService mapperService) throws IOException {\n+        String addIndexOptionsTemplate = \"{\\\"properties\\\":{\\\"\"\n+            + SPARSE_VECTOR_FIELD\n+            + \"\\\":{\\\"type\\\":\\\"sparse_vector\\\",\\\"index_options\\\"\"\n+            + \":{\\\"prune\\\":true,\\\"pruning_config\\\":{\\\"tokens_freq_ratio_threshold\\\"\"\n+            + \":12,\\\"tokens_weight_threshold\\\":0.6}}}}}\";\n+        mapperService.merge(\"_doc\", new CompressedXContent(addIndexOptionsTemplate), MapperService.MergeReason.MAPPING_UPDATE);\n+    }\n+\n     @Override\n     protected void doAssertLuceneQuery(SparseVectorQueryBuilder queryBuilder, Query query, SearchExecutionContext context) {\n         assertThat(query, instanceOf(SparseVectorQueryWrapper.class));\n@@ -338,4 +355,27 @@ public void testThatWeCorrectlyRewriteQueryIntoVectors() {\n         assertEquals(queryBuilder.shouldPruneTokens(), ((SparseVectorQueryBuilder) rewrittenQueryBuilder).shouldPruneTokens());\n         assertNotNull(((SparseVectorQueryBuilder) rewrittenQueryBuilder).getQueryVectors());\n     }\n+\n+    public void testWeCorrectlyRewriteQueryIntoVectorsWithIndexOptions() {\n+        wrapTestSparseVectorIndexOptions((c) -> {\n+            SearchExecutionContext searchExecutionContext = createSearchExecutionContext();\n+\n+            TokenPruningConfig defaultTokenPruningConfig = new TokenPruningConfig(12, 0.6f, false);\n+\n+            SparseVectorQueryBuilder queryBuilder = createTestQueryBuilder(null);\n+            QueryBuilder rewrittenQueryBuilder = rewriteAndFetch(queryBuilder, searchExecutionContext);\n+            assertTrue(rewrittenQueryBuilder instanceof SparseVectorQueryBuilder);\n+            assertEquals(queryBuilder.shouldPruneTokens(), ((SparseVectorQueryBuilder) rewrittenQueryBuilder).shouldPruneTokens());\n+            assertNotNull(((SparseVectorQueryBuilder) rewrittenQueryBuilder).getQueryVectors());\n+        });\n+    }\n+\n+    private void wrapTestSparseVectorIndexOptions(Consumer<Boolean> testMethod) {\n+        testWithSparseVectorFieldIndexOptions = true;\n+        try {\n+            testMethod.accept(true);\n+        } finally {\n+            testWithSparseVectorFieldIndexOptions = false;\n+        }\n+    }\n }\n",
  "files_changed": 7,
  "additions": 693,
  "deletions": 19,
  "commit_count": 23,
  "mergeable_state": "",
  "base_commit_sha": "feb44c5c893ea48611290da75acf792512b87038",
  "base_commit_link": "https://github.com/elastic/elasticsearch/commit/feb44c5c893ea48611290da75acf792512b87038",
  "last_processed_time": "2025-04-29T01:17:20",
  "comments": [
    {
      "id": 2064135117,
      "pr_id": 2455055213,
      "body": "I'm not sure if I would add `Inference` here - maybe ML? \r\n\r\nAlso, you should never have to generate these changelogs yourself. Once you tag a PR with the team (e.g. `:ml`) the changelog will be auto-generated and you can edit it as needed. ",
      "created_at": "2025-04-28T17:18:11",
      "user_login": "kderusso",
      "path": "docs/changelog/126739.yaml",
      "position": 0
    },
    {
      "id": 2064137612,
      "pr_id": 2455055213,
      "body": "This is called out as default: false, but the default should be true, correct? ",
      "created_at": "2025-04-28T17:19:33",
      "user_login": "kderusso",
      "path": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
      "position": 0
    },
    {
      "id": 2064138889,
      "pr_id": 2455055213,
      "body": "Just a reminder, that we'll have to open a PR for 8.19 to update the appropriate asciidoc files as well \ud83d\udc4d ",
      "created_at": "2025-04-28T17:20:28",
      "user_login": "kderusso",
      "path": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
      "position": 1
    },
    {
      "id": 2064141345,
      "pr_id": 2455055213,
      "body": "I wonder if we should have two examples here - one \"simple\" example that creates the `sparse_vector` field with defaults, and one that adds the index options? It's just that we show this, and only explain later on that it's optional, so people may assume it's required? WDYT? ",
      "created_at": "2025-04-28T17:21:30",
      "user_login": "kderusso",
      "path": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
      "position": 11
    },
    {
      "id": 2064144290,
      "pr_id": 2455055213,
      "body": "Note: We're going to step on each other a bit here between this PR and https://github.com/elastic/elasticsearch/pull/119967 where I try to create a generic way to define index options for both dense and sparse vector. ",
      "created_at": "2025-04-28T17:23:29",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 48
    },
    {
      "id": 2064195093,
      "pr_id": 2455055213,
      "body": "Hard coded String should be a member",
      "created_at": "2025-04-28T17:57:10",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 0
    },
    {
      "id": 2064199795,
      "pr_id": 2455055213,
      "body": "Do we want to add any validation here, for example fail if someone sets pruning configuration but also sets `prune` to false? We don't do that type of validation at query time but as it's creating a mapping it might be good to have some validation to ensure that we're doing what users think we are? WDYT? ",
      "created_at": "2025-04-28T17:59:12",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 60
    },
    {
      "id": 2064204945,
      "pr_id": 2455055213,
      "body": "Do we need this null check here, since you check for null later on too? We could just do that validation once? ",
      "created_at": "2025-04-28T18:00:40",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 64
    },
    {
      "id": 2064318296,
      "pr_id": 2455055213,
      "body": "Curious why `prune` has to be a `Boolean`/nullable here? Why can't we use a primitive boolean? ",
      "created_at": "2025-04-28T18:49:55",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 192
    },
    {
      "id": 2064321582,
      "pr_id": 2455055213,
      "body": "Curious why we're re-implementing the same configuration defined in [TokenPruningConfig.java](https://github.com/elastic/elasticsearch/blob/0700b24dd0b9fc1aeb7670e3b8224ba45107cd9f/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/TokenPruningConfig.java)?\r\n\r\nIf the answer is just because we think that no one will want to use the boolean to score pruned tokens only, we should talk about whether omitting that is worth this extra complexity. ",
      "created_at": "2025-04-28T18:51:22",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 268
    },
    {
      "id": 2064323300,
      "pr_id": 2455055213,
      "body": "I think we'd want these to be floats and not doubles?",
      "created_at": "2025-04-28T18:52:31",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 0
    },
    {
      "id": 2064324863,
      "pr_id": 2455055213,
      "body": "If no options are specified, we will return an empty object, is that what we want? ",
      "created_at": "2025-04-28T18:53:36",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 304
    },
    {
      "id": 2064326704,
      "pr_id": 2455055213,
      "body": "This doesn't add `prune:true` - what's the expected behavior here? ",
      "created_at": "2025-04-28T18:54:43",
      "user_login": "kderusso",
      "path": "server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java",
      "position": 22
    },
    {
      "id": 2064329961,
      "pr_id": 2455055213,
      "body": "This will break BWC as it is. Any time we change serialization like this, we need to create a new `TransportVersion` and reference this new transport version, so that older transport versions still use the same serialization. ",
      "created_at": "2025-04-28T18:57:00",
      "user_login": "kderusso",
      "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
      "position": 0
    },
    {
      "id": 2064331054,
      "pr_id": 2455055213,
      "body": "This method also needs a transport version check if we change serialization. ",
      "created_at": "2025-04-28T18:57:54",
      "user_login": "kderusso",
      "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
      "position": 0
    },
    {
      "id": 2064347674,
      "pr_id": 2455055213,
      "body": "Curious why `buildIndexOptions` has to be passed in through both the field type and the mapper type here? ",
      "created_at": "2025-04-28T19:07:51",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 101
    },
    {
      "id": 2064348732,
      "pr_id": 2455055213,
      "body": "Note: We could technically make the default `prune: false` here instead of null, as that's what the previous behavior is. ",
      "created_at": "2025-04-28T19:08:43",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 0
    },
    {
      "id": 2064359401,
      "pr_id": 2455055213,
      "body": "You could use something like `Map<String, Object> indexOptionsMap = XContentMapValues.nodeMapValue(propNode, INDEX_OPTIONS_FIELD)` here",
      "created_at": "2025-04-28T19:14:38",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 0
    },
    {
      "id": 2064367917,
      "pr_id": 2455055213,
      "body": "I feel like this parsing method could be cleaned up a bit. There's some duplicated logic in it that may be helped by breaking some of this logic out into smaller methods, and it may benefit from some of the existing pruning logic we define elsewhere.",
      "created_at": "2025-04-28T19:19:05",
      "user_login": "kderusso",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 127
    },
    {
      "id": 2064372697,
      "pr_id": 2455055213,
      "body": "Looks like there is some duplicate logic here that could potentially be broken out. ",
      "created_at": "2025-04-28T19:22:45",
      "user_login": "kderusso",
      "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
      "position": 0
    },
    {
      "id": 2064931672,
      "pr_id": 2455055213,
      "body": "Oh - right. Thanks! This was written up before the confirmation from Serena and Nick",
      "created_at": "2025-04-28T22:35:07",
      "user_login": "markjhoy",
      "path": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
      "position": 0
    },
    {
      "id": 2064942569,
      "pr_id": 2455055213,
      "body": "Yep - makes sense... probably the best way forward is to get them both working, then a new PR to backfill your methods to the sparse vector...",
      "created_at": "2025-04-28T22:39:15",
      "user_login": "markjhoy",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 48
    },
    {
      "id": 2064947369,
      "pr_id": 2455055213,
      "body": "That's not a bad idea... by default it's `true` so, if `prune` is missing, we're good, but if a user explicitly sets `prune: false` and sets the `pruning_config` it might confuse them.",
      "created_at": "2025-04-28T22:41:21",
      "user_login": "markjhoy",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 60
    },
    {
      "id": 2064954006,
      "pr_id": 2455055213,
      "body": "I use it to check if the user has explicitly set it or not... I could use another variable for this, but this way is more concise ;)",
      "created_at": "2025-04-28T22:44:37",
      "user_login": "markjhoy",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 192
    },
    {
      "id": 2064957035,
      "pr_id": 2455055213,
      "body": "Primarily so we don't have `onlyScorePrunedTokens` allowed here... although I'm sure I can add checks for this on my end... I'll have to think about this.",
      "created_at": "2025-04-28T22:45:52",
      "user_login": "markjhoy",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 268
    },
    {
      "id": 2064958523,
      "pr_id": 2455055213,
      "body": "Ah - I thought it was whole numbers only... but yeah, they are floats in the TokenPruningConfig options too...",
      "created_at": "2025-04-28T22:46:30",
      "user_login": "markjhoy",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 0
    },
    {
      "id": 2064961813,
      "pr_id": 2455055213,
      "body": "This is to test the default `prune: true` value... so, it _should_ be an implicit true.",
      "created_at": "2025-04-28T22:50:28",
      "user_login": "markjhoy",
      "path": "server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java",
      "position": 22
    },
    {
      "id": 2064962201,
      "pr_id": 2455055213,
      "body": "Ah - this is probably where my failures are coming in from (and the bane of my existence for the past couple of days ;) ) - thanks for pointing this out!",
      "created_at": "2025-04-28T22:50:57",
      "user_login": "markjhoy",
      "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
      "position": 0
    },
    {
      "id": 2064984543,
      "pr_id": 2455055213,
      "body": "Ah - did not know about that function. Thanks!",
      "created_at": "2025-04-28T23:11:00",
      "user_login": "markjhoy",
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "position": 0
    }
  ],
  "github_reviews": [
    {
      "id": 2800085922,
      "pr_id": 2455055213,
      "body": "First pass review, nice work so far! I would also like to see some yaml tests here, that show mappings and also default/override behavior for different mapping configurations. Thanks for all the work here! ",
      "state": "COMMENTED",
      "created_at": "2025-04-28T19:25:02",
      "user_login": "kderusso"
    },
    {
      "id": 2801189539,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:35:07",
      "user_login": "markjhoy"
    },
    {
      "id": 2801204226,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:39:15",
      "user_login": "markjhoy"
    },
    {
      "id": 2801210534,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:41:21",
      "user_login": "markjhoy"
    },
    {
      "id": 2801218677,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:44:37",
      "user_login": "markjhoy"
    },
    {
      "id": 2801223525,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:45:53",
      "user_login": "markjhoy"
    },
    {
      "id": 2801225225,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:46:30",
      "user_login": "markjhoy"
    },
    {
      "id": 2801230041,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:50:28",
      "user_login": "markjhoy"
    },
    {
      "id": 2801230613,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T22:50:58",
      "user_login": "markjhoy"
    },
    {
      "id": 2801262191,
      "pr_id": 2455055213,
      "body": "",
      "state": "COMMENTED",
      "created_at": "2025-04-28T23:11:00",
      "user_login": "markjhoy"
    }
  ],
  "patches": [
    {
      "id": 1807,
      "pr_id": 2455055213,
      "path": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
      "patch": "@@ -24,6 +24,27 @@ PUT my-index\n }\n ```\n \n+With optional `index_options` for pruning:\n+```console\n+PUT my-index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"text.tokens\": {\n+        \"type\": \"sparse_vector\",\n+        \"index_options\": {\n+          \"prune\": true,\n+          \"pruning_config\": {\n+            \"tokens_freq_ratio_threshold\": 5,\n+            \"tokens_weight_threshold: 0.4\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n See [semantic search with ELSER](docs-content://solutions/search/semantic-search/semantic-search-elser-ingest-pipelines.md) for a complete example on adding documents to a `sparse_vector` mapped field using ELSER.\n \n ## Parameters for `sparse_vector` fields [sparse-vectors-params]\n@@ -36,6 +57,28 @@ The following parameters are accepted by `sparse_vector` fields:\n     * Exclude the field from [_source](/reference/elasticsearch/rest-apis/retrieve-selected-fields.md#source-filtering).\n     * Use [synthetic `_source`](/reference/elasticsearch/mapping-reference/mapping-source-field.md#synthetic-source).\n \n+index_options\n+:    (Optional, object) You can set index options for your  `sparse_vector` field to determine if you should prune tokens, and the parameter configurations for the token pruning. If the pruning options are not set for your `sparse_query` vector on the field, Elasticsearch will use the defaults if set here for the field. The available options for the index options are:\n+\n+Parameters for `index_options` are:\n+\n+`prune`\n+:   (Optional, boolean) [preview] Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance. If `prune` is true but the `pruning_config` is not specified, pruning will occur but default values will be used. Default: true.\n+\n+`pruning_config`\n+:   (Optional, object) [preview] Optional pruning configuration. If enabled, this will omit non-significant tokens from the query in order to improve query performance. This is only used if `prune` is set to `true`. If `prune` is set to `true` but `pruning_config` is not specified, default values will be used.\n+\n+    Parameters for `pruning_config` include:\n+\n+    `tokens_freq_ratio_threshold`\n+    :   (Optional, integer) [preview] Tokens whose frequency is more than `tokens_freq_ratio_threshold` times the average frequency of all tokens in the specified field are considered outliers and pruned. This value must between 1 and 100. Default: `5`.\n+\n+    `tokens_weight_threshold`\n+    :   (Optional, float) [preview] Tokens whose weight is less than `tokens_weight_threshold` are considered insignificant and pruned. This value must be between 0 and 1. Default: `0.4`.\n+\n+    ::::{note}\n+    The default values for `tokens_freq_ratio_threshold` and `tokens_weight_threshold` were chosen based on tests using ELSERv2 that provided the most optimal results.\n+    ::::\n \n \n ## Multi-value sparse vectors [index-multi-value-sparse-vectors]",
      "filename": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
      "status": "modified",
      "changes": 43,
      "additions": 43,
      "deletions": 0
    },
    {
      "id": 1809,
      "pr_id": 2455055213,
      "path": "server/src/main/java/org/elasticsearch/index/IndexVersions.java",
      "patch": "@@ -162,6 +162,7 @@ private static Version parseUnchecked(String version) {\n     public static final IndexVersion UPGRADE_TO_LUCENE_10_2_0 = def(9_022_00_0, Version.LUCENE_10_2_0);\n     public static final IndexVersion UPGRADE_TO_LUCENE_10_2_1 = def(9_023_00_0, Version.LUCENE_10_2_1);\n     public static final IndexVersion DEFAULT_OVERSAMPLE_VALUE_FOR_BBQ = def(9_024_0_00, Version.LUCENE_10_2_1);\n+    public static final IndexVersion SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT = def(9_025_0_00, Version.LUCENE_10_2_1);\n     /*\n      * STOP! READ THIS FIRST! No, really,\n      *        ____ _____ ___  ____  _        ____  _____    _    ____    _____ _   _ ___ ____    _____ ___ ____  ____ _____ _",
      "filename": "server/src/main/java/org/elasticsearch/index/IndexVersions.java",
      "status": "modified",
      "changes": 1,
      "additions": 1,
      "deletions": 0
    },
    {
      "id": 1810,
      "pr_id": 2455055213,
      "path": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "patch": "@@ -22,6 +22,8 @@\n import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.common.logging.DeprecationCategory;\n import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.core.Nullable;\n import org.elasticsearch.index.IndexVersion;\n import org.elasticsearch.index.IndexVersions;\n import org.elasticsearch.index.analysis.NamedAnalyzer;\n@@ -31,13 +33,16 @@\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.MapperBuilderContext;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MappingParserContext;\n import org.elasticsearch.index.mapper.SourceLoader;\n import org.elasticsearch.index.mapper.SourceValueFetcher;\n import org.elasticsearch.index.mapper.TextSearchInfo;\n import org.elasticsearch.index.mapper.ValueFetcher;\n import org.elasticsearch.index.query.SearchExecutionContext;\n import org.elasticsearch.search.fetch.StoredFieldsSpec;\n import org.elasticsearch.search.lookup.Source;\n+import org.elasticsearch.xcontent.ToXContent;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentParser.Token;\n \n@@ -46,6 +51,7 @@\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.stream.Stream;\n \n import static org.elasticsearch.index.query.AbstractQueryBuilder.DEFAULT_BOOST;\n@@ -57,6 +63,7 @@\n public class SparseVectorFieldMapper extends FieldMapper {\n \n     public static final String CONTENT_TYPE = \"sparse_vector\";\n+    public static final String SPARSE_VECTOR_INDEX_OPTIONS = \"index_options\";\n \n     static final String ERROR_MESSAGE_7X = \"[sparse_vector] field type in old 7.x indices is allowed to \"\n         + \"contain [sparse_vector] fields, but they cannot be indexed or searched.\";\n@@ -65,6 +72,9 @@ public class SparseVectorFieldMapper extends FieldMapper {\n \n     static final IndexVersion NEW_SPARSE_VECTOR_INDEX_VERSION = IndexVersions.NEW_SPARSE_VECTOR;\n     static final IndexVersion SPARSE_VECTOR_IN_FIELD_NAMES_INDEX_VERSION = IndexVersions.SPARSE_VECTOR_IN_FIELD_NAMES_SUPPORT;\n+    static final IndexVersion SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_VERSION = IndexVersions.SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT;\n+\n+    private final SparseVectorFieldMapper.IndexOptions indexOptions;\n \n     private static SparseVectorFieldMapper toType(FieldMapper in) {\n         return (SparseVectorFieldMapper) in;\n@@ -73,9 +83,23 @@ private static SparseVectorFieldMapper toType(FieldMapper in) {\n     public static class Builder extends FieldMapper.Builder {\n         private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType().isStored(), false);\n         private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<IndexOptions> indexOptions;\n \n         public Builder(String name) {\n             super(name);\n+            this.indexOptions = new Parameter<>(\n+                SPARSE_VECTOR_INDEX_OPTIONS,\n+                true,\n+                () -> null,\n+                (n, c, o) -> o == null ? getDefaultIndexOptions(c) : parseIndexOptions(c, o),\n+                m -> toType(m).fieldType().indexOptions,\n+                (b, n, v) -> {\n+                    if (v != null) {\n+                        b.field(n, v);\n+                    }\n+                },\n+                Objects::toString\n+            );\n         }\n \n         public Builder setStored(boolean value) {\n@@ -85,19 +109,63 @@ public Builder setStored(boolean value) {\n \n         @Override\n         protected Parameter<?>[] getParameters() {\n-            return new Parameter<?>[] { stored, meta };\n+            return new Parameter<?>[] { stored, meta, indexOptions };\n         }\n \n         @Override\n         public SparseVectorFieldMapper build(MapperBuilderContext context) {\n+            IndexOptions buildIndexOptions = indexOptions.getValue();\n+\n+            if (buildIndexOptions == null) {\n+                buildIndexOptions = new IndexOptions(\n+                    true,\n+                    new PruningConfig(PruningConfig.DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD, PruningConfig.DEFAULT_TOKENS_WEIGHT_THRESHOLD)\n+                );\n+            }\n+\n             return new SparseVectorFieldMapper(\n                 leafName(),\n-                new SparseVectorFieldType(context.buildFullName(leafName()), stored.getValue(), meta.getValue()),\n-                builderParams(this, context)\n+                new SparseVectorFieldType(context.buildFullName(leafName()), stored.getValue(), meta.getValue(), buildIndexOptions),\n+                builderParams(this, context),\n+                buildIndexOptions\n             );\n         }\n     }\n \n+    public IndexOptions getIndexOptions() {\n+        return this.indexOptions;\n+    }\n+\n+    private static SparseVectorFieldMapper.IndexOptions getDefaultIndexOptions(MappingParserContext context) {\n+        if (context.indexVersionCreated().before(SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_VERSION)) {\n+            // don't set defaults if this index was created before\n+            // we added this functionality in, so it will\n+            // not change current index behaviour\n+            return new IndexOptions(false, null);\n+        }\n+\n+        // index options are not set - for new indices, we\n+        // need to set pruning to true by default\n+        // with a default pruning configuration\n+        return new IndexOptions(\n+            true,\n+            new PruningConfig(PruningConfig.DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD, PruningConfig.DEFAULT_TOKENS_WEIGHT_THRESHOLD)\n+        );\n+    }\n+\n+    private static SparseVectorFieldMapper.IndexOptions parseIndexOptions(MappingParserContext context, Object propNode) {\n+        Map<String, Object> indexOptionsMap = XContentMapValues.nodeMapValue(propNode, SPARSE_VECTOR_INDEX_OPTIONS);\n+\n+        Boolean prune = IndexOptions.parseIndexOptionsPruneValue(indexOptionsMap);\n+        PruningConfig pruningConfig = IndexOptions.parseIndexOptionsPruningConfig(prune, indexOptionsMap);\n+\n+        if (prune == null && pruningConfig == null) {\n+            return getDefaultIndexOptions(context);\n+        }\n+\n+        return new SparseVectorFieldMapper.IndexOptions(prune, pruningConfig);\n+    }\n+\n     public static final TypeParser PARSER = new TypeParser((n, c) -> {\n         if (c.indexVersionCreated().before(PREVIOUS_SPARSE_VECTOR_INDEX_VERSION)) {\n             deprecationLogger.warn(DeprecationCategory.MAPPINGS, \"sparse_vector\", ERROR_MESSAGE_7X);\n@@ -109,9 +177,21 @@ public SparseVectorFieldMapper build(MapperBuilderContext context) {\n     }, notInMultiFields(CONTENT_TYPE));\n \n     public static final class SparseVectorFieldType extends MappedFieldType {\n+        private final IndexOptions indexOptions;\n \n         public SparseVectorFieldType(String name, boolean isStored, Map<String, String> meta) {\n             super(name, true, isStored, false, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);\n+            this.indexOptions = null;\n+        }\n+\n+        public SparseVectorFieldType(\n+            String name,\n+            boolean isStored,\n+            Map<String, String> meta,\n+            @Nullable SparseVectorFieldMapper.IndexOptions indexOptions\n+        ) {\n+            super(name, true, isStored, false, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);\n+            this.indexOptions = indexOptions;\n         }\n \n         @Override\n@@ -157,8 +237,14 @@ private static String indexedValueForSearch(Object value) {\n         }\n     }\n \n-    private SparseVectorFieldMapper(String simpleName, MappedFieldType mappedFieldType, BuilderParams builderParams) {\n+    private SparseVectorFieldMapper(\n+        String simpleName,\n+        MappedFieldType mappedFieldType,\n+        BuilderParams builderParams,\n+        @Nullable IndexOptions indexOptions\n+    ) {\n         super(simpleName, mappedFieldType, builderParams);\n+        this.indexOptions = indexOptions;\n     }\n \n     @Override\n@@ -364,4 +450,227 @@ public void reset() {\n         }\n     }\n \n+    public static class IndexOptions implements ToXContent {\n+        public static final String PRUNE_FIELD_NAME = \"prune\";\n+        public static final String PRUNING_CONFIG_FIELD_NAME = \"pruning_config\";\n+\n+        final Boolean prune;\n+        final PruningConfig pruningConfig;\n+\n+        IndexOptions(@Nullable Boolean prune, @Nullable PruningConfig pruningConfig) {\n+            this.prune = prune;\n+            this.pruningConfig = pruningConfig;\n+        }\n+\n+        public Boolean getPrune() {\n+            return prune;\n+        }\n+\n+        public PruningConfig getPruningConfig() {\n+            return pruningConfig;\n+        }\n+\n+        @Override\n+        public final boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+            if (other instanceof IndexOptions otherOptions) {\n+                return Objects.equals(prune, otherOptions.prune) && Objects.equals(pruningConfig, otherOptions.pruningConfig);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public final int hashCode() {\n+            return Objects.hash(prune, pruningConfig);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (prune == null && pruningConfig == null) {\n+                return builder;\n+            }\n+\n+            builder.startObject();\n+            if (prune != null) {\n+                builder.field(PRUNE_FIELD_NAME, prune);\n+            }\n+            if (pruningConfig != null) {\n+                builder.field(PRUNING_CONFIG_FIELD_NAME, pruningConfig);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        public static Boolean parseIndexOptionsPruneValue(Map<String, Object> indexOptionsMap) {\n+            Object shouldPrune = indexOptionsMap.remove(IndexOptions.PRUNE_FIELD_NAME);\n+            if (shouldPrune == null) {\n+                return null;\n+            }\n+\n+            if ((shouldPrune instanceof Boolean) == false) {\n+                throw new MapperParsingException(\"[index_options] field [prune] should be true or false\");\n+            }\n+\n+            return ((Boolean) shouldPrune);\n+        }\n+\n+        public static PruningConfig parseIndexOptionsPruningConfig(Boolean prune, Map<String, Object> indexOptionsMap) {\n+            Object pruningConfiguration = indexOptionsMap.remove(IndexOptions.PRUNING_CONFIG_FIELD_NAME);\n+            if (pruningConfiguration == null) {\n+                return null;\n+            }\n+            if ((pruningConfiguration instanceof Map) == false) {\n+                throw new MapperParsingException(\"[index_options] field [pruning_config] should be a map\");\n+            }\n+\n+            if (prune != null && prune == false) {\n+                throw new MapperParsingException(\"[index_options] field [pruning_config] should not be set if [prune] is false\");\n+            }\n+\n+            return PruningConfig.parsePruningConfig(pruningConfiguration);\n+        }\n+    }\n+\n+    public static class PruningConfig implements ToXContent {\n+        public static final String TOKENS_FREQ_RATIO_THRESHOLD_FIELD_NAME = \"tokens_freq_ratio_threshold\";\n+        public static final String TOKENS_WEIGHT_THRESHOLD_FIELD_NAME = \"tokens_weight_threshold\";\n+\n+        public static float DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD = 5;\n+        public static float MIN_TOKENS_FREQ_RATIO_THRESHOLD = 1;\n+        public static float MAX_TOKENS_FREQ_RATIO_THRESHOLD = 100;\n+\n+        public static float DEFAULT_TOKENS_WEIGHT_THRESHOLD = 0.4f;\n+        public static float MIN_TOKENS_WEIGHT_THRESHOLD = 0.0f;\n+        public static float MAX_TOKENS_WEIGHT_THRESHOLD = 1.0f;\n+\n+        final Float tokens_freq_ratio_threshold;\n+        final Float tokens_weight_threshold;\n+\n+        PruningConfig(@Nullable Float tokens_freq_ratio_threshold, @Nullable Float tokens_weight_threshold) {\n+            this.tokens_freq_ratio_threshold = tokens_freq_ratio_threshold;\n+            this.tokens_weight_threshold = tokens_weight_threshold;\n+        }\n+\n+        public float getTokensFreqRatioThresholdOrDefault() {\n+            if (tokens_freq_ratio_threshold == null) {\n+                return DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD;\n+            }\n+            return tokens_freq_ratio_threshold;\n+        }\n+\n+        public float getTokensWeightThresholdOrDefault() {\n+            if (tokens_weight_threshold == null) {\n+                return DEFAULT_TOKENS_WEIGHT_THRESHOLD;\n+            }\n+            return tokens_weight_threshold;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            if (tokens_freq_ratio_threshold != null) {\n+                builder.field(TOKENS_FREQ_RATIO_THRESHOLD_FIELD_NAME, tokens_freq_ratio_threshold);\n+            }\n+            if (tokens_weight_threshold != null) {\n+                builder.field(TOKENS_WEIGHT_THRESHOLD_FIELD_NAME, tokens_weight_threshold);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public final boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+            if (other instanceof PruningConfig otherConfig) {\n+                return Objects.equals(tokens_freq_ratio_threshold, otherConfig.tokens_freq_ratio_threshold)\n+                    && Objects.equals(tokens_weight_threshold, otherConfig.tokens_weight_threshold);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public final int hashCode() {\n+            return Objects.hash(tokens_freq_ratio_threshold, tokens_weight_threshold);\n+        }\n+\n+        public static PruningConfig parsePruningConfig(Object pruningConfiguration) {\n+            Map<String, Object> pruningConfigMap = XContentMapValues.nodeMapValue(pruningConfiguration, SPARSE_VECTOR_INDEX_OPTIONS);\n+\n+            Object mappedTokensFreqRatioThreshold = pruningConfigMap.remove(TOKENS_FREQ_RATIO_THRESHOLD_FIELD_NAME);\n+            Object mappedTokensWeightThreshold = pruningConfigMap.remove(TOKENS_WEIGHT_THRESHOLD_FIELD_NAME);\n+\n+            if (pruningConfigMap.isEmpty() == false) {\n+                throw new MapperParsingException(\"[index_options] field [pruning_config] has unknown fields\");\n+            }\n+\n+            Float tokensFreqRatioThreshold = parseTokensFreqRatioThreshold(mappedTokensFreqRatioThreshold);\n+            Float tokensWeightThreshold = parseTokensWeightThreshold(mappedTokensWeightThreshold);\n+\n+            if (tokensFreqRatioThreshold != null || tokensWeightThreshold != null) {\n+                return new PruningConfig(tokensFreqRatioThreshold, tokensWeightThreshold);\n+            }\n+\n+            return null;\n+        }\n+\n+        private static Float parseFloatNumberFromObject(Object numberObject) {\n+            if (numberObject instanceof Integer intValue) {\n+                return (float) intValue;\n+            } else if (numberObject instanceof Float floatValue) {\n+                return floatValue;\n+            } else if (numberObject instanceof Double doubleValue) {\n+                return ((Double) numberObject).floatValue();\n+            }\n+            return null;\n+        }\n+\n+        private static Float parseTokensWeightThreshold(Object mappedTokensWeightThreshold) {\n+            if (mappedTokensWeightThreshold == null) {\n+                return null;\n+            }\n+\n+            Float tokensWeightThreshold = parseFloatNumberFromObject(mappedTokensWeightThreshold);\n+\n+            if (tokensWeightThreshold == null) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\"\n+                );\n+            }\n+\n+            if (tokensWeightThreshold < PruningConfig.MIN_TOKENS_WEIGHT_THRESHOLD\n+                || tokensWeightThreshold > PruningConfig.MAX_TOKENS_WEIGHT_THRESHOLD) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\"\n+                );\n+            }\n+            return tokensWeightThreshold;\n+        }\n+\n+        private static Float parseTokensFreqRatioThreshold(Object mappedTokensFreqRatioThreshold) {\n+            if (mappedTokensFreqRatioThreshold == null) {\n+                return null;\n+            }\n+\n+            Float tokensFreqRatioThreshold = parseFloatNumberFromObject(mappedTokensFreqRatioThreshold);\n+\n+            if (tokensFreqRatioThreshold == null) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\"\n+                );\n+            }\n+\n+            if (tokensFreqRatioThreshold < PruningConfig.MIN_TOKENS_FREQ_RATIO_THRESHOLD\n+                || tokensFreqRatioThreshold > PruningConfig.MAX_TOKENS_FREQ_RATIO_THRESHOLD) {\n+                throw new MapperParsingException(\n+                    \"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\"\n+                );\n+            }\n+\n+            return tokensFreqRatioThreshold;\n+        }\n+    }\n }",
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
      "status": "modified",
      "changes": 317,
      "additions": 313,
      "deletions": 4
    },
    {
      "id": 1808,
      "pr_id": 2455055213,
      "path": "server/src/main/java/org/elasticsearch/TransportVersions.java",
      "patch": "@@ -228,6 +228,7 @@ static TransportVersion def(int id) {\n     public static final TransportVersion DENSE_VECTOR_OFF_HEAP_STATS = def(9_062_00_0);\n     public static final TransportVersion RANDOM_SAMPLER_QUERY_BUILDER = def(9_063_0_00);\n     public static final TransportVersion SETTINGS_IN_DATA_STREAMS = def(9_064_0_00);\n+    public static final TransportVersion SPARSE_VECTOR_FIELD_PRUNING_OPTIONS = def(9_065_0_00);\n \n     /*\n      * STOP! READ THIS FIRST! No, really,",
      "filename": "server/src/main/java/org/elasticsearch/TransportVersions.java",
      "status": "modified",
      "changes": 1,
      "additions": 1,
      "deletions": 0
    },
    {
      "id": 1811,
      "pr_id": 2455055213,
      "path": "server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java",
      "patch": "@@ -67,6 +67,34 @@ protected void minimalMapping(XContentBuilder b) throws IOException {\n         b.field(\"type\", \"sparse_vector\");\n     }\n \n+    protected void mappingWithDefaultIndexOptions(XContentBuilder b) throws IOException {\n+        b.field(\"type\", \"sparse_vector\");\n+        b.startObject(\"index_options\");\n+        b.field(\"prune\", true);\n+        b.startObject(\"pruning_config\");\n+        b.field(\"tokens_freq_ratio_threshold\", SparseVectorFieldMapper.PruningConfig.DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD);\n+        b.field(\"tokens_weight_threshold\", SparseVectorFieldMapper.PruningConfig.DEFAULT_TOKENS_WEIGHT_THRESHOLD);\n+        b.endObject();\n+        b.endObject();\n+    }\n+\n+    protected void mappingWithIndexOptionsPrune(XContentBuilder b) throws IOException {\n+        b.field(\"type\", \"sparse_vector\");\n+        b.startObject(\"index_options\");\n+        b.field(\"prune\", true);\n+        b.endObject();\n+    }\n+\n+    protected void mappingWithIndexOptionsPruningConfig(XContentBuilder b) throws IOException {\n+        b.field(\"type\", \"sparse_vector\");\n+        b.startObject(\"index_options\");\n+        b.startObject(\"pruning_config\");\n+        b.field(\"tokens_freq_ratio_threshold\", 5.0);\n+        b.field(\"tokens_weight_threshold\", 0.4);\n+        b.endObject();\n+        b.endObject();\n+    }\n+\n     @Override\n     protected boolean supportsStoredFields() {\n         return false;\n@@ -96,7 +124,59 @@ private static int getFrequency(TokenStream tk) throws IOException {\n \n     public void testDefaults() throws Exception {\n         DocumentMapper mapper = createDocumentMapper(fieldMapping(this::minimalMapping));\n-        assertEquals(Strings.toString(fieldMapping(this::minimalMapping)), mapper.mappingSource().toString());\n+        assertEquals(Strings.toString(fieldMapping(this::mappingWithDefaultIndexOptions)), mapper.mappingSource().toString());\n+\n+        ParsedDocument doc1 = mapper.parse(source(this::writeField));\n+\n+        List<IndexableField> fields = doc1.rootDoc().getFields(\"field\");\n+        assertEquals(2, fields.size());\n+        assertThat(fields.get(0), Matchers.instanceOf(XFeatureField.class));\n+        XFeatureField featureField1 = null;\n+        XFeatureField featureField2 = null;\n+        for (IndexableField field : fields) {\n+            if (field.stringValue().equals(\"ten\")) {\n+                featureField1 = (XFeatureField) field;\n+            } else if (field.stringValue().equals(\"twenty\")) {\n+                featureField2 = (XFeatureField) field;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        int freq1 = getFrequency(featureField1.tokenStream(null, null));\n+        int freq2 = getFrequency(featureField2.tokenStream(null, null));\n+        assertTrue(freq1 < freq2);\n+    }\n+\n+    public void testWithIndexOptionsPrune() throws Exception {\n+        DocumentMapper mapper = createDocumentMapper(fieldMapping(this::mappingWithIndexOptionsPrune));\n+        assertEquals(Strings.toString(fieldMapping(this::mappingWithIndexOptionsPrune)), mapper.mappingSource().toString());\n+\n+        ParsedDocument doc1 = mapper.parse(source(this::writeField));\n+\n+        List<IndexableField> fields = doc1.rootDoc().getFields(\"field\");\n+        assertEquals(2, fields.size());\n+        assertThat(fields.get(0), Matchers.instanceOf(XFeatureField.class));\n+        XFeatureField featureField1 = null;\n+        XFeatureField featureField2 = null;\n+        for (IndexableField field : fields) {\n+            if (field.stringValue().equals(\"ten\")) {\n+                featureField1 = (XFeatureField) field;\n+            } else if (field.stringValue().equals(\"twenty\")) {\n+                featureField2 = (XFeatureField) field;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        int freq1 = getFrequency(featureField1.tokenStream(null, null));\n+        int freq2 = getFrequency(featureField2.tokenStream(null, null));\n+        assertTrue(freq1 < freq2);\n+    }\n+\n+    public void testWithIndexOptionsPruningConfig() throws Exception {\n+        DocumentMapper mapper = createDocumentMapper(fieldMapping(this::mappingWithIndexOptionsPruningConfig));\n+        assertEquals(Strings.toString(fieldMapping(this::mappingWithIndexOptionsPruningConfig)), mapper.mappingSource().toString());\n \n         ParsedDocument doc1 = mapper.parse(source(this::writeField));\n \n@@ -202,6 +282,108 @@ public void testCannotBeUsedInMultiFields() {\n         assertThat(e.getMessage(), containsString(\"Field [feature] of type [sparse_vector] can't be used in multifields\"));\n     }\n \n+    public void testPruneMustBeBoolean() {\n+        Exception e = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.field(\"prune\", \"othervalue\");\n+            b.endObject();\n+        })));\n+        assertThat(e.getMessage(), containsString(\"[index_options] field [prune] should be true or false\"));\n+    }\n+\n+    public void testPruningConfigurationIsMap() {\n+        Exception e = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.field(\"pruning_config\", \"this_is_not_a_map\");\n+            b.endObject();\n+        })));\n+        assertThat(e.getMessage(), containsString(\"index_options] field [pruning_config] should be a map\"));\n+    }\n+\n+    public void testTokensFreqRatioCorrect() {\n+        Exception eTestInteger = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_freq_ratio_threshold\", \"notaninteger\");\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestInteger.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\")\n+        );\n+\n+        Exception eTestRangeLower = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_freq_ratio_threshold\", -2);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeLower.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\")\n+        );\n+\n+        Exception eTestRangeHigher = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_freq_ratio_threshold\", 101);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeHigher.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_freq_ratio_threshold] field should be a number between 1 and 100\")\n+        );\n+    }\n+\n+    public void testTokensWeightThresholdCorrect() {\n+        Exception eTestDouble = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_weight_threshold\", \"notadouble\");\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestDouble.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\")\n+        );\n+\n+        Exception eTestRangeLower = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_weight_threshold\", -0.1);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeLower.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\")\n+        );\n+\n+        Exception eTestRangeHigher = expectThrows(MapperParsingException.class, () -> createMapperService(fieldMapping(b -> {\n+            b.field(\"type\", \"sparse_vector\");\n+            b.startObject(\"index_options\");\n+            b.startObject(\"pruning_config\");\n+            b.field(\"tokens_weight_threshold\", 1.1);\n+            b.endObject();\n+            b.endObject();\n+        })));\n+        assertThat(\n+            eTestRangeHigher.getMessage(),\n+            containsString(\"[pruning_config] field [tokens_weight_threshold] field should be a number between 0.0 and 1.0\")\n+        );\n+    }\n+\n     public void testStoreIsNotUpdateable() throws IOException {\n         var mapperService = createMapperService(fieldMapping(this::minimalMapping));\n         XContentBuilder mapping = jsonBuilder().startObject()",
      "filename": "server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java",
      "status": "modified",
      "changes": 184,
      "additions": 183,
      "deletions": 1
    },
    {
      "id": 1812,
      "pr_id": 2455055213,
      "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
      "patch": "@@ -18,6 +18,10 @@\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.core.Nullable;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.Mapping;\n+import org.elasticsearch.index.mapper.RootObjectMapper;\n+import org.elasticsearch.index.mapper.vectors.SparseVectorFieldMapper;\n import org.elasticsearch.index.query.AbstractQueryBuilder;\n import org.elasticsearch.index.query.QueryBuilder;\n import org.elasticsearch.index.query.QueryRewriteContext;\n@@ -61,7 +65,7 @@ public class SparseVectorQueryBuilder extends AbstractQueryBuilder<SparseVectorQ\n     private final List<WeightedToken> queryVectors;\n     private final String inferenceId;\n     private final String query;\n-    private final boolean shouldPruneTokens;\n+    private final Boolean shouldPruneTokens;\n \n     private final SetOnce<TextExpansionResults> weightedTokensSupplier;\n \n@@ -81,13 +85,11 @@ public SparseVectorQueryBuilder(\n         @Nullable TokenPruningConfig tokenPruningConfig\n     ) {\n         this.fieldName = Objects.requireNonNull(fieldName, \"[\" + NAME + \"] requires a [\" + FIELD_FIELD.getPreferredName() + \"]\");\n-        this.shouldPruneTokens = (shouldPruneTokens != null ? shouldPruneTokens : DEFAULT_PRUNE);\n+        this.shouldPruneTokens = shouldPruneTokens;\n         this.queryVectors = queryVectors;\n         this.inferenceId = inferenceId;\n         this.query = query;\n-        this.tokenPruningConfig = (tokenPruningConfig != null\n-            ? tokenPruningConfig\n-            : (this.shouldPruneTokens ? new TokenPruningConfig() : null));\n+        this.tokenPruningConfig = tokenPruningConfig;\n         this.weightedTokensSupplier = null;\n \n         // Preserve BWC error messaging\n@@ -124,7 +126,11 @@ public SparseVectorQueryBuilder(\n     public SparseVectorQueryBuilder(StreamInput in) throws IOException {\n         super(in);\n         this.fieldName = in.readString();\n-        this.shouldPruneTokens = in.readBoolean();\n+        if (in.getTransportVersion().onOrAfter(TransportVersions.SPARSE_VECTOR_FIELD_PRUNING_OPTIONS)) {\n+            this.shouldPruneTokens = in.readOptionalBoolean();\n+        } else {\n+            this.shouldPruneTokens = in.readBoolean();\n+        }\n         this.queryVectors = in.readOptionalCollectionAsList(WeightedToken::new);\n         this.inferenceId = in.readOptionalString();\n         this.query = in.readOptionalString();\n@@ -159,7 +165,7 @@ public String getQuery() {\n     }\n \n     public boolean shouldPruneTokens() {\n-        return shouldPruneTokens;\n+        return shouldPruneTokens != null ? shouldPruneTokens : DEFAULT_PRUNE;\n     }\n \n     public TokenPruningConfig getTokenPruningConfig() {\n@@ -173,7 +179,11 @@ protected void doWriteTo(StreamOutput out) throws IOException {\n         }\n \n         out.writeString(fieldName);\n-        out.writeBoolean(shouldPruneTokens);\n+        if (out.getTransportVersion().onOrAfter(TransportVersions.SPARSE_VECTOR_FIELD_PRUNING_OPTIONS)) {\n+            out.writeOptionalBoolean(shouldPruneTokens);\n+        } else {\n+            out.writeBoolean(shouldPruneTokens != null && shouldPruneTokens);\n+        }\n         out.writeOptionalCollection(queryVectors);\n         out.writeOptionalString(inferenceId);\n         out.writeOptionalString(query);\n@@ -196,7 +206,9 @@ protected void doXContent(XContentBuilder builder, Params params) throws IOExcep\n             }\n             builder.field(QUERY_FIELD.getPreferredName(), query);\n         }\n-        builder.field(PRUNE_FIELD.getPreferredName(), shouldPruneTokens);\n+        if (shouldPruneTokens != null) {\n+            builder.field(PRUNE_FIELD.getPreferredName(), shouldPruneTokens);\n+        }\n         if (tokenPruningConfig != null) {\n             builder.field(PRUNING_CONFIG_FIELD.getPreferredName(), tokenPruningConfig);\n         }\n@@ -222,28 +234,46 @@ protected Query doToQuery(SearchExecutionContext context) throws IOException {\n             );\n         }\n \n-        return (shouldPruneTokens)\n-            ? WeightedTokensUtils.queryBuilderWithPrunedTokens(fieldName, tokenPruningConfig, queryVectors, ft, context)\n+        // if the query options for pruning are not set,\n+        // we need to check the index options for this field\n+        // and use those if set.\n+        SparseVectorFieldMapper sparseVectorFieldMapper = getSparseVectorFieldMapperForSearchExecution(fieldName, context);\n+        TokenPruningSet pruningOptions = setPruningConfigFromIndexIfNeeded(shouldPruneTokens, tokenPruningConfig, sparseVectorFieldMapper);\n+\n+        return pruningOptions.pruneTokens\n+            ? WeightedTokensUtils.queryBuilderWithPrunedTokens(fieldName, pruningOptions.pruningConfig, queryVectors, ft, context)\n             : WeightedTokensUtils.queryBuilderWithAllTokens(fieldName, queryVectors, ft, context);\n     }\n \n     @Override\n     protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) {\n         if (queryVectors != null) {\n             return this;\n-        } else if (weightedTokensSupplier != null) {\n+        }\n+\n+        if (weightedTokensSupplier != null) {\n             TextExpansionResults textExpansionResults = weightedTokensSupplier.get();\n             if (textExpansionResults == null) {\n                 return this; // No results yet\n             }\n \n+            // if the query options for pruning are not set,\n+            // we need to check the index options for this field\n+            // and use those if set.\n+            SparseVectorFieldMapper sparseVectorFieldMapper = getSparseVectorFieldMapperForQueryRewrite(fieldName, queryRewriteContext);\n+            TokenPruningSet pruningOptions = setPruningConfigFromIndexIfNeeded(\n+                shouldPruneTokens,\n+                tokenPruningConfig,\n+                sparseVectorFieldMapper\n+            );\n+\n             return new SparseVectorQueryBuilder(\n                 fieldName,\n                 textExpansionResults.getWeightedTokens(),\n                 null,\n                 null,\n-                shouldPruneTokens,\n-                tokenPruningConfig\n+                pruningOptions.pruneTokens,\n+                pruningOptions.pruningConfig\n             );\n         } else if (inferenceId == null) {\n             // Edge case, where inference_id was not specified in the request,\n@@ -378,4 +408,72 @@ public static SparseVectorQueryBuilder fromXContent(XContentParser parser) {\n             throw new ParsingException(parser.getTokenLocation(), e.getMessage(), e);\n         }\n     }\n+\n+    private record IndexFieldPruningSettings(@Nullable Boolean prune, @Nullable TokenPruningConfig pruningConfig) {}\n+\n+    private IndexFieldPruningSettings getIndexFieldPruningSettings(SparseVectorFieldMapper sparseVectorFieldMapper) {\n+        if (sparseVectorFieldMapper == null) {\n+            return new IndexFieldPruningSettings(null, null);\n+        }\n+\n+        SparseVectorFieldMapper.IndexOptions indexOptions = sparseVectorFieldMapper.getIndexOptions();\n+        if (indexOptions == null) {\n+            return new IndexFieldPruningSettings(null, null);\n+        }\n+\n+        Boolean indexOptionsPrune = indexOptions.getPrune();\n+\n+        SparseVectorFieldMapper.PruningConfig indexPruningConfig = indexOptions.getPruningConfig();\n+        TokenPruningConfig indexTokenPruningConfig = indexPruningConfig != null\n+            ? new TokenPruningConfig(\n+                indexPruningConfig.getTokensFreqRatioThresholdOrDefault(),\n+                indexPruningConfig.getTokensWeightThresholdOrDefault(),\n+                false\n+            )\n+            : null;\n+\n+        return new IndexFieldPruningSettings(indexOptionsPrune, indexTokenPruningConfig);\n+    }\n+\n+    private SparseVectorFieldMapper getSparseVectorFieldMapper(String fieldName, Mapping fieldMapping) {\n+        RootObjectMapper rootMapping = fieldMapping.getRoot();\n+        Mapper thisMapper = rootMapping.getMapper(fieldName);\n+        if (thisMapper instanceof SparseVectorFieldMapper) {\n+            return (SparseVectorFieldMapper) thisMapper;\n+        }\n+\n+        return null;\n+    }\n+\n+    private SparseVectorFieldMapper getSparseVectorFieldMapperForSearchExecution(String fieldName, SearchExecutionContext context) {\n+        return getSparseVectorFieldMapper(fieldName, context.getMappingLookup().getMapping());\n+    }\n+\n+    private SparseVectorFieldMapper getSparseVectorFieldMapperForQueryRewrite(String fieldName, QueryRewriteContext context) {\n+        return getSparseVectorFieldMapper(fieldName, context.getMappingLookup().getMapping());\n+    }\n+\n+    private record TokenPruningSet(boolean pruneTokens, TokenPruningConfig pruningConfig) {}\n+\n+    private TokenPruningSet setPruningConfigFromIndexIfNeeded(\n+        Boolean queryPruneTokens,\n+        TokenPruningConfig queryPruningConfig,\n+        SparseVectorFieldMapper fieldMapper\n+    ) {\n+        boolean doPruneTokens = false;\n+        TokenPruningConfig setTokenPruningConfig = queryPruningConfig;\n+        if (queryPruneTokens == null || queryPruningConfig == null) {\n+            IndexFieldPruningSettings indexPruningSettings = getIndexFieldPruningSettings(fieldMapper);\n+            if (shouldPruneTokens == null && indexPruningSettings.prune != null && indexPruningSettings.prune) {\n+                doPruneTokens = true;\n+            }\n+            if (setTokenPruningConfig == null && indexPruningSettings.pruningConfig != null) {\n+                setTokenPruningConfig = indexPruningSettings.pruningConfig;\n+            }\n+        } else {\n+            doPruneTokens = queryPruneTokens;\n+        }\n+\n+        return new TokenPruningSet(doPruneTokens, setTokenPruningConfig);\n+    }\n }",
      "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
      "status": "modified",
      "changes": 126,
      "additions": 112,
      "deletions": 14
    },
    {
      "id": 1813,
      "pr_id": 2455055213,
      "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java",
      "patch": "@@ -46,6 +46,7 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n \n import static org.elasticsearch.xpack.core.ml.search.SparseVectorQueryBuilder.QUERY_VECTOR_FIELD;\n import static org.hamcrest.CoreMatchers.instanceOf;\n@@ -58,6 +59,8 @@ public class SparseVectorQueryBuilderTests extends AbstractQueryTestCase<SparseV\n     private static final List<WeightedToken> WEIGHTED_TOKENS = List.of(new WeightedToken(\"foo\", .42f));\n     private static final int NUM_TOKENS = WEIGHTED_TOKENS.size();\n \n+    private boolean testWithSparseVectorFieldIndexOptions = false;\n+\n     @Override\n     protected SparseVectorQueryBuilder doCreateTestQueryBuilder() {\n         TokenPruningConfig tokenPruningConfig = randomBoolean()\n@@ -144,13 +147,27 @@ protected Object simulateMethod(Method method, Object[] args) {\n \n     @Override\n     protected void initializeAdditionalMappings(MapperService mapperService) throws IOException {\n+        if (testWithSparseVectorFieldIndexOptions) {\n+            addSparseVectorIndexOptionsMapping(mapperService);\n+            return;\n+        }\n+\n         mapperService.merge(\n             \"_doc\",\n             new CompressedXContent(Strings.toString(PutMappingRequest.simpleMapping(SPARSE_VECTOR_FIELD, \"type=sparse_vector\"))),\n             MapperService.MergeReason.MAPPING_UPDATE\n         );\n     }\n \n+    private void addSparseVectorIndexOptionsMapping(MapperService mapperService) throws IOException {\n+        String addIndexOptionsTemplate = \"{\\\"properties\\\":{\\\"\"\n+            + SPARSE_VECTOR_FIELD\n+            + \"\\\":{\\\"type\\\":\\\"sparse_vector\\\",\\\"index_options\\\"\"\n+            + \":{\\\"prune\\\":true,\\\"pruning_config\\\":{\\\"tokens_freq_ratio_threshold\\\"\"\n+            + \":12,\\\"tokens_weight_threshold\\\":0.6}}}}}\";\n+        mapperService.merge(\"_doc\", new CompressedXContent(addIndexOptionsTemplate), MapperService.MergeReason.MAPPING_UPDATE);\n+    }\n+\n     @Override\n     protected void doAssertLuceneQuery(SparseVectorQueryBuilder queryBuilder, Query query, SearchExecutionContext context) {\n         assertThat(query, instanceOf(SparseVectorQueryWrapper.class));\n@@ -338,4 +355,27 @@ public void testThatWeCorrectlyRewriteQueryIntoVectors() {\n         assertEquals(queryBuilder.shouldPruneTokens(), ((SparseVectorQueryBuilder) rewrittenQueryBuilder).shouldPruneTokens());\n         assertNotNull(((SparseVectorQueryBuilder) rewrittenQueryBuilder).getQueryVectors());\n     }\n+\n+    public void testWeCorrectlyRewriteQueryIntoVectorsWithIndexOptions() {\n+        wrapTestSparseVectorIndexOptions((c) -> {\n+            SearchExecutionContext searchExecutionContext = createSearchExecutionContext();\n+\n+            TokenPruningConfig defaultTokenPruningConfig = new TokenPruningConfig(12, 0.6f, false);\n+\n+            SparseVectorQueryBuilder queryBuilder = createTestQueryBuilder(null);\n+            QueryBuilder rewrittenQueryBuilder = rewriteAndFetch(queryBuilder, searchExecutionContext);\n+            assertTrue(rewrittenQueryBuilder instanceof SparseVectorQueryBuilder);\n+            assertEquals(queryBuilder.shouldPruneTokens(), ((SparseVectorQueryBuilder) rewrittenQueryBuilder).shouldPruneTokens());\n+            assertNotNull(((SparseVectorQueryBuilder) rewrittenQueryBuilder).getQueryVectors());\n+        });\n+    }\n+\n+    private void wrapTestSparseVectorIndexOptions(Consumer<Boolean> testMethod) {\n+        testWithSparseVectorFieldIndexOptions = true;\n+        try {\n+            testMethod.accept(true);\n+        } finally {\n+            testWithSparseVectorFieldIndexOptions = false;\n+        }\n+    }\n }",
      "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java",
      "status": "modified",
      "changes": 40,
      "additions": 40,
      "deletions": 0
    }
  ],
  "ai_reviews": [
    {
      "id": 11,
      "pr_id": 2455055213,
      "summary": "This pull request aims to enhance the `sparse_vector` field mapping in Elasticsearch by introducing a default setting for token pruning. This change is intended to improve the efficiency and performance of sparse vector operations by allowing users to configure token pruning behavior more effectively.\n\nSignificant modifications include:\n- The addition of a new entry in the changelog (`docs/changelog/126739.yaml`) to document the changes.\n- Updates to the mapping reference documentation (`docs/reference/elasticsearch/mapping-reference/sparse-vector.md`) to reflect the new default setting and its implications.\n- Major changes in the `SparseVectorFieldMapper.java` file, which includes 313 additions and 4 deletions, indicating substantial updates to the field mapping logic and potentially new features or configurations related to token pruning.\n\nPotential concerns include ensuring that the new default setting does not introduce unexpected behavior for existing users and that the documentation is clear and comprehensive. Additionally, thorough testing should be conducted to validate the new functionality and its impact on performance. Overall, the changes appear to be a positive enhancement, but careful consideration of user experience and backward compatibility is essential.",
      "full_review": "# AI Review \ud83e\udd16\n\n## Summary\nThis pull request aims to enhance the `sparse_vector` field mapping in Elasticsearch by introducing a default setting for token pruning. This change is intended to improve the efficiency and performance of sparse vector operations by allowing users to configure token pruning behavior more effectively.\n\nSignificant modifications include:\n- The addition of a new entry in the changelog (`docs/changelog/126739.yaml`) to document the changes.\n- Updates to the mapping reference documentation (`docs/reference/elasticsearch/mapping-reference/sparse-vector.md`) to reflect the new default setting and its implications.\n- Major changes in the `SparseVectorFieldMapper.java` file, which includes 313 additions and 4 deletions, indicating substantial updates to the field mapping logic and potentially new features or configurations related to token pruning.\n\nPotential concerns include ensuring that the new default setting does not introduce unexpected behavior for existing users and that the documentation is clear and comprehensive. Additionally, thorough testing should be conducted to validate the new functionality and its impact on performance. Overall, the changes appear to be a positive enhancement, but careful consideration of user experience and backward compatibility is essential.\n\n## Detailed Review\n\n### docs/reference/elasticsearch/mapping-reference/sparse-vector.md\nOverall, the code diff looks good and provides a clear addition to the documentation regarding the `sparse_vector` field and its `index_options`. However, there are a couple of issues that need to be addressed.\n\n1. **Syntax Error**:\n   - **Line 10**: The `tokens_weight_threshold` key is missing a closing quote (`\"`). It should be:\n     ```json\n     \"tokens_weight_threshold\": 0.4\n     ```\n\n2. **Clarity and Consistency**:\n   - **Line 27**: The description for `tokens_freq_ratio_threshold` states \"This value must between 1 and 100.\" It should be corrected to \"This value must be between 1 and 100.\"\n   - **Line 36**: The phrase \"If the pruning options are not set for your `sparse_query` vector on the field\" could be clearer. It might be better to say \"If the pruning options are not set for your `sparse_vector` field, Elasticsearch will use the defaults if set here for the field.\"\n\n3. **Documentation Style**:\n   - Consider using consistent formatting for the parameter descriptions. For example, the use of colons and indentation should be uniform across all parameters for better readability.\n\n4. **Edge Cases**:\n   - Ensure that the documentation mentions what happens if the user sets `prune` to `true` but does not provide a `pruning_config`. It should clarify that default values will be used in this case.\n\n5. **Preview Tags**:\n   - The `[preview]` tags in the parameter descriptions may need clarification. If these are meant to indicate that the features are experimental or subject to change, it should be explicitly stated.\n\nBy addressing these issues, the documentation will be clearer and more accurate.\n### server/src/main/java/org/elasticsearch/index/IndexVersions.java\nOverall Assessment:\nThe code diff introduces a new constant for an index version related to sparse vector pruning options. The change appears to be straightforward and does not introduce any immediate bugs or logical errors. However, there are a few points worth considering for best practices and potential edge cases.\n\nSpecific Issues:\n\n1. **Line 162**: \n   - The new constant `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` is defined with a version number `9_025_0_00`. Ensure that this versioning scheme is consistent with the existing versioning format used in the other constants. The format `9_025_0_00` seems to deviate from the pattern of the other version numbers (e.g., `9_022_00_0`), which could lead to confusion or errors in version management.\n\n2. **Documentation**:\n   - There is no accompanying comment or documentation for the new constant. It would be beneficial to add a brief comment explaining the purpose of `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` and how it relates to the other index versions. This will help future maintainers understand the context and significance of this addition.\n\n3. **Version Compatibility**:\n   - Ensure that the new index version `9_025_0_00` is compatible with the existing versions and that any related code that interacts with index versions is updated accordingly. This includes checking if there are any dependencies or features that rely on this version.\n\n4. **Testing**:\n   - Verify that there are corresponding tests that cover the new index version. If not, consider adding unit tests to ensure that the new version behaves as expected in various scenarios.\n\nIn summary, while the change itself is simple and does not introduce immediate issues, attention to versioning consistency, documentation, compatibility, and testing will enhance the quality and maintainability of the code.\n### server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java\nOverall, the code diff introduces new functionality for handling index options in the `SparseVectorFieldMapper` class. The changes appear to be well-structured, but there are a few areas that could benefit from further attention. Here are the specific points of feedback:\n\n1. **Null Handling (Line 85)**:\n   - The code checks if `buildIndexOptions` is null and assigns a default value if it is. However, the default value is created using `new IndexOptions(...)`, which may lead to unnecessary object creation if `getDefaultIndexOptions(context)` is called multiple times. Consider caching the default value or ensuring that the method is only called when necessary.\n\n2. **Potential NullPointerException (Line 109)**:\n   - The `parseIndexOptions` method assumes that `propNode` will always contain a valid map for `SPARSE_VECTOR_INDEX_OPTIONS`. If `XContentMapValues.nodeMapValue(propNode, SPARSE_VECTOR_INDEX_OPTIONS)` returns null, it could lead to a `NullPointerException` when trying to access `indexOptionsMap`. It would be prudent to add a null check for `indexOptionsMap` before proceeding with parsing.\n\n3. **Code Duplication (Lines 85-109)**:\n   - The logic for determining default index options is duplicated in both `getDefaultIndexOptions` and the `build` method. Consider refactoring this logic into a single method to adhere to the DRY (Don't Repeat Yourself) principle.\n\n4. **Documentation and Comments**:\n   - While the code is mostly self-explanatory, adding comments to complex logic, especially in the `parseIndexOptions` method, would improve readability and maintainability. Explain the purpose of the pruning configuration and the significance of the default values.\n\n5. **IndexOptions Class**:\n   - Ensure that the `IndexOptions` class is properly documented, especially regarding its fields and expected behavior. This will help future developers understand how to use it effectively.\n\n6. **Testing**:\n   - Ensure that there are adequate unit tests covering the new functionality, especially edge cases such as invalid input for index options and scenarios where the index version is before the new features were introduced.\n\n7. **Code Style**:\n   - The code generally follows good practices, but ensure consistent formatting, especially around method parameters and line lengths. For example, the constructor for `SparseVectorFieldType` could be formatted for better readability.\n\nIn summary, while the changes are mostly well-implemented, addressing the above points will enhance the robustness, maintainability, and clarity of the code.\n### server/src/main/java/org/elasticsearch/TransportVersions.java\nOverall Assessment:\nThe code diff appears to be a straightforward addition of a new constant for a transport version in the Elasticsearch project. There are no apparent bugs, performance issues, or security vulnerabilities in this specific change. However, I will provide some feedback on code style and best practices.\n\nSpecific Issues:\n1. **Line 229**: The addition of the new constant `SPARSE_VECTOR_FIELD_PRUNING_OPTIONS` is clear and follows the existing naming conventions. However, ensure that the naming accurately reflects the functionality it represents. If this constant is part of a larger feature, consider adding a comment to explain its purpose.\n\n2. **Documentation**: While not directly related to the code change, it would be beneficial to update any relevant documentation or comments in the surrounding code to reflect the addition of this new transport version. This helps maintain clarity for future developers.\n\n3. **Versioning Consistency**: Ensure that the version number `9_065_0_00` is consistent with the versioning scheme used throughout the project. If there are specific rules or patterns for versioning, verify that this addition adheres to them.\n\nIn summary, while the code change itself is simple and appears correct, consider enhancing documentation and ensuring consistency with existing conventions. \n\nOverall, the change is acceptable. \n\nLGTM! (Looks Good To Me)\n### server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java\nOverall, the code diff appears to be well-structured and adds necessary functionality for handling sparse vector mappings in Elasticsearch. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Line 67-68**: The method `mappingWithDefaultIndexOptions` is defined but not used in the test method `testDefaults`. Instead, the test method uses `mappingWithDefaultIndexOptions` to assert the mapping source. This could lead to confusion about which mapping is being tested. Ensure that the correct mapping method is being referenced.\n\n2. **Line 124-125**: The test method `testWithIndexOptionsPrune` is very similar to `testDefaults`. Consider refactoring the common logic into a helper method to reduce code duplication. This will improve maintainability.\n\n3. **Line 282-283**: The error messages in the exception assertions are quite specific. While this is good for debugging, ensure that they do not expose sensitive information in production environments. Consider logging these messages at a debug level instead of exposing them directly in exception messages.\n\n4. **Line 284-285**: The test for `tokens_freq_ratio_threshold` checks for a range between 1 and 100. Ensure that this range is appropriate for your application context. If the thresholds are configurable, consider making them constants or configurable parameters.\n\n5. **Line 286-287**: Similar to the previous point, the test for `tokens_weight_threshold` should also ensure that the range is appropriate. The error message is truncated in the diff; ensure that the complete message is clear and informative.\n\n6. **Line 288-289**: The exception handling for invalid types (e.g., string instead of a number) is good, but consider adding more specific tests for edge cases, such as null values or empty strings, to ensure robustness.\n\n### Performance Issues:\n- The current implementation of parsing and validating the mapping options could be optimized if the number of fields grows. Consider using a more efficient data structure or validation approach if performance becomes an issue.\n\n### Code Style and Best Practices:\n- Ensure consistent naming conventions for methods and variables. For example, consider using camelCase for method names (e.g., `mappingWithIndexOptionsPrune` could be `mappingWithIndexOptionsPruneConfig` for clarity).\n- Add JavaDoc comments to the new methods to explain their purpose and usage, which will help future developers understand the code better.\n\n### Potential Edge Cases:\n- Consider testing scenarios where the `pruning_config` object is missing entirely or partially. This will help ensure that the code handles such cases gracefully without throwing unexpected exceptions.\n\nIn summary, while the code is generally well-structured and functional, addressing the above points will enhance clarity, maintainability, and robustness.\n### x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java\nOverall, the code diff appears to be well-structured and introduces improvements related to handling optional boolean values for pruning tokens in the `SparseVectorQueryBuilder`. However, there are a few areas that could benefit from further attention regarding clarity, potential edge cases, and best practices.\n\n### Specific Issues:\n\n1. **Line 85-86**: \n   - The change from `boolean shouldPruneTokens` to `Boolean shouldPruneTokens` introduces the possibility of a `null` value. While this is intended to allow for optional behavior, it may lead to confusion. Consider documenting this behavior clearly in the class-level comments or method documentation to avoid misunderstandings.\n\n2. **Line 159**:\n   - The logic for reading `shouldPruneTokens` from the `StreamInput` is dependent on the transport version. Ensure that the versioning logic is well-tested, as any discrepancies could lead to unexpected behavior. It might be beneficial to add a comment explaining the rationale behind this version check.\n\n3. **Line 206-207**:\n   - The check for `shouldPruneTokens` being `null` before writing to the output stream is good, but it could be clearer. Consider adding a comment to explain why `null` is a valid state and what it signifies in the context of this query builder.\n\n4. **Line 222-224**:\n   - The comment regarding checking index options for pruning is helpful, but it could be expanded to clarify what happens if both the query options and index options are not set. This could help future maintainers understand the implications of the logic.\n\n5. **Line 408**:\n   - The method `getIndexFieldPruningSettings` could benefit from additional error handling or logging if the `sparseVectorFieldMapper` is `null`. This would help in debugging scenarios where the expected field mapping is not present.\n\n6. **Line 408-409**:\n   - The use of `new IndexFieldPruningSettings(null, null)` could be misleading. Consider using a more descriptive approach, such as throwing an exception or logging a warning, to indicate that the expected field mapping was not found.\n\n7. **Code Style**:\n   - Ensure consistent use of whitespace and indentation throughout the code. For example, there are some inconsistencies in spacing around operators and method calls. Consistent formatting improves readability.\n\n### Conclusion:\nWhile the changes made in the diff are generally positive and enhance the functionality of the `SparseVectorQueryBuilder`, addressing the above points will improve clarity, maintainability, and robustness. \n\nOverall, I would recommend a thorough review of the edge cases and potential impacts of the changes made, especially regarding the handling of optional values. \n\n**Final Assessment**: The code is mostly good but requires some refinements for clarity and robustness.\n### x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java\nOverall, the code diff appears to be well-structured and introduces new functionality for testing the `SparseVectorQueryBuilder` with index options. However, there are a few areas that could be improved or clarified. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 144-147**: The logic in `initializeAdditionalMappings` checks `testWithSparseVectorFieldIndexOptions` to decide whether to add a sparse vector index options mapping. However, if this flag is set to `true`, the method returns immediately after adding the mapping. This could lead to confusion if there are other mappings that need to be added. Consider whether this is the intended behavior or if additional mappings should still be processed.\n\n2. **Code Style and Best Practices**:\n   - **Line 147**: The method `addSparseVectorIndexOptionsMapping` is a good addition, but consider renaming it to something more descriptive, such as `addSparseVectorMappingWithIndexOptions`, to clarify that it specifically adds a mapping with index options.\n   - **Line 355**: The method `wrapTestSparseVectorIndexOptions` uses a `Consumer<Boolean>` but does not utilize the boolean parameter. If the boolean is not needed, consider changing the method signature to `Consumer<Void>` or simply removing the parameter altogether.\n\n3. **Potential Edge Cases**:\n   - **Line 355**: The `wrapTestSparseVectorIndexOptions` method sets the `testWithSparseVectorFieldIndexOptions` flag to `true` and then resets it in a `finally` block. This is good practice for ensuring the flag is reset, but consider what happens if an exception is thrown in the `testMethod`. Ensure that the `testMethod` is robust and handles any exceptions appropriately.\n   - **Line 355**: If `testMethod` is expected to throw an exception, it might be beneficial to log the exception or handle it in a way that provides feedback during testing.\n\n4. **Performance Issues**:\n   - There are no significant performance issues identified in this diff. However, ensure that the `addSparseVectorIndexOptionsMapping` method is efficient, especially if it will be called frequently during tests.\n\n5. **Security Vulnerabilities**:\n   - There are no apparent security vulnerabilities in this diff. However, always ensure that any data being processed (like mappings) is validated and sanitized if it comes from an untrusted source.\n\nIn summary, while the code looks good overall, consider the points above for improvements in clarity, robustness, and maintainability.\n\n\n---\n*This review was automatically generated by an AI assistant.*",
      "created_at": "2025-04-29T01:25:15",
      "file_reviews": [
        {
          "id": 102,
          "review_id": 11,
          "pr_id": 2455055213,
          "filename": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
          "content": "Overall, the code diff looks good and provides a clear addition to the documentation regarding the `sparse_vector` field and its `index_options`. However, there are a couple of issues that need to be addressed.\n\n1. **Syntax Error**:\n   - **Line 10**: The `tokens_weight_threshold` key is missing a closing quote (`\"`). It should be:\n     ```json\n     \"tokens_weight_threshold\": 0.4\n     ```\n\n2. **Clarity and Consistency**:\n   - **Line 27**: The description for `tokens_freq_ratio_threshold` states \"This value must between 1 and 100.\" It should be corrected to \"This value must be between 1 and 100.\"\n   - **Line 36**: The phrase \"If the pruning options are not set for your `sparse_query` vector on the field\" could be clearer. It might be better to say \"If the pruning options are not set for your `sparse_vector` field, Elasticsearch will use the defaults if set here for the field.\"\n\n3. **Documentation Style**:\n   - Consider using consistent formatting for the parameter descriptions. For example, the use of colons and indentation should be uniform across all parameters for better readability.\n\n4. **Edge Cases**:\n   - Ensure that the documentation mentions what happens if the user sets `prune` to `true` but does not provide a `pruning_config`. It should clarify that default values will be used in this case.\n\n5. **Preview Tags**:\n   - The `[preview]` tags in the parameter descriptions may need clarification. If these are meant to indicate that the features are experimental or subject to change, it should be explicitly stated.\n\nBy addressing these issues, the documentation will be clearer and more accurate.",
          "created_at": "2025-04-29T01:25:15"
        },
        {
          "id": 103,
          "review_id": 11,
          "pr_id": 2455055213,
          "filename": "server/src/main/java/org/elasticsearch/index/IndexVersions.java",
          "content": "Overall Assessment:\nThe code diff introduces a new constant for an index version related to sparse vector pruning options. The change appears to be straightforward and does not introduce any immediate bugs or logical errors. However, there are a few points worth considering for best practices and potential edge cases.\n\nSpecific Issues:\n\n1. **Line 162**: \n   - The new constant `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` is defined with a version number `9_025_0_00`. Ensure that this versioning scheme is consistent with the existing versioning format used in the other constants. The format `9_025_0_00` seems to deviate from the pattern of the other version numbers (e.g., `9_022_00_0`), which could lead to confusion or errors in version management.\n\n2. **Documentation**:\n   - There is no accompanying comment or documentation for the new constant. It would be beneficial to add a brief comment explaining the purpose of `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` and how it relates to the other index versions. This will help future maintainers understand the context and significance of this addition.\n\n3. **Version Compatibility**:\n   - Ensure that the new index version `9_025_0_00` is compatible with the existing versions and that any related code that interacts with index versions is updated accordingly. This includes checking if there are any dependencies or features that rely on this version.\n\n4. **Testing**:\n   - Verify that there are corresponding tests that cover the new index version. If not, consider adding unit tests to ensure that the new version behaves as expected in various scenarios.\n\nIn summary, while the change itself is simple and does not introduce immediate issues, attention to versioning consistency, documentation, compatibility, and testing will enhance the quality and maintainability of the code.",
          "created_at": "2025-04-29T01:25:15"
        },
        {
          "id": 104,
          "review_id": 11,
          "pr_id": 2455055213,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
          "content": "Overall, the code diff introduces new functionality for handling index options in the `SparseVectorFieldMapper` class. The changes appear to be well-structured, but there are a few areas that could benefit from further attention. Here are the specific points of feedback:\n\n1. **Null Handling (Line 85)**:\n   - The code checks if `buildIndexOptions` is null and assigns a default value if it is. However, the default value is created using `new IndexOptions(...)`, which may lead to unnecessary object creation if `getDefaultIndexOptions(context)` is called multiple times. Consider caching the default value or ensuring that the method is only called when necessary.\n\n2. **Potential NullPointerException (Line 109)**:\n   - The `parseIndexOptions` method assumes that `propNode` will always contain a valid map for `SPARSE_VECTOR_INDEX_OPTIONS`. If `XContentMapValues.nodeMapValue(propNode, SPARSE_VECTOR_INDEX_OPTIONS)` returns null, it could lead to a `NullPointerException` when trying to access `indexOptionsMap`. It would be prudent to add a null check for `indexOptionsMap` before proceeding with parsing.\n\n3. **Code Duplication (Lines 85-109)**:\n   - The logic for determining default index options is duplicated in both `getDefaultIndexOptions` and the `build` method. Consider refactoring this logic into a single method to adhere to the DRY (Don't Repeat Yourself) principle.\n\n4. **Documentation and Comments**:\n   - While the code is mostly self-explanatory, adding comments to complex logic, especially in the `parseIndexOptions` method, would improve readability and maintainability. Explain the purpose of the pruning configuration and the significance of the default values.\n\n5. **IndexOptions Class**:\n   - Ensure that the `IndexOptions` class is properly documented, especially regarding its fields and expected behavior. This will help future developers understand how to use it effectively.\n\n6. **Testing**:\n   - Ensure that there are adequate unit tests covering the new functionality, especially edge cases such as invalid input for index options and scenarios where the index version is before the new features were introduced.\n\n7. **Code Style**:\n   - The code generally follows good practices, but ensure consistent formatting, especially around method parameters and line lengths. For example, the constructor for `SparseVectorFieldType` could be formatted for better readability.\n\nIn summary, while the changes are mostly well-implemented, addressing the above points will enhance the robustness, maintainability, and clarity of the code.",
          "created_at": "2025-04-29T01:25:15"
        },
        {
          "id": 105,
          "review_id": 11,
          "pr_id": 2455055213,
          "filename": "server/src/main/java/org/elasticsearch/TransportVersions.java",
          "content": "Overall Assessment:\nThe code diff appears to be a straightforward addition of a new constant for a transport version in the Elasticsearch project. There are no apparent bugs, performance issues, or security vulnerabilities in this specific change. However, I will provide some feedback on code style and best practices.\n\nSpecific Issues:\n1. **Line 229**: The addition of the new constant `SPARSE_VECTOR_FIELD_PRUNING_OPTIONS` is clear and follows the existing naming conventions. However, ensure that the naming accurately reflects the functionality it represents. If this constant is part of a larger feature, consider adding a comment to explain its purpose.\n\n2. **Documentation**: While not directly related to the code change, it would be beneficial to update any relevant documentation or comments in the surrounding code to reflect the addition of this new transport version. This helps maintain clarity for future developers.\n\n3. **Versioning Consistency**: Ensure that the version number `9_065_0_00` is consistent with the versioning scheme used throughout the project. If there are specific rules or patterns for versioning, verify that this addition adheres to them.\n\nIn summary, while the code change itself is simple and appears correct, consider enhancing documentation and ensuring consistency with existing conventions. \n\nOverall, the change is acceptable. \n\nLGTM! (Looks Good To Me)",
          "created_at": "2025-04-29T01:25:15"
        },
        {
          "id": 106,
          "review_id": 11,
          "pr_id": 2455055213,
          "filename": "server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java",
          "content": "Overall, the code diff appears to be well-structured and adds necessary functionality for handling sparse vector mappings in Elasticsearch. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Line 67-68**: The method `mappingWithDefaultIndexOptions` is defined but not used in the test method `testDefaults`. Instead, the test method uses `mappingWithDefaultIndexOptions` to assert the mapping source. This could lead to confusion about which mapping is being tested. Ensure that the correct mapping method is being referenced.\n\n2. **Line 124-125**: The test method `testWithIndexOptionsPrune` is very similar to `testDefaults`. Consider refactoring the common logic into a helper method to reduce code duplication. This will improve maintainability.\n\n3. **Line 282-283**: The error messages in the exception assertions are quite specific. While this is good for debugging, ensure that they do not expose sensitive information in production environments. Consider logging these messages at a debug level instead of exposing them directly in exception messages.\n\n4. **Line 284-285**: The test for `tokens_freq_ratio_threshold` checks for a range between 1 and 100. Ensure that this range is appropriate for your application context. If the thresholds are configurable, consider making them constants or configurable parameters.\n\n5. **Line 286-287**: Similar to the previous point, the test for `tokens_weight_threshold` should also ensure that the range is appropriate. The error message is truncated in the diff; ensure that the complete message is clear and informative.\n\n6. **Line 288-289**: The exception handling for invalid types (e.g., string instead of a number) is good, but consider adding more specific tests for edge cases, such as null values or empty strings, to ensure robustness.\n\n### Performance Issues:\n- The current implementation of parsing and validating the mapping options could be optimized if the number of fields grows. Consider using a more efficient data structure or validation approach if performance becomes an issue.\n\n### Code Style and Best Practices:\n- Ensure consistent naming conventions for methods and variables. For example, consider using camelCase for method names (e.g., `mappingWithIndexOptionsPrune` could be `mappingWithIndexOptionsPruneConfig` for clarity).\n- Add JavaDoc comments to the new methods to explain their purpose and usage, which will help future developers understand the code better.\n\n### Potential Edge Cases:\n- Consider testing scenarios where the `pruning_config` object is missing entirely or partially. This will help ensure that the code handles such cases gracefully without throwing unexpected exceptions.\n\nIn summary, while the code is generally well-structured and functional, addressing the above points will enhance clarity, maintainability, and robustness.",
          "created_at": "2025-04-29T01:25:15"
        },
        {
          "id": 107,
          "review_id": 11,
          "pr_id": 2455055213,
          "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
          "content": "Overall, the code diff appears to be well-structured and introduces improvements related to handling optional boolean values for pruning tokens in the `SparseVectorQueryBuilder`. However, there are a few areas that could benefit from further attention regarding clarity, potential edge cases, and best practices.\n\n### Specific Issues:\n\n1. **Line 85-86**: \n   - The change from `boolean shouldPruneTokens` to `Boolean shouldPruneTokens` introduces the possibility of a `null` value. While this is intended to allow for optional behavior, it may lead to confusion. Consider documenting this behavior clearly in the class-level comments or method documentation to avoid misunderstandings.\n\n2. **Line 159**:\n   - The logic for reading `shouldPruneTokens` from the `StreamInput` is dependent on the transport version. Ensure that the versioning logic is well-tested, as any discrepancies could lead to unexpected behavior. It might be beneficial to add a comment explaining the rationale behind this version check.\n\n3. **Line 206-207**:\n   - The check for `shouldPruneTokens` being `null` before writing to the output stream is good, but it could be clearer. Consider adding a comment to explain why `null` is a valid state and what it signifies in the context of this query builder.\n\n4. **Line 222-224**:\n   - The comment regarding checking index options for pruning is helpful, but it could be expanded to clarify what happens if both the query options and index options are not set. This could help future maintainers understand the implications of the logic.\n\n5. **Line 408**:\n   - The method `getIndexFieldPruningSettings` could benefit from additional error handling or logging if the `sparseVectorFieldMapper` is `null`. This would help in debugging scenarios where the expected field mapping is not present.\n\n6. **Line 408-409**:\n   - The use of `new IndexFieldPruningSettings(null, null)` could be misleading. Consider using a more descriptive approach, such as throwing an exception or logging a warning, to indicate that the expected field mapping was not found.\n\n7. **Code Style**:\n   - Ensure consistent use of whitespace and indentation throughout the code. For example, there are some inconsistencies in spacing around operators and method calls. Consistent formatting improves readability.\n\n### Conclusion:\nWhile the changes made in the diff are generally positive and enhance the functionality of the `SparseVectorQueryBuilder`, addressing the above points will improve clarity, maintainability, and robustness. \n\nOverall, I would recommend a thorough review of the edge cases and potential impacts of the changes made, especially regarding the handling of optional values. \n\n**Final Assessment**: The code is mostly good but requires some refinements for clarity and robustness.",
          "created_at": "2025-04-29T01:25:15"
        },
        {
          "id": 108,
          "review_id": 11,
          "pr_id": 2455055213,
          "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java",
          "content": "Overall, the code diff appears to be well-structured and introduces new functionality for testing the `SparseVectorQueryBuilder` with index options. However, there are a few areas that could be improved or clarified. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 144-147**: The logic in `initializeAdditionalMappings` checks `testWithSparseVectorFieldIndexOptions` to decide whether to add a sparse vector index options mapping. However, if this flag is set to `true`, the method returns immediately after adding the mapping. This could lead to confusion if there are other mappings that need to be added. Consider whether this is the intended behavior or if additional mappings should still be processed.\n\n2. **Code Style and Best Practices**:\n   - **Line 147**: The method `addSparseVectorIndexOptionsMapping` is a good addition, but consider renaming it to something more descriptive, such as `addSparseVectorMappingWithIndexOptions`, to clarify that it specifically adds a mapping with index options.\n   - **Line 355**: The method `wrapTestSparseVectorIndexOptions` uses a `Consumer<Boolean>` but does not utilize the boolean parameter. If the boolean is not needed, consider changing the method signature to `Consumer<Void>` or simply removing the parameter altogether.\n\n3. **Potential Edge Cases**:\n   - **Line 355**: The `wrapTestSparseVectorIndexOptions` method sets the `testWithSparseVectorFieldIndexOptions` flag to `true` and then resets it in a `finally` block. This is good practice for ensuring the flag is reset, but consider what happens if an exception is thrown in the `testMethod`. Ensure that the `testMethod` is robust and handles any exceptions appropriately.\n   - **Line 355**: If `testMethod` is expected to throw an exception, it might be beneficial to log the exception or handle it in a way that provides feedback during testing.\n\n4. **Performance Issues**:\n   - There are no significant performance issues identified in this diff. However, ensure that the `addSparseVectorIndexOptionsMapping` method is efficient, especially if it will be called frequently during tests.\n\n5. **Security Vulnerabilities**:\n   - There are no apparent security vulnerabilities in this diff. However, always ensure that any data being processed (like mappings) is validated and sanitized if it comes from an untrusted source.\n\nIn summary, while the code looks good overall, consider the points above for improvements in clarity, robustness, and maintainability.",
          "created_at": "2025-04-29T01:25:15"
        }
      ]
    },
    {
      "id": 4,
      "pr_id": 2455055213,
      "summary": "This pull request aims to enhance the sparse vector field mapping in Elasticsearch by introducing a default setting for token pruning. This change is significant as it allows for more efficient handling of sparse vectors, potentially improving performance and resource utilization.\n\nKey modifications include:\n- The addition of a new entry in the changelog (`docs/changelog/126739.yaml`) to document the changes.\n- Updates to the mapping reference documentation (`docs/reference/elasticsearch/mapping-reference/sparse-vector.md`) to reflect the new default setting and its implications.\n- Major changes in the `SparseVectorFieldMapper.java` file, which includes 313 additions and 4 deletions, indicating substantial code modifications to implement the new feature.\n- Minor updates in versioning files (`IndexVersions.java` and `TransportVersions.java`) to ensure compatibility with the new mapping.\n\nPotential concerns include the need for thorough testing to ensure that the new default setting does not introduce unexpected behavior in existing implementations. Additionally, the extensive changes in the `SparseVectorFieldMapper` may require careful review to confirm that performance optimizations are achieved without compromising functionality. Overall, the PR appears to be a valuable enhancement, but attention should be given to testing and documentation completeness.",
      "full_review": "# AI Review \ud83e\udd16\n\n## Summary\nThis pull request aims to enhance the sparse vector field mapping in Elasticsearch by introducing a default setting for token pruning. This change is significant as it allows for more efficient handling of sparse vectors, potentially improving performance and resource utilization.\n\nKey modifications include:\n- The addition of a new entry in the changelog (`docs/changelog/126739.yaml`) to document the changes.\n- Updates to the mapping reference documentation (`docs/reference/elasticsearch/mapping-reference/sparse-vector.md`) to reflect the new default setting and its implications.\n- Major changes in the `SparseVectorFieldMapper.java` file, which includes 313 additions and 4 deletions, indicating substantial code modifications to implement the new feature.\n- Minor updates in versioning files (`IndexVersions.java` and `TransportVersions.java`) to ensure compatibility with the new mapping.\n\nPotential concerns include the need for thorough testing to ensure that the new default setting does not introduce unexpected behavior in existing implementations. Additionally, the extensive changes in the `SparseVectorFieldMapper` may require careful review to confirm that performance optimizations are achieved without compromising functionality. Overall, the PR appears to be a valuable enhancement, but attention should be given to testing and documentation completeness.\n\n## Detailed Review\n\n### docs/reference/elasticsearch/mapping-reference/sparse-vector.md\nOverall, the code diff looks good and provides a clear addition to the documentation regarding the `sparse_vector` field and its `index_options`. However, there are a couple of issues that need to be addressed.\n\n1. **Syntax Error**:\n   - **Line 10**: The `tokens_weight_threshold` key is missing a closing quote (`\"`). It should be:\n     ```json\n     \"tokens_weight_threshold\": 0.4\n     ```\n\n2. **Clarity and Consistency**:\n   - **Line 27**: The description for `tokens_freq_ratio_threshold` states, \"This value must between 1 and 100.\" It should be corrected to \"This value must be between 1 and 100.\"\n   - **Line 35**: The description for `tokens_weight_threshold` should also clarify that it is a threshold for weights, similar to how `tokens_freq_ratio_threshold` is described.\n\n3. **Documentation Style**:\n   - Consider using consistent formatting for the parameter descriptions. For example, the use of colons and indentation should be uniform across all parameters for better readability.\n\n4. **Edge Cases**:\n   - It might be beneficial to mention what happens if the `prune` option is set to `true` but the `pruning_config` parameters are outside their specified ranges. This could help users avoid potential misconfigurations.\n\n5. **Preview Tags**:\n   - The `[preview]` tags in the parameter descriptions suggest that these features may not be fully stable. It would be helpful to clarify the implications of using preview features, such as potential changes in future releases.\n\nBy addressing these issues, the documentation will be clearer and more accurate for users.\n### server/src/main/java/org/elasticsearch/index/IndexVersions.java\nOverall Assessment:\nThe code diff introduces a new constant for an index version related to sparse vector pruning options. The change appears to be straightforward and does not introduce any immediate bugs or logical errors. However, there are a few points worth considering for best practices and potential edge cases.\n\nSpecific Issues:\n\n1. **Line 162**: \n   - The new constant `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` is defined with a version number `9_025_0_00`. Ensure that this versioning scheme is consistent with the existing versioning format used in the other constants. The format `9_025_0_00` seems to deviate from the pattern of the other version numbers (e.g., `9_022_00_0`), which could lead to confusion or errors in version management.\n\n2. **Documentation**:\n   - There is no accompanying comment or documentation for the new constant. It would be beneficial to add a brief comment explaining the purpose of `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` and how it relates to the existing index versions. This will help future maintainers understand the context and significance of this addition.\n\n3. **Version Compatibility**:\n   - Ensure that the version `Version.LUCENE_10_2_1` is indeed the correct version for this new index option. If there are any dependencies or compatibility issues with other components of the system, they should be documented or addressed.\n\n4. **Testing**:\n   - Although not directly related to the code diff, ensure that there are corresponding tests that validate the behavior associated with this new index version. If this version introduces new functionality or changes existing behavior, it should be covered by unit tests.\n\nIn summary, while the change itself is simple and does not introduce immediate issues, attention to versioning consistency, documentation, and testing will enhance the maintainability and clarity of the code.\n### server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java\nOverall, the code diff introduces new functionality for handling index options in the `SparseVectorFieldMapper` class. The changes appear to be well-structured, but there are a few areas that could benefit from further attention. Here are the specific points of feedback:\n\n1. **Null Handling (Line 85)**:\n   - The code checks if `buildIndexOptions` is null and assigns a default value if it is. However, the default value is created every time the `build` method is called if `buildIndexOptions` is null. This could lead to unnecessary object creation. Consider initializing `buildIndexOptions` directly with the default value at the point of declaration or using a lazy initialization approach.\n\n2. **IndexOptions Parsing (Line 109)**:\n   - The `parseIndexOptions` method uses `XContentMapValues.nodeMapValue(propNode, SPARSE_VECTOR_INDEX_OPTIONS)`. Ensure that `propNode` is always in the expected format. If it is not, this could lead to a `ClassCastException`. Consider adding error handling or validation to ensure that `propNode` is indeed a map before attempting to access it.\n\n3. **Default Values Logic (Lines 139-145)**:\n   - The logic for determining default values in `getDefaultIndexOptions` is based on the index version. Ensure that this logic is well-documented, as it may not be immediately clear to future maintainers why certain defaults are set based on version. Additionally, consider whether the default values should be configurable or if they should remain hardcoded.\n\n4. **Code Style and Readability**:\n   - The code is generally well-structured, but consider adding JavaDoc comments for the new methods (`getIndexOptions`, `getDefaultIndexOptions`, and `parseIndexOptions`). This will improve readability and maintainability by providing context for future developers.\n\n5. **Potential Edge Cases**:\n   - In the `parseIndexOptions` method, if `indexOptionsMap` is empty or does not contain the expected keys, the subsequent calls to `IndexOptions.parseIndexOptionsPruneValue` and `IndexOptions.parseIndexOptionsPruningConfig` may return null. Ensure that the handling of these cases is robust and that the method returns a sensible default or throws an informative exception.\n\n6. **Immutable Parameters**:\n   - The `indexOptions` parameter in the `Builder` class is mutable. If the `Builder` is used in a multi-threaded context, this could lead to race conditions. Consider making it immutable or ensuring that the builder is not shared across threads.\n\nIn summary, while the changes are generally well-implemented, attention to null handling, error checking, documentation, and potential edge cases will enhance the robustness and maintainability of the code.\n### server/src/main/java/org/elasticsearch/TransportVersions.java\nOverall Assessment:\nThe code diff appears to be a straightforward addition of a new constant for a transport version in the Elasticsearch project. There are no apparent bugs, performance issues, or security vulnerabilities in this specific change. The addition follows the existing pattern and style of the code.\n\nSpecific Issues:\n1. **Line 229**: The new constant `SPARSE_VECTOR_FIELD_PRUNING_OPTIONS` is added correctly, following the naming conventions and format of the existing constants. However, ensure that the version number `9_065_0_00` is correctly defined and follows the intended versioning scheme for the project.\n\n2. **Documentation**: While not explicitly part of the diff, consider adding a comment or documentation regarding the purpose of the new transport version constant. This can help future developers understand its significance and usage.\n\n3. **Testing**: Ensure that there are corresponding tests that validate the behavior associated with this new transport version. If not, it would be beneficial to add tests to cover any new functionality or changes that this version introduces.\n\nIn summary, while the code change itself is valid, attention should be given to documentation and testing to ensure maintainability and clarity in the future.\n### server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java\nOverall, the code diff appears to be well-structured and follows good practices for unit testing in Java. However, there are a few areas that could be improved or warrant further attention. Here are the specific points:\n\n1. **Code Duplication**:\n   - Lines 68-90 and 92-114 contain similar code for creating `DocumentMapper` and parsing documents. Consider extracting the common logic into a private method to reduce duplication and improve maintainability.\n\n2. **Error Messages**:\n   - In the exception assertions (e.g., lines 204-206, 210-212), the error messages could be more descriptive. Instead of just stating the field should be a number between 1 and 100, it might be helpful to specify the expected type (e.g., \"should be a number between 1 and 100 (inclusive)\").\n\n3. **Magic Numbers**:\n   - The thresholds used in the tests (e.g., `-2`, `101`, `5.0`, `0.4`) should be defined as constants with meaningful names. This will improve readability and make it easier to adjust these values in the future.\n\n4. **Test Coverage**:\n   - While the tests cover various scenarios, consider adding tests for edge cases, such as:\n     - What happens if the `pruning_config` object is empty?\n     - What if the `index_options` object is missing entirely?\n     - Tests for boundary values (e.g., exactly `1` and `100` for `tokens_freq_ratio_threshold`).\n\n5. **Assertions**:\n   - In the tests, consider using more specific assertions where applicable. For example, instead of just checking the size of the fields list, you could assert the contents of the fields to ensure they match expected values.\n\n6. **Performance**:\n   - The current implementation does not seem to have any immediate performance issues. However, if the number of fields grows significantly, consider profiling the parsing and indexing process to ensure it remains efficient.\n\n7. **Security**:\n   - Ensure that the input to the `createMapperService` method is validated properly to prevent any potential injection attacks or malformed data issues.\n\n8. **Documentation**:\n   - Adding comments to explain the purpose of each test method would enhance readability and help future maintainers understand the intent behind each test.\n\nIn summary, while the code is generally well-structured, addressing the points above will improve maintainability, readability, and robustness.\n### x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java\nOverall, the code diff appears to be well-structured and introduces improvements related to handling optional boolean values for pruning tokens in the `SparseVectorQueryBuilder`. However, there are a few areas that could benefit from further attention.\n\n### Specific Issues:\n\n1. **Line 85-86**: \n   - The change from `boolean shouldPruneTokens` to `Boolean shouldPruneTokens` introduces the possibility of a `null` value. While this is intended to allow for optional behavior, ensure that all usages of `shouldPruneTokens` handle the `null` case appropriately. The current implementation does this, but it\u2019s crucial to maintain this throughout the code.\n\n2. **Line 126-130**: \n   - The handling of `shouldPruneTokens` when reading from `StreamInput` is correct, but ensure that the default behavior is well-documented. If `null` is a valid state, it should be clear in the documentation or comments that this is an expected and handled case.\n\n3. **Line 206-207**: \n   - The logic for writing `shouldPruneTokens` to `StreamOutput` is sound, but consider adding a comment explaining why the `null` check is necessary. This will help future maintainers understand the reasoning behind the conditional logic.\n\n4. **Line 222-234**: \n   - The comments added regarding checking index options for pruning are helpful. However, ensure that the logic for `setPruningConfigFromIndexIfNeeded` is robust and handles all edge cases, especially if the index options are not set or are invalid.\n\n5. **Line 408-409**: \n   - The `getIndexFieldPruningSettings` method could benefit from additional error handling or logging if the `sparseVectorFieldMapper` is `null`. This could help in debugging scenarios where the expected field mapping is not found.\n\n6. **Line 408-409**: \n   - The method `getSparseVectorFieldMapper` is truncated in the diff. Ensure that the complete method implementation is robust and handles cases where the field may not exist in the mapping. Consider returning an `Optional<SparseVectorFieldMapper>` to clearly indicate the potential absence of a mapper.\n\n### Performance Issues:\n- The changes do not introduce any significant performance issues, but ensure that the additional checks for `null` do not lead to performance degradation in high-throughput scenarios. Profiling may be necessary if this code is in a performance-critical path.\n\n### Security Vulnerabilities:\n- No immediate security vulnerabilities are apparent in this diff. However, always ensure that any user input or external data is validated and sanitized, especially when dealing with query parameters.\n\n### Code Style and Best Practices:\n- The code adheres to Java conventions and is generally well-structured. Consider adding JavaDoc comments for public methods to improve maintainability and clarity for future developers.\n\n### Potential Edge Cases:\n- Ensure that the logic for handling `null` values in `shouldPruneTokens` is thoroughly tested, especially in scenarios where the field may not be present or when the input stream is malformed.\n\nIn summary, while the changes are largely positive, attention to detail in handling optional values and ensuring robust error handling will enhance the quality of the code. \n\n**Overall Assessment**: The code is on the right track but requires careful consideration of edge cases and documentation for clarity.\n### x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java\nOverall, the code diff appears to be well-structured and introduces new functionality for testing the `SparseVectorQueryBuilder` with index options. However, there are a few areas that could be improved or clarified. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 144-147**: The `initializeAdditionalMappings` method has a conditional check for `testWithSparseVectorFieldIndexOptions`. If this flag is true, it calls `addSparseVectorIndexOptionsMapping` and returns immediately. Ensure that this behavior is intended and that there are no scenarios where the mapping should be applied regardless of this flag.\n\n2. **Code Style and Best Practices**:\n   - **Line 147**: The method `addSparseVectorIndexOptionsMapping` is a good addition, but consider renaming it to something more descriptive, such as `addSparseVectorMappingWithIndexOptions`, to clarify its purpose.\n   - **Line 355**: The method `wrapTestSparseVectorIndexOptions` uses a boolean parameter (`testMethod.accept(true)`) that is not utilized within the method. This could be misleading. If the boolean is not necessary, consider removing it or using it meaningfully.\n\n3. **Potential Edge Cases**:\n   - **Line 355**: The `wrapTestSparseVectorIndexOptions` method sets the `testWithSparseVectorFieldIndexOptions` flag to true and then resets it in a `finally` block. This is good practice, but ensure that no other tests are running concurrently that might be affected by this flag. If this test class is run in parallel with others, it could lead to unexpected behavior.\n\n4. **Performance Issues**:\n   - The use of `List.of` for `WEIGHTED_TOKENS` is efficient for immutable lists. However, if this list is expected to grow or change in size, consider using a more flexible collection type. If it remains static, this is fine.\n\n5. **Documentation**:\n   - Consider adding comments to explain the purpose of the new test method `testWeCorrectlyRewriteQueryIntoVectorsWithIndexOptions` and the `wrapTestSparseVectorIndexOptions` method. This will help future maintainers understand the intent behind these additions.\n\nIn summary, while the code looks good overall, addressing the above points will enhance clarity, maintainability, and robustness.\n\n\n---\n*This review was automatically generated by an AI assistant.*",
      "created_at": "2025-04-29T01:09:37",
      "file_reviews": [
        {
          "id": 35,
          "review_id": 4,
          "pr_id": 2455055213,
          "filename": "docs/reference/elasticsearch/mapping-reference/sparse-vector.md",
          "content": "Overall, the code diff looks good and provides a clear addition to the documentation regarding the `sparse_vector` field and its `index_options`. However, there are a couple of issues that need to be addressed.\n\n1. **Syntax Error**:\n   - **Line 10**: The `tokens_weight_threshold` key is missing a closing quote (`\"`). It should be:\n     ```json\n     \"tokens_weight_threshold\": 0.4\n     ```\n\n2. **Clarity and Consistency**:\n   - **Line 27**: The description for `tokens_freq_ratio_threshold` states, \"This value must between 1 and 100.\" It should be corrected to \"This value must be between 1 and 100.\"\n   - **Line 35**: The description for `tokens_weight_threshold` should also clarify that it is a threshold for weights, similar to how `tokens_freq_ratio_threshold` is described.\n\n3. **Documentation Style**:\n   - Consider using consistent formatting for the parameter descriptions. For example, the use of colons and indentation should be uniform across all parameters for better readability.\n\n4. **Edge Cases**:\n   - It might be beneficial to mention what happens if the `prune` option is set to `true` but the `pruning_config` parameters are outside their specified ranges. This could help users avoid potential misconfigurations.\n\n5. **Preview Tags**:\n   - The `[preview]` tags in the parameter descriptions suggest that these features may not be fully stable. It would be helpful to clarify the implications of using preview features, such as potential changes in future releases.\n\nBy addressing these issues, the documentation will be clearer and more accurate for users.",
          "created_at": "2025-04-29T01:09:37"
        },
        {
          "id": 36,
          "review_id": 4,
          "pr_id": 2455055213,
          "filename": "server/src/main/java/org/elasticsearch/index/IndexVersions.java",
          "content": "Overall Assessment:\nThe code diff introduces a new constant for an index version related to sparse vector pruning options. The change appears to be straightforward and does not introduce any immediate bugs or logical errors. However, there are a few points worth considering for best practices and potential edge cases.\n\nSpecific Issues:\n\n1. **Line 162**: \n   - The new constant `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` is defined with a version number `9_025_0_00`. Ensure that this versioning scheme is consistent with the existing versioning format used in the other constants. The format `9_025_0_00` seems to deviate from the pattern of the other version numbers (e.g., `9_022_00_0`), which could lead to confusion or errors in version management.\n\n2. **Documentation**:\n   - There is no accompanying comment or documentation for the new constant. It would be beneficial to add a brief comment explaining the purpose of `SPARSE_VECTOR_PRUNING_INDEX_OPTIONS_SUPPORT` and how it relates to the existing index versions. This will help future maintainers understand the context and significance of this addition.\n\n3. **Version Compatibility**:\n   - Ensure that the version `Version.LUCENE_10_2_1` is indeed the correct version for this new index option. If there are any dependencies or compatibility issues with other components of the system, they should be documented or addressed.\n\n4. **Testing**:\n   - Although not directly related to the code diff, ensure that there are corresponding tests that validate the behavior associated with this new index version. If this version introduces new functionality or changes existing behavior, it should be covered by unit tests.\n\nIn summary, while the change itself is simple and does not introduce immediate issues, attention to versioning consistency, documentation, and testing will enhance the maintainability and clarity of the code.",
          "created_at": "2025-04-29T01:09:37"
        },
        {
          "id": 37,
          "review_id": 4,
          "pr_id": 2455055213,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapper.java",
          "content": "Overall, the code diff introduces new functionality for handling index options in the `SparseVectorFieldMapper` class. The changes appear to be well-structured, but there are a few areas that could benefit from further attention. Here are the specific points of feedback:\n\n1. **Null Handling (Line 85)**:\n   - The code checks if `buildIndexOptions` is null and assigns a default value if it is. However, the default value is created every time the `build` method is called if `buildIndexOptions` is null. This could lead to unnecessary object creation. Consider initializing `buildIndexOptions` directly with the default value at the point of declaration or using a lazy initialization approach.\n\n2. **IndexOptions Parsing (Line 109)**:\n   - The `parseIndexOptions` method uses `XContentMapValues.nodeMapValue(propNode, SPARSE_VECTOR_INDEX_OPTIONS)`. Ensure that `propNode` is always in the expected format. If it is not, this could lead to a `ClassCastException`. Consider adding error handling or validation to ensure that `propNode` is indeed a map before attempting to access it.\n\n3. **Default Values Logic (Lines 139-145)**:\n   - The logic for determining default values in `getDefaultIndexOptions` is based on the index version. Ensure that this logic is well-documented, as it may not be immediately clear to future maintainers why certain defaults are set based on version. Additionally, consider whether the default values should be configurable or if they should remain hardcoded.\n\n4. **Code Style and Readability**:\n   - The code is generally well-structured, but consider adding JavaDoc comments for the new methods (`getIndexOptions`, `getDefaultIndexOptions`, and `parseIndexOptions`). This will improve readability and maintainability by providing context for future developers.\n\n5. **Potential Edge Cases**:\n   - In the `parseIndexOptions` method, if `indexOptionsMap` is empty or does not contain the expected keys, the subsequent calls to `IndexOptions.parseIndexOptionsPruneValue` and `IndexOptions.parseIndexOptionsPruningConfig` may return null. Ensure that the handling of these cases is robust and that the method returns a sensible default or throws an informative exception.\n\n6. **Immutable Parameters**:\n   - The `indexOptions` parameter in the `Builder` class is mutable. If the `Builder` is used in a multi-threaded context, this could lead to race conditions. Consider making it immutable or ensuring that the builder is not shared across threads.\n\nIn summary, while the changes are generally well-implemented, attention to null handling, error checking, documentation, and potential edge cases will enhance the robustness and maintainability of the code.",
          "created_at": "2025-04-29T01:09:37"
        },
        {
          "id": 38,
          "review_id": 4,
          "pr_id": 2455055213,
          "filename": "server/src/main/java/org/elasticsearch/TransportVersions.java",
          "content": "Overall Assessment:\nThe code diff appears to be a straightforward addition of a new constant for a transport version in the Elasticsearch project. There are no apparent bugs, performance issues, or security vulnerabilities in this specific change. The addition follows the existing pattern and style of the code.\n\nSpecific Issues:\n1. **Line 229**: The new constant `SPARSE_VECTOR_FIELD_PRUNING_OPTIONS` is added correctly, following the naming conventions and format of the existing constants. However, ensure that the version number `9_065_0_00` is correctly defined and follows the intended versioning scheme for the project.\n\n2. **Documentation**: While not explicitly part of the diff, consider adding a comment or documentation regarding the purpose of the new transport version constant. This can help future developers understand its significance and usage.\n\n3. **Testing**: Ensure that there are corresponding tests that validate the behavior associated with this new transport version. If not, it would be beneficial to add tests to cover any new functionality or changes that this version introduces.\n\nIn summary, while the code change itself is valid, attention should be given to documentation and testing to ensure maintainability and clarity in the future.",
          "created_at": "2025-04-29T01:09:37"
        },
        {
          "id": 39,
          "review_id": 4,
          "pr_id": 2455055213,
          "filename": "server/src/test/java/org/elasticsearch/index/mapper/vectors/SparseVectorFieldMapperTests.java",
          "content": "Overall, the code diff appears to be well-structured and follows good practices for unit testing in Java. However, there are a few areas that could be improved or warrant further attention. Here are the specific points:\n\n1. **Code Duplication**:\n   - Lines 68-90 and 92-114 contain similar code for creating `DocumentMapper` and parsing documents. Consider extracting the common logic into a private method to reduce duplication and improve maintainability.\n\n2. **Error Messages**:\n   - In the exception assertions (e.g., lines 204-206, 210-212), the error messages could be more descriptive. Instead of just stating the field should be a number between 1 and 100, it might be helpful to specify the expected type (e.g., \"should be a number between 1 and 100 (inclusive)\").\n\n3. **Magic Numbers**:\n   - The thresholds used in the tests (e.g., `-2`, `101`, `5.0`, `0.4`) should be defined as constants with meaningful names. This will improve readability and make it easier to adjust these values in the future.\n\n4. **Test Coverage**:\n   - While the tests cover various scenarios, consider adding tests for edge cases, such as:\n     - What happens if the `pruning_config` object is empty?\n     - What if the `index_options` object is missing entirely?\n     - Tests for boundary values (e.g., exactly `1` and `100` for `tokens_freq_ratio_threshold`).\n\n5. **Assertions**:\n   - In the tests, consider using more specific assertions where applicable. For example, instead of just checking the size of the fields list, you could assert the contents of the fields to ensure they match expected values.\n\n6. **Performance**:\n   - The current implementation does not seem to have any immediate performance issues. However, if the number of fields grows significantly, consider profiling the parsing and indexing process to ensure it remains efficient.\n\n7. **Security**:\n   - Ensure that the input to the `createMapperService` method is validated properly to prevent any potential injection attacks or malformed data issues.\n\n8. **Documentation**:\n   - Adding comments to explain the purpose of each test method would enhance readability and help future maintainers understand the intent behind each test.\n\nIn summary, while the code is generally well-structured, addressing the points above will improve maintainability, readability, and robustness.",
          "created_at": "2025-04-29T01:09:37"
        },
        {
          "id": 40,
          "review_id": 4,
          "pr_id": 2455055213,
          "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilder.java",
          "content": "Overall, the code diff appears to be well-structured and introduces improvements related to handling optional boolean values for pruning tokens in the `SparseVectorQueryBuilder`. However, there are a few areas that could benefit from further attention.\n\n### Specific Issues:\n\n1. **Line 85-86**: \n   - The change from `boolean shouldPruneTokens` to `Boolean shouldPruneTokens` introduces the possibility of a `null` value. While this is intended to allow for optional behavior, ensure that all usages of `shouldPruneTokens` handle the `null` case appropriately. The current implementation does this, but it\u2019s crucial to maintain this throughout the code.\n\n2. **Line 126-130**: \n   - The handling of `shouldPruneTokens` when reading from `StreamInput` is correct, but ensure that the default behavior is well-documented. If `null` is a valid state, it should be clear in the documentation or comments that this is an expected and handled case.\n\n3. **Line 206-207**: \n   - The logic for writing `shouldPruneTokens` to `StreamOutput` is sound, but consider adding a comment explaining why the `null` check is necessary. This will help future maintainers understand the reasoning behind the conditional logic.\n\n4. **Line 222-234**: \n   - The comments added regarding checking index options for pruning are helpful. However, ensure that the logic for `setPruningConfigFromIndexIfNeeded` is robust and handles all edge cases, especially if the index options are not set or are invalid.\n\n5. **Line 408-409**: \n   - The `getIndexFieldPruningSettings` method could benefit from additional error handling or logging if the `sparseVectorFieldMapper` is `null`. This could help in debugging scenarios where the expected field mapping is not found.\n\n6. **Line 408-409**: \n   - The method `getSparseVectorFieldMapper` is truncated in the diff. Ensure that the complete method implementation is robust and handles cases where the field may not exist in the mapping. Consider returning an `Optional<SparseVectorFieldMapper>` to clearly indicate the potential absence of a mapper.\n\n### Performance Issues:\n- The changes do not introduce any significant performance issues, but ensure that the additional checks for `null` do not lead to performance degradation in high-throughput scenarios. Profiling may be necessary if this code is in a performance-critical path.\n\n### Security Vulnerabilities:\n- No immediate security vulnerabilities are apparent in this diff. However, always ensure that any user input or external data is validated and sanitized, especially when dealing with query parameters.\n\n### Code Style and Best Practices:\n- The code adheres to Java conventions and is generally well-structured. Consider adding JavaDoc comments for public methods to improve maintainability and clarity for future developers.\n\n### Potential Edge Cases:\n- Ensure that the logic for handling `null` values in `shouldPruneTokens` is thoroughly tested, especially in scenarios where the field may not be present or when the input stream is malformed.\n\nIn summary, while the changes are largely positive, attention to detail in handling optional values and ensuring robust error handling will enhance the quality of the code. \n\n**Overall Assessment**: The code is on the right track but requires careful consideration of edge cases and documentation for clarity.",
          "created_at": "2025-04-29T01:09:37"
        },
        {
          "id": 41,
          "review_id": 4,
          "pr_id": 2455055213,
          "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/search/SparseVectorQueryBuilderTests.java",
          "content": "Overall, the code diff appears to be well-structured and introduces new functionality for testing the `SparseVectorQueryBuilder` with index options. However, there are a few areas that could be improved or clarified. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 144-147**: The `initializeAdditionalMappings` method has a conditional check for `testWithSparseVectorFieldIndexOptions`. If this flag is true, it calls `addSparseVectorIndexOptionsMapping` and returns immediately. Ensure that this behavior is intended and that there are no scenarios where the mapping should be applied regardless of this flag.\n\n2. **Code Style and Best Practices**:\n   - **Line 147**: The method `addSparseVectorIndexOptionsMapping` is a good addition, but consider renaming it to something more descriptive, such as `addSparseVectorMappingWithIndexOptions`, to clarify its purpose.\n   - **Line 355**: The method `wrapTestSparseVectorIndexOptions` uses a boolean parameter (`testMethod.accept(true)`) that is not utilized within the method. This could be misleading. If the boolean is not necessary, consider removing it or using it meaningfully.\n\n3. **Potential Edge Cases**:\n   - **Line 355**: The `wrapTestSparseVectorIndexOptions` method sets the `testWithSparseVectorFieldIndexOptions` flag to true and then resets it in a `finally` block. This is good practice, but ensure that no other tests are running concurrently that might be affected by this flag. If this test class is run in parallel with others, it could lead to unexpected behavior.\n\n4. **Performance Issues**:\n   - The use of `List.of` for `WEIGHTED_TOKENS` is efficient for immutable lists. However, if this list is expected to grow or change in size, consider using a more flexible collection type. If it remains static, this is fine.\n\n5. **Documentation**:\n   - Consider adding comments to explain the purpose of the new test method `testWeCorrectlyRewriteQueryIntoVectorsWithIndexOptions` and the `wrapTestSparseVectorIndexOptions` method. This will help future maintainers understand the intent behind these additions.\n\nIn summary, while the code looks good overall, addressing the above points will enhance clarity, maintainability, and robustness.",
          "created_at": "2025-04-29T01:09:37"
        }
      ]
    }
  ]
}