{
  "id": 2487052561,
  "repo_owner": "elastic",
  "repo_name": "elasticsearch",
  "number": 127483,
  "title": "Add tests for block loaders of multifields",
  "created_at": "2025-04-28T21:33:25",
  "updated_at": "2025-04-29T00:29:07",
  "state": "open",
  "user_login": "lkts",
  "diffs": "diff --git a/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java b/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java\nindex 9e7940201c4a3..5bf5295e7adde 100644\n--- a/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java\n+++ b/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java\n@@ -378,7 +378,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             if (hasDocValues() && (blContext.fieldExtractPreference() != FieldExtractPreference.STORED || isSyntheticSource)) {\n                 return new BlockDocValuesReader.DoublesBlockLoader(name(), l -> l / scalingFactor);\n             }\n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {\ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java\nindex 6013950255928..2843900c564c7 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java\n@@ -350,7 +350,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockDocValuesReader.BooleansBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {\ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java\nindex 7a1fbd5383476..3511c8dc19321 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java\n@@ -948,7 +948,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockDocValuesReader.LongsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {\ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\nindex dce49367bd565..764f0c4cc5031 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\n@@ -316,7 +316,7 @@ protected void index(DocumentParserContext context, GeoPoint geometry) throws IO\n \n     /**\n      * Parser that pretends to be the main document parser, but exposes the provided geohash regardless of how the geopoint was provided\n-     * in the incoming document. We rely on the fact that consumers are only ever call {@link XContentParser#textOrNull()} and never\n+     * in the incoming document. We rely on the fact that consumers only ever read text from the parser and never\n      * advance tokens, which is explicitly disallowed by this parser.\n      */\n     static class GeoHashMultiFieldParser extends FilterXContentParserWrapper {\n@@ -332,6 +332,11 @@ public String textOrNull() throws IOException {\n             return value;\n         }\n \n+        @Override\n+        public String text() throws IOException {\n+            return value;\n+        }\n+\n         @Override\n         public Token currentToken() {\n             return Token.VALUE_STRING;\n@@ -545,8 +550,9 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             // So we have two subcases:\n             // - doc_values are enabled - _ignored_source field does not exist since we have doc_values. We will use\n             // blockLoaderFromSource which reads \"native\" synthetic source.\n-            // - doc_values are disabled - we know that _ignored_source field is present and use a special block loader.\n-            if (isSyntheticSource && hasDocValues() == false) {\n+            // - doc_values are disabled - we know that _ignored_source field is present and use a special block loader unless it's a multi\n+            // field.\n+            if (isSyntheticSource && hasDocValues() == false && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n \ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java\nindex 2dfd11456523e..8e7cf41ca21b7 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java\n@@ -467,7 +467,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockStoredFieldsReader.BytesFromBytesRefsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n \ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\nindex e31e291a425cd..840f4a3726109 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\n@@ -755,7 +755,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockStoredFieldsReader.BytesFromBytesRefsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {\ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java\nindex c96062516e2f0..8711d39a23c08 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java\n@@ -1973,7 +1973,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return type.blockLoaderFromDocValues(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return type.blockLoaderFromFallbackSyntheticSource(name(), nullValue, coerce);\n             }\n \ndiff --git a/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java b/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\nindex 21f6766a3705e..530be9fbbc738 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\n@@ -35,19 +35,19 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         var values = extractedFieldValues.values();\n \n         var nullValue = switch (fieldMapping.get(\"null_value\")) {\n-            case String s -> convert(s, null);\n+            case String s -> convert(s, null, false);\n             case null -> null;\n             default -> throw new IllegalStateException(\"Unexpected null_value format\");\n         };\n \n         if (params.preference() == MappedFieldType.FieldExtractPreference.DOC_VALUES && hasDocValues(fieldMapping, true)) {\n             if (values instanceof List<?> == false) {\n-                var point = convert(values, nullValue);\n+                var point = convert(values, nullValue, testContext.isMultifield());\n                 return point != null ? point.getEncoded() : null;\n             }\n \n             var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue))\n+                .map(v -> convert(v, nullValue, testContext.isMultifield()))\n                 .filter(Objects::nonNull)\n                 .map(GeoPoint::getEncoded)\n                 .sorted()\n@@ -55,8 +55,9 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n             return maybeFoldList(resultList);\n         }\n \n+        // stored source is used\n         if (params.syntheticSource() == false) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n \n         // Usually implementation of block loader from source adjusts values read from source\n@@ -67,25 +68,25 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         // That is unless \"synthetic_source_keep\" forces fallback synthetic source again.\n \n         if (testContext.forceFallbackSyntheticSource()) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n \n         String syntheticSourceKeep = (String) fieldMapping.getOrDefault(\"synthetic_source_keep\", \"none\");\n         if (syntheticSourceKeep.equals(\"all\")) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n         if (syntheticSourceKeep.equals(\"arrays\") && extractedFieldValues.documentHasObjectArrays()) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n \n         // synthetic source and doc_values are present\n         if (hasDocValues(fieldMapping, true)) {\n             if (values instanceof List<?> == false) {\n-                return toWKB(normalize(convert(values, nullValue)));\n+                return toWKB(normalize(convert(values, nullValue, false)));\n             }\n \n             var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue))\n+                .map(v -> convert(v, nullValue, false))\n                 .filter(Objects::nonNull)\n                 .sorted(Comparator.comparingLong(GeoPoint::getEncoded))\n                 .map(p -> toWKB(normalize(p)))\n@@ -94,16 +95,20 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         }\n \n         // synthetic source but no doc_values so using fallback synthetic source\n-        return exactValuesFromSource(values, nullValue);\n+        return exactValuesFromSource(values, nullValue, false);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private Object exactValuesFromSource(Object value, GeoPoint nullValue) {\n+    private Object exactValuesFromSource(Object value, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n         if (value instanceof List<?> == false) {\n-            return toWKB(convert(value, nullValue));\n+            return toWKB(convert(value, nullValue, needsMultifieldAdjustment));\n         }\n \n-        var resultList = ((List<Object>) value).stream().map(v -> convert(v, nullValue)).filter(Objects::nonNull).map(this::toWKB).toList();\n+        var resultList = ((List<Object>) value).stream()\n+            .map(v -> convert(v, nullValue, needsMultifieldAdjustment))\n+            .filter(Objects::nonNull)\n+            .map(this::toWKB)\n+            .toList();\n         return maybeFoldList(resultList);\n     }\n \n@@ -163,14 +168,17 @@ private void processLeafLevel(Object value, ArrayList<Object> extracted) {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private GeoPoint convert(Object value, GeoPoint nullValue) {\n+    private GeoPoint convert(Object value, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n         if (value == null) {\n-            return nullValue;\n+            if (nullValue == null) {\n+                return null;\n+            }\n+            return possiblyAdjustMultifieldValue(nullValue, needsMultifieldAdjustment);\n         }\n \n         if (value instanceof String s) {\n             try {\n-                return new GeoPoint(s);\n+                return possiblyAdjustMultifieldValue(new GeoPoint(s), needsMultifieldAdjustment);\n             } catch (Exception e) {\n                 return null;\n             }\n@@ -180,9 +188,9 @@ private GeoPoint convert(Object value, GeoPoint nullValue) {\n             if (m.get(\"type\") != null) {\n                 var coordinates = (List<Double>) m.get(\"coordinates\");\n                 // Order is GeoJSON is lon,lat\n-                return new GeoPoint(coordinates.get(1), coordinates.get(0));\n+                return possiblyAdjustMultifieldValue(new GeoPoint(coordinates.get(1), coordinates.get(0)), needsMultifieldAdjustment);\n             } else {\n-                return new GeoPoint((Double) m.get(\"lat\"), (Double) m.get(\"lon\"));\n+                return possiblyAdjustMultifieldValue(new GeoPoint((Double) m.get(\"lat\"), (Double) m.get(\"lon\")), needsMultifieldAdjustment);\n             }\n         }\n \n@@ -190,6 +198,20 @@ private GeoPoint convert(Object value, GeoPoint nullValue) {\n         return null;\n     }\n \n+    private GeoPoint possiblyAdjustMultifieldValue(GeoPoint point, boolean isMultifield) {\n+        // geo_point multifields are parsed from a geohash representation of the original point (GeoPointFieldMapper#index)\n+        // and it's not exact.\n+        // So if this is a multifield we need another adjustment here.\n+        // Note that this does not apply to block loader from source because in this case we parse raw original values.\n+        // Same thing happens with synthetic source since it is generated from the parent field data that didn't go through multi field\n+        // parsing logic.\n+        if (isMultifield) {\n+            return point.resetFromString(point.geohash());\n+        }\n+\n+        return point;\n+    }\n+\n     private GeoPoint normalize(GeoPoint point) {\n         if (point == null) {\n             return null;\ndiff --git a/server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java b/server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java\nindex 1f154fa7581ab..6343aeea2d9de 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java\n@@ -9,51 +9,108 @@\n \n package org.elasticsearch.index.mapper.blockloader;\n \n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.datageneration.DocumentGenerator;\n import org.elasticsearch.datageneration.FieldType;\n+import org.elasticsearch.datageneration.MappingGenerator;\n+import org.elasticsearch.datageneration.Template;\n import org.elasticsearch.datageneration.datasource.DataSourceHandler;\n import org.elasticsearch.datageneration.datasource.DataSourceRequest;\n import org.elasticsearch.datageneration.datasource.DataSourceResponse;\n-import org.elasticsearch.datageneration.datasource.DefaultMappingParametersHandler;\n import org.elasticsearch.index.mapper.BlockLoaderTestCase;\n+import org.elasticsearch.index.mapper.BlockLoaderTestRunner;\n+import org.elasticsearch.index.mapper.MapperServiceTestCase;\n+import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xcontent.XContentType;\n \n-import java.util.HashMap;\n+import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n \n-public class TextFieldWithParentBlockLoaderTests extends BlockLoaderTestCase {\n-    public TextFieldWithParentBlockLoaderTests(Params params) {\n-        // keyword because we need a keyword parent field\n-        super(FieldType.KEYWORD.toString(), List.of(new DataSourceHandler() {\n+import static org.elasticsearch.index.mapper.BlockLoaderTestCase.buildSpecification;\n+import static org.elasticsearch.index.mapper.BlockLoaderTestCase.hasDocValues;\n+\n+public class TextFieldWithParentBlockLoaderTests extends MapperServiceTestCase {\n+    private final BlockLoaderTestCase.Params params;\n+    private final BlockLoaderTestRunner runner;\n+\n+    @ParametersFactory(argumentFormatting = \"preference=%s\")\n+    public static List<Object[]> args() {\n+        return BlockLoaderTestCase.args();\n+    }\n+\n+    public TextFieldWithParentBlockLoaderTests(BlockLoaderTestCase.Params params) {\n+        this.params = params;\n+        this.runner = new BlockLoaderTestRunner(params);\n+    }\n+\n+    // This is similar to BlockLoaderTestCase#testBlockLoaderOfMultiField but has customizations required to properly test the case\n+    // of text multi field in a keyword field.\n+    public void testBlockLoaderOfParentField() throws IOException {\n+        var template = new Template(Map.of(\"parent\", new Template.Leaf(\"parent\", FieldType.KEYWORD.toString())));\n+        var specification = buildSpecification(List.of(new DataSourceHandler() {\n             @Override\n             public DataSourceResponse.LeafMappingParametersGenerator handle(DataSourceRequest.LeafMappingParametersGenerator request) {\n-                assert request.fieldType().equals(FieldType.KEYWORD.toString());\n+                // This is a bit tricky meta-logic.\n+                // We want to customize mapping but to do this we need the mapping for the same field type\n+                // so we use name to untangle this.\n+                if (request.fieldName().equals(\"parent\") == false) {\n+                    return null;\n+                }\n \n-                // We need to force multi field generation\n                 return new DataSourceResponse.LeafMappingParametersGenerator(() -> {\n-                    var defaultSupplier = DefaultMappingParametersHandler.keywordMapping(\n-                        request,\n-                        DefaultMappingParametersHandler.commonMappingParameters()\n-                    );\n-                    var mapping = defaultSupplier.get();\n+                    var dataSource = request.dataSource();\n+\n+                    var keywordParentMapping = dataSource.get(\n+                        new DataSourceRequest.LeafMappingParametersGenerator(\n+                            dataSource,\n+                            \"_field\",\n+                            FieldType.KEYWORD.toString(),\n+                            request.eligibleCopyToFields(),\n+                            request.dynamicMapping()\n+                        )\n+                    ).mappingGenerator().get();\n+\n+                    var textMultiFieldMapping = dataSource.get(\n+                        new DataSourceRequest.LeafMappingParametersGenerator(\n+                            dataSource,\n+                            \"_field\",\n+                            FieldType.TEXT.toString(),\n+                            request.eligibleCopyToFields(),\n+                            request.dynamicMapping()\n+                        )\n+                    ).mappingGenerator().get();\n+\n                     // we don't need this here\n-                    mapping.remove(\"copy_to\");\n+                    keywordParentMapping.remove(\"copy_to\");\n \n-                    var textMultiFieldMappingSupplier = DefaultMappingParametersHandler.textMapping(request, new HashMap<>());\n-                    var textMultiFieldMapping = textMultiFieldMappingSupplier.get();\n                     textMultiFieldMapping.put(\"type\", \"text\");\n                     textMultiFieldMapping.remove(\"fields\");\n \n-                    mapping.put(\"fields\", Map.of(\"txt\", textMultiFieldMapping));\n+                    keywordParentMapping.put(\"fields\", Map.of(\"mf\", textMultiFieldMapping));\n \n-                    return mapping;\n+                    return keywordParentMapping;\n                 });\n             }\n-        }), params);\n+        }));\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var fieldMapping = mapping.lookup().get(\"parent\");\n+\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n+        var fieldValue = document.get(\"parent\");\n+\n+        Object expected = expected(fieldMapping, fieldValue, new BlockLoaderTestCase.TestContext(false, true));\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+        var mapperService = params.syntheticSource()\n+            ? createSytheticSourceMapperService(mappingXContent)\n+            : createMapperService(mappingXContent);\n+\n+        runner.runTest(mapperService, document, expected, \"parent.mf\");\n     }\n \n-    @Override\n     @SuppressWarnings(\"unchecked\")\n-    protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\n+    private Object expected(Map<String, Object> fieldMapping, Object value, BlockLoaderTestCase.TestContext testContext) {\n         assert fieldMapping.containsKey(\"fields\");\n \n         Object normalizer = fieldMapping.get(\"normalizer\");\n@@ -66,12 +123,7 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         }\n \n         // we are using block loader of the text field itself\n-        var textFieldMapping = (Map<String, Object>) ((Map<String, Object>) fieldMapping.get(\"fields\")).get(\"txt\");\n+        var textFieldMapping = (Map<String, Object>) ((Map<String, Object>) fieldMapping.get(\"fields\")).get(\"mf\");\n         return TextFieldBlockLoaderTests.expectedValue(textFieldMapping, value, params, testContext);\n     }\n-\n-    @Override\n-    protected String blockLoaderFieldName(String originalName) {\n-        return originalName + \".txt\";\n-    }\n }\ndiff --git a/test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java b/test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java\nindex 4c8e835f6170f..795302e0972c7 100644\n--- a/test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java\n+++ b/test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java\n@@ -104,6 +104,7 @@ private void generateMapping(\n                 var mappingParametersGenerator = specification.dataSource()\n                     .get(\n                         new DataSourceRequest.LeafMappingParametersGenerator(\n+                            specification.dataSource(),\n                             fieldName,\n                             leaf.type(),\n                             context.eligibleCopyToDestinations(),\ndiff --git a/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java b/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java\nindex e5e845eb48585..1323fa23d226e 100644\n--- a/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java\n+++ b/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java\n@@ -199,6 +199,7 @@ public DataSourceResponse.ObjectArrayGenerator accept(DataSourceHandler handler)\n     }\n \n     record LeafMappingParametersGenerator(\n+        DataSource dataSource,\n         String fieldName,\n         String fieldType,\n         Set<String> eligibleCopyToFields,\ndiff --git a/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java b/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java\nindex de3e49e8457eb..2e234f8aec41c 100644\n--- a/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java\n+++ b/test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java\n@@ -36,34 +36,27 @@ public DataSourceResponse.LeafMappingParametersGenerator handle(DataSourceReques\n             return null;\n         }\n \n-        var map = commonMappingParameters();\n-        if (ESTestCase.randomBoolean()) {\n-            map.put(Mapper.SYNTHETIC_SOURCE_KEEP_PARAM, ESTestCase.randomFrom(\"none\", \"arrays\", \"all\"));\n-        }\n-\n         return new DataSourceResponse.LeafMappingParametersGenerator(switch (fieldType) {\n-            case KEYWORD -> keywordMapping(request, map);\n-            case LONG, INTEGER, SHORT, BYTE, DOUBLE, FLOAT, HALF_FLOAT, UNSIGNED_LONG -> numberMapping(map, fieldType);\n-            case SCALED_FLOAT -> scaledFloatMapping(map);\n-            case COUNTED_KEYWORD -> plain(Map.of(\"index\", ESTestCase.randomBoolean()));\n-            case BOOLEAN -> booleanMapping(map);\n-            case DATE -> dateMapping(map);\n-            case GEO_POINT -> geoPointMapping(map);\n-            case TEXT -> textMapping(request, new HashMap<>());\n-            case IP -> ipMapping(map);\n-            case CONSTANT_KEYWORD -> constantKeywordMapping(new HashMap<>());\n-            case WILDCARD -> wildcardMapping(new HashMap<>());\n+            case KEYWORD -> keywordMapping(request);\n+            case LONG, INTEGER, SHORT, BYTE, DOUBLE, FLOAT, HALF_FLOAT, UNSIGNED_LONG -> numberMapping(fieldType);\n+            case SCALED_FLOAT -> scaledFloatMapping();\n+            case COUNTED_KEYWORD -> countedKeywordMapping();\n+            case BOOLEAN -> booleanMapping();\n+            case DATE -> dateMapping();\n+            case GEO_POINT -> geoPointMapping();\n+            case TEXT -> textMapping(request);\n+            case IP -> ipMapping();\n+            case CONSTANT_KEYWORD -> constantKeywordMapping();\n+            case WILDCARD -> wildcardMapping();\n         });\n     }\n \n-    private Supplier<Map<String, Object>> plain(Map<String, Object> injected) {\n-        return () -> injected;\n-    }\n-\n-    private Supplier<Map<String, Object>> numberMapping(Map<String, Object> injected, FieldType fieldType) {\n+    private Supplier<Map<String, Object>> numberMapping(FieldType fieldType) {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n             if (ESTestCase.randomDouble() <= 0.2) {\n                 Number value = switch (fieldType) {\n@@ -77,18 +70,17 @@ private Supplier<Map<String, Object>> numberMapping(Map<String, Object> injected\n                     default -> throw new IllegalStateException(\"Unexpected field type\");\n                 };\n \n-                injected.put(\"null_value\", value);\n+                mapping.put(\"null_value\", value);\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    public static Supplier<Map<String, Object>> keywordMapping(\n-        DataSourceRequest.LeafMappingParametersGenerator request,\n-        Map<String, Object> injected\n-    ) {\n+    private Supplier<Map<String, Object>> keywordMapping(DataSourceRequest.LeafMappingParametersGenerator request) {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             // Inject copy_to sometimes but reflect that it is not widely used in reality.\n             // We only add copy_to to keywords because we get into trouble with numeric fields that are copied to dynamic fields.\n             // If first copied value is numeric, dynamic field is created with numeric field type and then copy of text values fail.\n@@ -100,69 +92,79 @@ public static Supplier<Map<String, Object>> keywordMapping(\n                     .collect(Collectors.toSet());\n \n                 if (options.isEmpty() == false) {\n-                    injected.put(\"copy_to\", ESTestCase.randomFrom(options));\n+                    mapping.put(\"copy_to\", ESTestCase.randomFrom(options));\n                 }\n             }\n \n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n+                mapping.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n             }\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n+                mapping.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> scaledFloatMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> scaledFloatMapping() {\n         return () -> {\n-            injected.put(\"scaling_factor\", ESTestCase.randomFrom(10, 1000, 100000, 100.5));\n+            var mapping = commonMappingParameters();\n+\n+            mapping.put(\"scaling_factor\", ESTestCase.randomFrom(10, 1000, 100000, 100.5));\n \n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomDouble());\n+                mapping.put(\"null_value\", ESTestCase.randomDouble());\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> booleanMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> countedKeywordMapping() {\n+        return () -> Map.of(\"index\", ESTestCase.randomBoolean());\n+    }\n+\n+    private Supplier<Map<String, Object>> booleanMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomFrom(true, false, \"true\", \"false\"));\n+                mapping.put(\"null_value\", ESTestCase.randomFrom(true, false, \"true\", \"false\"));\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n     // just a custom format, specific format does not matter\n     private static final String FORMAT = \"yyyy_MM_dd_HH_mm_ss_n\";\n \n-    private Supplier<Map<String, Object>> dateMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> dateMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             String format = null;\n             if (ESTestCase.randomBoolean()) {\n                 format = FORMAT;\n-                injected.put(\"format\", format);\n+                mapping.put(\"format\", format);\n             }\n \n             if (ESTestCase.randomDouble() <= 0.2) {\n                 var instant = ESTestCase.randomInstantBetween(Instant.parse(\"2300-01-01T00:00:00Z\"), Instant.parse(\"2350-01-01T00:00:00Z\"));\n \n                 if (format == null) {\n-                    injected.put(\"null_value\", instant.toEpochMilli());\n+                    mapping.put(\"null_value\", instant.toEpochMilli());\n                 } else {\n-                    injected.put(\n+                    mapping.put(\n                         \"null_value\",\n                         DateTimeFormatter.ofPattern(format, Locale.ROOT).withZone(ZoneId.from(ZoneOffset.UTC)).format(instant)\n                     );\n@@ -170,82 +172,89 @@ private Supplier<Map<String, Object>> dateMapping(Map<String, Object> injected)\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> geoPointMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> geoPointMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n                 var point = GeometryTestUtils.randomPoint(false);\n-                injected.put(\"null_value\", WellKnownText.toWKT(point));\n+                mapping.put(\"null_value\", WellKnownText.toWKT(point));\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    public static Supplier<Map<String, Object>> textMapping(\n-        DataSourceRequest.LeafMappingParametersGenerator request,\n-        Map<String, Object> injected\n-    ) {\n+    private Supplier<Map<String, Object>> textMapping(DataSourceRequest.LeafMappingParametersGenerator request) {\n         return () -> {\n-            injected.put(\"store\", ESTestCase.randomBoolean());\n-            injected.put(\"index\", ESTestCase.randomBoolean());\n+            var mapping = new HashMap<String, Object>();\n+\n+            mapping.put(\"store\", ESTestCase.randomBoolean());\n+            mapping.put(\"index\", ESTestCase.randomBoolean());\n \n             if (ESTestCase.randomDouble() <= 0.1) {\n-                var keywordMultiFieldMapping = keywordMapping(request, commonMappingParameters()).get();\n+                var keywordMultiFieldMapping = keywordMapping(request).get();\n                 keywordMultiFieldMapping.put(\"type\", \"keyword\");\n                 keywordMultiFieldMapping.remove(\"copy_to\");\n \n-                injected.put(\"fields\", Map.of(\"kwd\", keywordMultiFieldMapping));\n+                mapping.put(\"fields\", Map.of(\"kwd\", keywordMultiFieldMapping));\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> ipMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> ipMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", NetworkAddress.format(ESTestCase.randomIp(ESTestCase.randomBoolean())));\n+                mapping.put(\"null_value\", NetworkAddress.format(ESTestCase.randomIp(ESTestCase.randomBoolean())));\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> constantKeywordMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> constantKeywordMapping() {\n         return () -> {\n+            var mapping = new HashMap<String, Object>();\n+\n             // value is optional and can be set from the first document\n             // we don't cover this case here\n-            injected.put(\"value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n+            mapping.put(\"value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> wildcardMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> wildcardMapping() {\n         return () -> {\n+            var mapping = new HashMap<String, Object>();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n+                mapping.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n             }\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n+                mapping.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n@@ -254,6 +263,11 @@ public static HashMap<String, Object> commonMappingParameters() {\n         map.put(\"store\", ESTestCase.randomBoolean());\n         map.put(\"index\", ESTestCase.randomBoolean());\n         map.put(\"doc_values\", ESTestCase.randomBoolean());\n+\n+        if (ESTestCase.randomBoolean()) {\n+            map.put(Mapper.SYNTHETIC_SOURCE_KEEP_PARAM, ESTestCase.randomFrom(\"none\", \"arrays\", \"all\"));\n+        }\n+\n         return map;\n     }\n \ndiff --git a/test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java b/test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java\nindex 965c6dd4dd927..3b6c4ec5e0123 100644\n--- a/test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java\n@@ -11,24 +11,13 @@\n \n import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n \n-import org.apache.lucene.index.DirectoryReader;\n-import org.apache.lucene.index.LeafReaderContext;\n-import org.apache.lucene.store.Directory;\n-import org.apache.lucene.tests.index.RandomIndexWriter;\n-import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.datageneration.DataGeneratorSpecification;\n import org.elasticsearch.datageneration.DocumentGenerator;\n-import org.elasticsearch.datageneration.Mapping;\n import org.elasticsearch.datageneration.MappingGenerator;\n import org.elasticsearch.datageneration.Template;\n import org.elasticsearch.datageneration.datasource.DataSourceHandler;\n import org.elasticsearch.datageneration.datasource.DataSourceRequest;\n import org.elasticsearch.datageneration.datasource.DataSourceResponse;\n-import org.elasticsearch.index.IndexSettings;\n-import org.elasticsearch.index.fieldvisitor.StoredFieldLoader;\n-import org.elasticsearch.plugins.internal.XContentMeteringParserDecorator;\n-import org.elasticsearch.search.fetch.StoredFieldsSpec;\n-import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n \n@@ -38,7 +27,6 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.stream.Stream;\n \n public abstract class BlockLoaderTestCase extends MapperServiceTestCase {\n@@ -60,46 +48,26 @@ public static List<Object[]> args() {\n \n     public record Params(boolean syntheticSource, MappedFieldType.FieldExtractPreference preference) {}\n \n-    public record TestContext(boolean forceFallbackSyntheticSource) {}\n+    public record TestContext(boolean forceFallbackSyntheticSource, boolean isMultifield) {}\n \n     private final String fieldType;\n     protected final Params params;\n+    private final Collection<DataSourceHandler> customDataSourceHandlers;\n+    private final BlockLoaderTestRunner runner;\n \n     private final String fieldName;\n-    private final MappingGenerator mappingGenerator;\n-    private final DocumentGenerator documentGenerator;\n \n     protected BlockLoaderTestCase(String fieldType, Params params) {\n         this(fieldType, List.of(), params);\n     }\n \n-    protected BlockLoaderTestCase(String fieldType, Collection<DataSourceHandler> customHandlers, Params params) {\n+    protected BlockLoaderTestCase(String fieldType, Collection<DataSourceHandler> customDataSourceHandlers, Params params) {\n         this.fieldType = fieldType;\n         this.params = params;\n+        this.customDataSourceHandlers = customDataSourceHandlers;\n+        this.runner = new BlockLoaderTestRunner(params);\n \n         this.fieldName = randomAlphaOfLengthBetween(5, 10);\n-\n-        var specification = DataGeneratorSpecification.builder()\n-            .withFullyDynamicMapping(false)\n-            // Disable dynamic mapping and disabled objects\n-            .withDataSourceHandlers(List.of(new DataSourceHandler() {\n-                @Override\n-                public DataSourceResponse.DynamicMappingGenerator handle(DataSourceRequest.DynamicMappingGenerator request) {\n-                    return new DataSourceResponse.DynamicMappingGenerator(isObject -> false);\n-                }\n-\n-                @Override\n-                public DataSourceResponse.ObjectMappingParametersGenerator handle(\n-                    DataSourceRequest.ObjectMappingParametersGenerator request\n-                ) {\n-                    return new DataSourceResponse.ObjectMappingParametersGenerator(HashMap::new); // just defaults\n-                }\n-            }))\n-            .withDataSourceHandlers(customHandlers)\n-            .build();\n-\n-        this.mappingGenerator = new MappingGenerator(specification);\n-        this.documentGenerator = new DocumentGenerator(specification);\n     }\n \n     @Override\n@@ -114,9 +82,19 @@ public void testFieldHasValueWithEmptyFieldInfos() {\n \n     public void testBlockLoader() throws IOException {\n         var template = new Template(Map.of(fieldName, new Template.Leaf(fieldName, fieldType)));\n-        var mapping = mappingGenerator.generate(template);\n+        var specification = buildSpecification(customDataSourceHandlers);\n+\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n+\n+        Object expected = expected(mapping.lookup().get(fieldName), getFieldValue(document, fieldName), new TestContext(false, false));\n+\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+        var mapperService = params.syntheticSource\n+            ? createSytheticSourceMapperService(mappingXContent)\n+            : createMapperService(mappingXContent);\n \n-        runTest(template, mapping, fieldName, new TestContext(false));\n+        runner.runTest(mapperService, document, expected, fieldName);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n@@ -140,9 +118,11 @@ public void testBlockLoaderForFieldInObject() throws IOException {\n         currentLevel.put(fieldName, new Template.Leaf(fieldName, fieldType));\n         var template = new Template(top);\n \n-        var mapping = mappingGenerator.generate(template);\n+        var specification = buildSpecification(customDataSourceHandlers);\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n \n-        TestContext testContext = new TestContext(false);\n+        TestContext testContext = new TestContext(false, false);\n \n         if (params.syntheticSource && randomBoolean()) {\n             // force fallback synthetic source in the hierarchy\n@@ -150,29 +130,119 @@ public void testBlockLoaderForFieldInObject() throws IOException {\n             var topLevelMapping = (Map<String, Object>) ((Map<String, Object>) docMapping.get(\"properties\")).get(\"top\");\n             topLevelMapping.put(\"synthetic_source_keep\", \"all\");\n \n-            testContext = new TestContext(true);\n+            testContext = new TestContext(true, false);\n         }\n \n-        runTest(template, mapping, fullFieldName.toString(), testContext);\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+        var mapperService = params.syntheticSource\n+            ? createSytheticSourceMapperService(mappingXContent)\n+            : createMapperService(mappingXContent);\n+\n+        Object expected = expected(\n+            mapping.lookup().get(fullFieldName.toString()),\n+            getFieldValue(document, fullFieldName.toString()),\n+            testContext\n+        );\n+\n+        runner.runTest(mapperService, document, expected, fullFieldName.toString());\n     }\n \n-    private void runTest(Template template, Mapping mapping, String fieldName, TestContext testContext) throws IOException {\n-        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // We are going to have a parent field and a multi field of the same type in order to be sure we can index data.\n+        // Then we'll test block loader of the multi field.\n+        var template = new Template(Map.of(\"parent\", new Template.Leaf(\"parent\", fieldType)));\n+\n+        var customHandlers = new ArrayList<DataSourceHandler>();\n+        customHandlers.add(new DataSourceHandler() {\n+            @Override\n+            public DataSourceResponse.LeafMappingParametersGenerator handle(DataSourceRequest.LeafMappingParametersGenerator request) {\n+                // This is a bit tricky meta-logic.\n+                // We want to customize mapping but to do this we need the mapping for the same field type\n+                // so we use name to untangle this.\n+                if (request.fieldName().equals(\"parent\") == false) {\n+                    return null;\n+                }\n+\n+                return new DataSourceResponse.LeafMappingParametersGenerator(() -> {\n+                    var dataSource = request.dataSource();\n+\n+                    // We need parent field to have the same mapping as multi field due to different behavior caused f.e. by\n+                    // ignore_malformed.\n+                    // The name here should be different from \"parent\".\n+                    var mapping = dataSource.get(\n+                        new DataSourceRequest.LeafMappingParametersGenerator(\n+                            dataSource,\n+                            \"_field\",\n+                            request.fieldType(),\n+                            request.eligibleCopyToFields(),\n+                            request.dynamicMapping()\n+                        )\n+                    ).mappingGenerator().get();\n+\n+                    var parentMapping = new HashMap<>(mapping);\n+                    var multiFieldMapping = new HashMap<>(mapping);\n \n+                    multiFieldMapping.put(\"type\", fieldType);\n+                    multiFieldMapping.remove(\"fields\");\n+\n+                    parentMapping.put(\"fields\", Map.of(\"mf\", multiFieldMapping));\n+\n+                    return parentMapping;\n+                });\n+            }\n+        });\n+        customHandlers.addAll(customDataSourceHandlers);\n+        var specification = buildSpecification(customHandlers);\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var fieldMapping = (Map<String, Object>) ((Map<String, Object>) mapping.lookup().get(\"parent\").get(\"fields\")).get(\"mf\");\n+\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n+\n+        Object expected = expected(fieldMapping, getFieldValue(document, \"parent\"), new TestContext(false, true));\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n         var mapperService = params.syntheticSource\n             ? createSytheticSourceMapperService(mappingXContent)\n             : createMapperService(mappingXContent);\n \n-        var document = documentGenerator.generate(template, mapping);\n-        var documentXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(document);\n+        runner.runTest(mapperService, document, expected, \"parent.mf\");\n+    }\n+\n+    public static DataGeneratorSpecification buildSpecification(Collection<DataSourceHandler> customHandlers) {\n+        return DataGeneratorSpecification.builder()\n+            .withFullyDynamicMapping(false)\n+            // Disable dynamic mapping and disabled objects\n+            .withDataSourceHandlers(List.of(new DataSourceHandler() {\n+                @Override\n+                public DataSourceResponse.DynamicMappingGenerator handle(DataSourceRequest.DynamicMappingGenerator request) {\n+                    return new DataSourceResponse.DynamicMappingGenerator(isObject -> false);\n+                }\n \n-        Object expected = expected(mapping.lookup().get(fieldName), getFieldValue(document, fieldName), testContext);\n-        Object blockLoaderResult = setupAndInvokeBlockLoader(mapperService, documentXContent, blockLoaderFieldName(fieldName));\n-        assertEquals(expected, blockLoaderResult);\n+                @Override\n+                public DataSourceResponse.ObjectMappingParametersGenerator handle(\n+                    DataSourceRequest.ObjectMappingParametersGenerator request\n+                ) {\n+                    return new DataSourceResponse.ObjectMappingParametersGenerator(HashMap::new); // just defaults\n+                }\n+            }))\n+            .withDataSourceHandlers(customHandlers)\n+            .build();\n     }\n \n     protected abstract Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext);\n \n+    protected static Object maybeFoldList(List<?> list) {\n+        if (list.isEmpty()) {\n+            return null;\n+        }\n+\n+        if (list.size() == 1) {\n+            return list.get(0);\n+        }\n+\n+        return list;\n+    }\n+\n     protected Object getFieldValue(Map<String, Object> document, String fieldName) {\n         var rawValues = new ArrayList<>();\n         processLevel(document, fieldName, rawValues);\n@@ -204,128 +274,7 @@ private void processLevel(Map<String, Object> level, String field, ArrayList<Obj\n         }\n     }\n \n-    protected static Object maybeFoldList(List<?> list) {\n-        if (list.isEmpty()) {\n-            return null;\n-        }\n-\n-        if (list.size() == 1) {\n-            return list.get(0);\n-        }\n-\n-        return list;\n-    }\n-\n-    /**\n-        Allows to change the field name used to obtain a block loader.\n-        Useful f.e. to test block loaders of multi fields.\n-     */\n-    protected String blockLoaderFieldName(String originalName) {\n-        return originalName;\n-    }\n-\n-    private Object setupAndInvokeBlockLoader(MapperService mapperService, XContentBuilder document, String fieldName) throws IOException {\n-        try (Directory directory = newDirectory()) {\n-            RandomIndexWriter iw = new RandomIndexWriter(random(), directory);\n-\n-            var source = new SourceToParse(\n-                \"1\",\n-                BytesReference.bytes(document),\n-                XContentType.JSON,\n-                null,\n-                Map.of(),\n-                true,\n-                XContentMeteringParserDecorator.NOOP\n-            );\n-            LuceneDocument doc = mapperService.documentMapper().parse(source).rootDoc();\n-\n-            iw.addDocument(doc);\n-            iw.close();\n-\n-            try (DirectoryReader reader = DirectoryReader.open(directory)) {\n-                LeafReaderContext context = reader.leaves().get(0);\n-                return load(createBlockLoader(mapperService, fieldName), context, mapperService);\n-            }\n-        }\n-    }\n-\n-    private Object load(BlockLoader blockLoader, LeafReaderContext context, MapperService mapperService) throws IOException {\n-        // `columnAtATimeReader` is tried first, we mimic `ValuesSourceReaderOperator`\n-        var columnAtATimeReader = blockLoader.columnAtATimeReader(context);\n-        if (columnAtATimeReader != null) {\n-            var block = (TestBlock) columnAtATimeReader.read(TestBlock.factory(context.reader().numDocs()), TestBlock.docs(0));\n-            if (block.size() == 0) {\n-                return null;\n-            }\n-            return block.get(0);\n-        }\n-\n-        StoredFieldsSpec storedFieldsSpec = blockLoader.rowStrideStoredFieldSpec();\n-        SourceLoader.Leaf leafSourceLoader = null;\n-        if (storedFieldsSpec.requiresSource()) {\n-            var sourceLoader = mapperService.mappingLookup().newSourceLoader(null, SourceFieldMetrics.NOOP);\n-            leafSourceLoader = sourceLoader.leaf(context.reader(), null);\n-            storedFieldsSpec = storedFieldsSpec.merge(\n-                new StoredFieldsSpec(true, storedFieldsSpec.requiresMetadata(), sourceLoader.requiredStoredFields())\n-            );\n-        }\n-        BlockLoaderStoredFieldsFromLeafLoader storedFieldsLoader = new BlockLoaderStoredFieldsFromLeafLoader(\n-            StoredFieldLoader.fromSpec(storedFieldsSpec).getLoader(context, null),\n-            leafSourceLoader\n-        );\n-        storedFieldsLoader.advanceTo(0);\n-\n-        BlockLoader.Builder builder = blockLoader.builder(TestBlock.factory(context.reader().numDocs()), 1);\n-        blockLoader.rowStrideReader(context).read(0, storedFieldsLoader, builder);\n-        var block = (TestBlock) builder.build();\n-        if (block.size() == 0) {\n-            return null;\n-        }\n-        return block.get(0);\n-    }\n-\n-    private BlockLoader createBlockLoader(MapperService mapperService, String fieldName) {\n-        SearchLookup searchLookup = new SearchLookup(mapperService.mappingLookup().fieldTypesLookup()::get, null, null);\n-\n-        return mapperService.fieldType(fieldName).blockLoader(new MappedFieldType.BlockLoaderContext() {\n-            @Override\n-            public String indexName() {\n-                return mapperService.getIndexSettings().getIndex().getName();\n-            }\n-\n-            @Override\n-            public IndexSettings indexSettings() {\n-                return mapperService.getIndexSettings();\n-            }\n-\n-            @Override\n-            public MappedFieldType.FieldExtractPreference fieldExtractPreference() {\n-                return params.preference;\n-            }\n-\n-            @Override\n-            public SearchLookup lookup() {\n-                return searchLookup;\n-            }\n-\n-            @Override\n-            public Set<String> sourcePaths(String name) {\n-                return mapperService.mappingLookup().sourcePaths(name);\n-            }\n-\n-            @Override\n-            public String parentField(String field) {\n-                return mapperService.mappingLookup().parentField(field);\n-            }\n-\n-            @Override\n-            public FieldNamesFieldMapper.FieldNamesFieldType fieldNames() {\n-                return (FieldNamesFieldMapper.FieldNamesFieldType) mapperService.fieldType(FieldNamesFieldMapper.NAME);\n-            }\n-        });\n-    }\n-\n-    protected static boolean hasDocValues(Map<String, Object> fieldMapping, boolean defaultValue) {\n+    public static boolean hasDocValues(Map<String, Object> fieldMapping, boolean defaultValue) {\n         return (boolean) fieldMapping.getOrDefault(\"doc_values\", defaultValue);\n     }\n }\ndiff --git a/test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java b/test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java\nnew file mode 100644\nindex 0000000000000..c558cd9ddfa08\n--- /dev/null\n+++ b/test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java\n@@ -0,0 +1,148 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.tests.index.RandomIndexWriter;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fieldvisitor.StoredFieldLoader;\n+import org.elasticsearch.plugins.internal.XContentMeteringParserDecorator;\n+import org.elasticsearch.search.fetch.StoredFieldsSpec;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xcontent.XContentType;\n+import org.junit.Assert;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.lucene.tests.util.LuceneTestCase.newDirectory;\n+import static org.apache.lucene.tests.util.LuceneTestCase.random;\n+\n+public class BlockLoaderTestRunner {\n+    private final BlockLoaderTestCase.Params params;\n+\n+    public BlockLoaderTestRunner(BlockLoaderTestCase.Params params) {\n+        this.params = params;\n+    }\n+\n+    public void runTest(MapperService mapperService, Map<String, Object> document, Object expected, String blockLoaderFieldName)\n+        throws IOException {\n+        var documentXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(document);\n+\n+        Object blockLoaderResult = setupAndInvokeBlockLoader(mapperService, documentXContent, blockLoaderFieldName);\n+        Assert.assertEquals(expected, blockLoaderResult);\n+    }\n+\n+    private Object setupAndInvokeBlockLoader(MapperService mapperService, XContentBuilder document, String fieldName) throws IOException {\n+        try (Directory directory = newDirectory()) {\n+            RandomIndexWriter iw = new RandomIndexWriter(random(), directory);\n+\n+            var source = new SourceToParse(\n+                \"1\",\n+                BytesReference.bytes(document),\n+                XContentType.JSON,\n+                null,\n+                Map.of(),\n+                true,\n+                XContentMeteringParserDecorator.NOOP\n+            );\n+            LuceneDocument doc = mapperService.documentMapper().parse(source).rootDoc();\n+\n+            iw.addDocument(doc);\n+            iw.close();\n+\n+            try (DirectoryReader reader = DirectoryReader.open(directory)) {\n+                LeafReaderContext context = reader.leaves().get(0);\n+                return load(createBlockLoader(mapperService, fieldName), context, mapperService);\n+            }\n+        }\n+    }\n+\n+    private Object load(BlockLoader blockLoader, LeafReaderContext context, MapperService mapperService) throws IOException {\n+        // `columnAtATimeReader` is tried first, we mimic `ValuesSourceReaderOperator`\n+        var columnAtATimeReader = blockLoader.columnAtATimeReader(context);\n+        if (columnAtATimeReader != null) {\n+            var block = (TestBlock) columnAtATimeReader.read(TestBlock.factory(context.reader().numDocs()), TestBlock.docs(0));\n+            if (block.size() == 0) {\n+                return null;\n+            }\n+            return block.get(0);\n+        }\n+\n+        StoredFieldsSpec storedFieldsSpec = blockLoader.rowStrideStoredFieldSpec();\n+        SourceLoader.Leaf leafSourceLoader = null;\n+        if (storedFieldsSpec.requiresSource()) {\n+            var sourceLoader = mapperService.mappingLookup().newSourceLoader(null, SourceFieldMetrics.NOOP);\n+            leafSourceLoader = sourceLoader.leaf(context.reader(), null);\n+            storedFieldsSpec = storedFieldsSpec.merge(\n+                new StoredFieldsSpec(true, storedFieldsSpec.requiresMetadata(), sourceLoader.requiredStoredFields())\n+            );\n+        }\n+        BlockLoaderStoredFieldsFromLeafLoader storedFieldsLoader = new BlockLoaderStoredFieldsFromLeafLoader(\n+            StoredFieldLoader.fromSpec(storedFieldsSpec).getLoader(context, null),\n+            leafSourceLoader\n+        );\n+        storedFieldsLoader.advanceTo(0);\n+\n+        BlockLoader.Builder builder = blockLoader.builder(TestBlock.factory(context.reader().numDocs()), 1);\n+        blockLoader.rowStrideReader(context).read(0, storedFieldsLoader, builder);\n+        var block = (TestBlock) builder.build();\n+        if (block.size() == 0) {\n+            return null;\n+        }\n+        return block.get(0);\n+    }\n+\n+    private BlockLoader createBlockLoader(MapperService mapperService, String fieldName) {\n+        SearchLookup searchLookup = new SearchLookup(mapperService.mappingLookup().fieldTypesLookup()::get, null, null);\n+\n+        return mapperService.fieldType(fieldName).blockLoader(new MappedFieldType.BlockLoaderContext() {\n+            @Override\n+            public String indexName() {\n+                return mapperService.getIndexSettings().getIndex().getName();\n+            }\n+\n+            @Override\n+            public IndexSettings indexSettings() {\n+                return mapperService.getIndexSettings();\n+            }\n+\n+            @Override\n+            public MappedFieldType.FieldExtractPreference fieldExtractPreference() {\n+                return params.preference();\n+            }\n+\n+            @Override\n+            public SearchLookup lookup() {\n+                return searchLookup;\n+            }\n+\n+            @Override\n+            public Set<String> sourcePaths(String name) {\n+                return mapperService.mappingLookup().sourcePaths(name);\n+            }\n+\n+            @Override\n+            public String parentField(String field) {\n+                return mapperService.mappingLookup().parentField(field);\n+            }\n+\n+            @Override\n+            public FieldNamesFieldMapper.FieldNamesFieldType fieldNames() {\n+                return (FieldNamesFieldMapper.FieldNamesFieldType) mapperService.fieldType(FieldNamesFieldMapper.NAME);\n+            }\n+        });\n+    }\n+}\ndiff --git a/x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java b/x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java\nindex 283feffa5dfc3..9460df7a16a5f 100644\n--- a/x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java\n+++ b/x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java\n@@ -15,6 +15,7 @@\n import org.elasticsearch.xpack.aggregatemetric.AggregateMetricMapperPlugin;\n import org.elasticsearch.xpack.aggregatemetric.mapper.datageneration.AggregateMetricDoubleDataSourceHandler;\n \n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashMap;\n@@ -33,6 +34,11 @@ public DataSourceResponse.ObjectArrayGenerator handle(DataSourceRequest.ObjectAr\n         }), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for aggregate_metric_double.\n+    }\n+\n     @Override\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\n         if (value instanceof Map<?, ?> map) {\ndiff --git a/x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java b/x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java\nindex 471a6a9a69fc3..53725cc088e5b 100644\n--- a/x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java\n+++ b/x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java\n@@ -13,6 +13,7 @@\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.xpack.constantkeyword.ConstantKeywordMapperPlugin;\n \n+import java.io.IOException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n@@ -22,6 +23,11 @@ public ConstantKeywordFieldBlockLoaderTests(Params params) {\n         super(FieldType.CONSTANT_KEYWORD.toString(), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for constant_keyword.\n+    }\n+\n     @Override\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\n         return new BytesRef((String) fieldMapping.get(\"value\"));\ndiff --git a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\nindex fda37c5343562..5061c8e303514 100644\n--- a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\n+++ b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\n@@ -379,7 +379,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             if (hasDocValues() && (blContext.fieldExtractPreference() != FieldExtractPreference.STORED || isSyntheticSource)) {\n                 return new BlockDocValuesReader.LongsBlockLoader(name());\n             }\n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {\ndiff --git a/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java b/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java\nindex 872d174a763b7..bde057e95ffc6 100644\n--- a/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java\n+++ b/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java\n@@ -313,7 +313,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             if (blContext.fieldExtractPreference() == FieldExtractPreference.EXTRACT_SPATIAL_BOUNDS) {\n                 return new GeoBoundsBlockLoader(name());\n             }\n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n \ndiff --git a/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java b/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java\nindex 7f66554382d8b..e6c2c0c2687ac 100644\n--- a/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java\n+++ b/x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java\n@@ -201,7 +201,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new CartesianBoundsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n \ndiff --git a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java\nindex 1c88429d04511..394ce2da7d167 100644\n--- a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java\n+++ b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java\n@@ -24,6 +24,7 @@\n import org.elasticsearch.xpack.spatial.LocalStateSpatialPlugin;\n import org.elasticsearch.xpack.spatial.datageneration.GeoShapeDataSourceHandler;\n \n+import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.Collection;\n import java.util.Collections;\n@@ -36,6 +37,11 @@ public GeoShapeFieldBlockLoaderTests(Params params) {\n         super(\"geo_shape\", List.of(new GeoShapeDataSourceHandler()), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for geo_shape.\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\ndiff --git a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java\nindex 922adebaef875..bd4033b0a58d4 100644\n--- a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java\n+++ b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java\n@@ -19,6 +19,7 @@\n import org.elasticsearch.xpack.spatial.common.CartesianPoint;\n import org.elasticsearch.xpack.spatial.datageneration.PointDataSourceHandler;\n \n+import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -32,6 +33,11 @@ public PointFieldBlockLoaderTests(Params params) {\n         super(\"point\", List.of(new PointDataSourceHandler()), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for point.\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\ndiff --git a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java\nindex 2a4a011d08dbb..9fd0b05c249b7 100644\n--- a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java\n+++ b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java\n@@ -22,6 +22,7 @@\n import org.elasticsearch.xpack.spatial.LocalStateSpatialPlugin;\n import org.elasticsearch.xpack.spatial.datageneration.ShapeDataSourceHandler;\n \n+import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.Collection;\n import java.util.Collections;\n@@ -34,6 +35,11 @@ public ShapeFieldBlockLoaderTests(Params params) {\n         super(\"shape\", List.of(new ShapeDataSourceHandler()), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for shape.\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\n",
  "files_changed": 22,
  "additions": 533,
  "deletions": 301,
  "commit_count": 6,
  "mergeable_state": "",
  "base_commit_sha": "637807c82bcd4d335ea248476672e1104731951c",
  "base_commit_link": "https://github.com/elastic/elasticsearch/commit/637807c82bcd4d335ea248476672e1104731951c",
  "last_processed_time": "2025-04-29T01:17:30",
  "comments": [],
  "github_reviews": [],
  "patches": [
    {
      "id": 1820,
      "pr_id": 2487052561,
      "path": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java",
      "patch": "@@ -378,7 +378,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             if (hasDocValues() && (blContext.fieldExtractPreference() != FieldExtractPreference.STORED || isSyntheticSource)) {\n                 return new BlockDocValuesReader.DoublesBlockLoader(name(), l -> l / scalingFactor);\n             }\n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {",
      "filename": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1821,
      "pr_id": 2487052561,
      "path": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java",
      "patch": "@@ -350,7 +350,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockDocValuesReader.BooleansBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {",
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1822,
      "pr_id": 2487052561,
      "path": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java",
      "patch": "@@ -948,7 +948,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockDocValuesReader.LongsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {",
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1823,
      "pr_id": 2487052561,
      "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java",
      "patch": "@@ -316,7 +316,7 @@ protected void index(DocumentParserContext context, GeoPoint geometry) throws IO\n \n     /**\n      * Parser that pretends to be the main document parser, but exposes the provided geohash regardless of how the geopoint was provided\n-     * in the incoming document. We rely on the fact that consumers are only ever call {@link XContentParser#textOrNull()} and never\n+     * in the incoming document. We rely on the fact that consumers only ever read text from the parser and never\n      * advance tokens, which is explicitly disallowed by this parser.\n      */\n     static class GeoHashMultiFieldParser extends FilterXContentParserWrapper {\n@@ -332,6 +332,11 @@ public String textOrNull() throws IOException {\n             return value;\n         }\n \n+        @Override\n+        public String text() throws IOException {\n+            return value;\n+        }\n+\n         @Override\n         public Token currentToken() {\n             return Token.VALUE_STRING;\n@@ -545,8 +550,9 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             // So we have two subcases:\n             // - doc_values are enabled - _ignored_source field does not exist since we have doc_values. We will use\n             // blockLoaderFromSource which reads \"native\" synthetic source.\n-            // - doc_values are disabled - we know that _ignored_source field is present and use a special block loader.\n-            if (isSyntheticSource && hasDocValues() == false) {\n+            // - doc_values are disabled - we know that _ignored_source field is present and use a special block loader unless it's a multi\n+            // field.\n+            if (isSyntheticSource && hasDocValues() == false && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n ",
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java",
      "status": "modified",
      "changes": 12,
      "additions": 9,
      "deletions": 3
    },
    {
      "id": 1824,
      "pr_id": 2487052561,
      "path": "server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java",
      "patch": "@@ -467,7 +467,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockStoredFieldsReader.BytesFromBytesRefsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n ",
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1825,
      "pr_id": 2487052561,
      "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java",
      "patch": "@@ -755,7 +755,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new BlockStoredFieldsReader.BytesFromBytesRefsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {",
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1826,
      "pr_id": 2487052561,
      "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java",
      "patch": "@@ -1973,7 +1973,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return type.blockLoaderFromDocValues(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return type.blockLoaderFromFallbackSyntheticSource(name(), nullValue, coerce);\n             }\n ",
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1827,
      "pr_id": 2487052561,
      "path": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java",
      "patch": "@@ -35,28 +35,29 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         var values = extractedFieldValues.values();\n \n         var nullValue = switch (fieldMapping.get(\"null_value\")) {\n-            case String s -> convert(s, null);\n+            case String s -> convert(s, null, false);\n             case null -> null;\n             default -> throw new IllegalStateException(\"Unexpected null_value format\");\n         };\n \n         if (params.preference() == MappedFieldType.FieldExtractPreference.DOC_VALUES && hasDocValues(fieldMapping, true)) {\n             if (values instanceof List<?> == false) {\n-                var point = convert(values, nullValue);\n+                var point = convert(values, nullValue, testContext.isMultifield());\n                 return point != null ? point.getEncoded() : null;\n             }\n \n             var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue))\n+                .map(v -> convert(v, nullValue, testContext.isMultifield()))\n                 .filter(Objects::nonNull)\n                 .map(GeoPoint::getEncoded)\n                 .sorted()\n                 .toList();\n             return maybeFoldList(resultList);\n         }\n \n+        // stored source is used\n         if (params.syntheticSource() == false) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n \n         // Usually implementation of block loader from source adjusts values read from source\n@@ -67,25 +68,25 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         // That is unless \"synthetic_source_keep\" forces fallback synthetic source again.\n \n         if (testContext.forceFallbackSyntheticSource()) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n \n         String syntheticSourceKeep = (String) fieldMapping.getOrDefault(\"synthetic_source_keep\", \"none\");\n         if (syntheticSourceKeep.equals(\"all\")) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n         if (syntheticSourceKeep.equals(\"arrays\") && extractedFieldValues.documentHasObjectArrays()) {\n-            return exactValuesFromSource(values, nullValue);\n+            return exactValuesFromSource(values, nullValue, false);\n         }\n \n         // synthetic source and doc_values are present\n         if (hasDocValues(fieldMapping, true)) {\n             if (values instanceof List<?> == false) {\n-                return toWKB(normalize(convert(values, nullValue)));\n+                return toWKB(normalize(convert(values, nullValue, false)));\n             }\n \n             var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue))\n+                .map(v -> convert(v, nullValue, false))\n                 .filter(Objects::nonNull)\n                 .sorted(Comparator.comparingLong(GeoPoint::getEncoded))\n                 .map(p -> toWKB(normalize(p)))\n@@ -94,16 +95,20 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         }\n \n         // synthetic source but no doc_values so using fallback synthetic source\n-        return exactValuesFromSource(values, nullValue);\n+        return exactValuesFromSource(values, nullValue, false);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private Object exactValuesFromSource(Object value, GeoPoint nullValue) {\n+    private Object exactValuesFromSource(Object value, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n         if (value instanceof List<?> == false) {\n-            return toWKB(convert(value, nullValue));\n+            return toWKB(convert(value, nullValue, needsMultifieldAdjustment));\n         }\n \n-        var resultList = ((List<Object>) value).stream().map(v -> convert(v, nullValue)).filter(Objects::nonNull).map(this::toWKB).toList();\n+        var resultList = ((List<Object>) value).stream()\n+            .map(v -> convert(v, nullValue, needsMultifieldAdjustment))\n+            .filter(Objects::nonNull)\n+            .map(this::toWKB)\n+            .toList();\n         return maybeFoldList(resultList);\n     }\n \n@@ -163,14 +168,17 @@ private void processLeafLevel(Object value, ArrayList<Object> extracted) {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private GeoPoint convert(Object value, GeoPoint nullValue) {\n+    private GeoPoint convert(Object value, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n         if (value == null) {\n-            return nullValue;\n+            if (nullValue == null) {\n+                return null;\n+            }\n+            return possiblyAdjustMultifieldValue(nullValue, needsMultifieldAdjustment);\n         }\n \n         if (value instanceof String s) {\n             try {\n-                return new GeoPoint(s);\n+                return possiblyAdjustMultifieldValue(new GeoPoint(s), needsMultifieldAdjustment);\n             } catch (Exception e) {\n                 return null;\n             }\n@@ -180,16 +188,30 @@ private GeoPoint convert(Object value, GeoPoint nullValue) {\n             if (m.get(\"type\") != null) {\n                 var coordinates = (List<Double>) m.get(\"coordinates\");\n                 // Order is GeoJSON is lon,lat\n-                return new GeoPoint(coordinates.get(1), coordinates.get(0));\n+                return possiblyAdjustMultifieldValue(new GeoPoint(coordinates.get(1), coordinates.get(0)), needsMultifieldAdjustment);\n             } else {\n-                return new GeoPoint((Double) m.get(\"lat\"), (Double) m.get(\"lon\"));\n+                return possiblyAdjustMultifieldValue(new GeoPoint((Double) m.get(\"lat\"), (Double) m.get(\"lon\")), needsMultifieldAdjustment);\n             }\n         }\n \n         // Malformed values are excluded\n         return null;\n     }\n \n+    private GeoPoint possiblyAdjustMultifieldValue(GeoPoint point, boolean isMultifield) {\n+        // geo_point multifields are parsed from a geohash representation of the original point (GeoPointFieldMapper#index)\n+        // and it's not exact.\n+        // So if this is a multifield we need another adjustment here.\n+        // Note that this does not apply to block loader from source because in this case we parse raw original values.\n+        // Same thing happens with synthetic source since it is generated from the parent field data that didn't go through multi field\n+        // parsing logic.\n+        if (isMultifield) {\n+            return point.resetFromString(point.geohash());\n+        }\n+\n+        return point;\n+    }\n+\n     private GeoPoint normalize(GeoPoint point) {\n         if (point == null) {\n             return null;",
      "filename": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java",
      "status": "modified",
      "changes": 58,
      "additions": 40,
      "deletions": 18
    },
    {
      "id": 1828,
      "pr_id": 2487052561,
      "path": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java",
      "patch": "@@ -9,51 +9,108 @@\n \n package org.elasticsearch.index.mapper.blockloader;\n \n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.datageneration.DocumentGenerator;\n import org.elasticsearch.datageneration.FieldType;\n+import org.elasticsearch.datageneration.MappingGenerator;\n+import org.elasticsearch.datageneration.Template;\n import org.elasticsearch.datageneration.datasource.DataSourceHandler;\n import org.elasticsearch.datageneration.datasource.DataSourceRequest;\n import org.elasticsearch.datageneration.datasource.DataSourceResponse;\n-import org.elasticsearch.datageneration.datasource.DefaultMappingParametersHandler;\n import org.elasticsearch.index.mapper.BlockLoaderTestCase;\n+import org.elasticsearch.index.mapper.BlockLoaderTestRunner;\n+import org.elasticsearch.index.mapper.MapperServiceTestCase;\n+import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xcontent.XContentType;\n \n-import java.util.HashMap;\n+import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n \n-public class TextFieldWithParentBlockLoaderTests extends BlockLoaderTestCase {\n-    public TextFieldWithParentBlockLoaderTests(Params params) {\n-        // keyword because we need a keyword parent field\n-        super(FieldType.KEYWORD.toString(), List.of(new DataSourceHandler() {\n+import static org.elasticsearch.index.mapper.BlockLoaderTestCase.buildSpecification;\n+import static org.elasticsearch.index.mapper.BlockLoaderTestCase.hasDocValues;\n+\n+public class TextFieldWithParentBlockLoaderTests extends MapperServiceTestCase {\n+    private final BlockLoaderTestCase.Params params;\n+    private final BlockLoaderTestRunner runner;\n+\n+    @ParametersFactory(argumentFormatting = \"preference=%s\")\n+    public static List<Object[]> args() {\n+        return BlockLoaderTestCase.args();\n+    }\n+\n+    public TextFieldWithParentBlockLoaderTests(BlockLoaderTestCase.Params params) {\n+        this.params = params;\n+        this.runner = new BlockLoaderTestRunner(params);\n+    }\n+\n+    // This is similar to BlockLoaderTestCase#testBlockLoaderOfMultiField but has customizations required to properly test the case\n+    // of text multi field in a keyword field.\n+    public void testBlockLoaderOfParentField() throws IOException {\n+        var template = new Template(Map.of(\"parent\", new Template.Leaf(\"parent\", FieldType.KEYWORD.toString())));\n+        var specification = buildSpecification(List.of(new DataSourceHandler() {\n             @Override\n             public DataSourceResponse.LeafMappingParametersGenerator handle(DataSourceRequest.LeafMappingParametersGenerator request) {\n-                assert request.fieldType().equals(FieldType.KEYWORD.toString());\n+                // This is a bit tricky meta-logic.\n+                // We want to customize mapping but to do this we need the mapping for the same field type\n+                // so we use name to untangle this.\n+                if (request.fieldName().equals(\"parent\") == false) {\n+                    return null;\n+                }\n \n-                // We need to force multi field generation\n                 return new DataSourceResponse.LeafMappingParametersGenerator(() -> {\n-                    var defaultSupplier = DefaultMappingParametersHandler.keywordMapping(\n-                        request,\n-                        DefaultMappingParametersHandler.commonMappingParameters()\n-                    );\n-                    var mapping = defaultSupplier.get();\n+                    var dataSource = request.dataSource();\n+\n+                    var keywordParentMapping = dataSource.get(\n+                        new DataSourceRequest.LeafMappingParametersGenerator(\n+                            dataSource,\n+                            \"_field\",\n+                            FieldType.KEYWORD.toString(),\n+                            request.eligibleCopyToFields(),\n+                            request.dynamicMapping()\n+                        )\n+                    ).mappingGenerator().get();\n+\n+                    var textMultiFieldMapping = dataSource.get(\n+                        new DataSourceRequest.LeafMappingParametersGenerator(\n+                            dataSource,\n+                            \"_field\",\n+                            FieldType.TEXT.toString(),\n+                            request.eligibleCopyToFields(),\n+                            request.dynamicMapping()\n+                        )\n+                    ).mappingGenerator().get();\n+\n                     // we don't need this here\n-                    mapping.remove(\"copy_to\");\n+                    keywordParentMapping.remove(\"copy_to\");\n \n-                    var textMultiFieldMappingSupplier = DefaultMappingParametersHandler.textMapping(request, new HashMap<>());\n-                    var textMultiFieldMapping = textMultiFieldMappingSupplier.get();\n                     textMultiFieldMapping.put(\"type\", \"text\");\n                     textMultiFieldMapping.remove(\"fields\");\n \n-                    mapping.put(\"fields\", Map.of(\"txt\", textMultiFieldMapping));\n+                    keywordParentMapping.put(\"fields\", Map.of(\"mf\", textMultiFieldMapping));\n \n-                    return mapping;\n+                    return keywordParentMapping;\n                 });\n             }\n-        }), params);\n+        }));\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var fieldMapping = mapping.lookup().get(\"parent\");\n+\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n+        var fieldValue = document.get(\"parent\");\n+\n+        Object expected = expected(fieldMapping, fieldValue, new BlockLoaderTestCase.TestContext(false, true));\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+        var mapperService = params.syntheticSource()\n+            ? createSytheticSourceMapperService(mappingXContent)\n+            : createMapperService(mappingXContent);\n+\n+        runner.runTest(mapperService, document, expected, \"parent.mf\");\n     }\n \n-    @Override\n     @SuppressWarnings(\"unchecked\")\n-    protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\n+    private Object expected(Map<String, Object> fieldMapping, Object value, BlockLoaderTestCase.TestContext testContext) {\n         assert fieldMapping.containsKey(\"fields\");\n \n         Object normalizer = fieldMapping.get(\"normalizer\");\n@@ -66,12 +123,7 @@ protected Object expected(Map<String, Object> fieldMapping, Object value, TestCo\n         }\n \n         // we are using block loader of the text field itself\n-        var textFieldMapping = (Map<String, Object>) ((Map<String, Object>) fieldMapping.get(\"fields\")).get(\"txt\");\n+        var textFieldMapping = (Map<String, Object>) ((Map<String, Object>) fieldMapping.get(\"fields\")).get(\"mf\");\n         return TextFieldBlockLoaderTests.expectedValue(textFieldMapping, value, params, testContext);\n     }\n-\n-    @Override\n-    protected String blockLoaderFieldName(String originalName) {\n-        return originalName + \".txt\";\n-    }\n }",
      "filename": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java",
      "status": "modified",
      "changes": 106,
      "additions": 79,
      "deletions": 27
    },
    {
      "id": 1830,
      "pr_id": 2487052561,
      "path": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java",
      "patch": "@@ -199,6 +199,7 @@ public DataSourceResponse.ObjectArrayGenerator accept(DataSourceHandler handler)\n     }\n \n     record LeafMappingParametersGenerator(\n+        DataSource dataSource,\n         String fieldName,\n         String fieldType,\n         Set<String> eligibleCopyToFields,",
      "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java",
      "status": "modified",
      "changes": 1,
      "additions": 1,
      "deletions": 0
    },
    {
      "id": 1831,
      "pr_id": 2487052561,
      "path": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java",
      "patch": "@@ -36,34 +36,27 @@ public DataSourceResponse.LeafMappingParametersGenerator handle(DataSourceReques\n             return null;\n         }\n \n-        var map = commonMappingParameters();\n-        if (ESTestCase.randomBoolean()) {\n-            map.put(Mapper.SYNTHETIC_SOURCE_KEEP_PARAM, ESTestCase.randomFrom(\"none\", \"arrays\", \"all\"));\n-        }\n-\n         return new DataSourceResponse.LeafMappingParametersGenerator(switch (fieldType) {\n-            case KEYWORD -> keywordMapping(request, map);\n-            case LONG, INTEGER, SHORT, BYTE, DOUBLE, FLOAT, HALF_FLOAT, UNSIGNED_LONG -> numberMapping(map, fieldType);\n-            case SCALED_FLOAT -> scaledFloatMapping(map);\n-            case COUNTED_KEYWORD -> plain(Map.of(\"index\", ESTestCase.randomBoolean()));\n-            case BOOLEAN -> booleanMapping(map);\n-            case DATE -> dateMapping(map);\n-            case GEO_POINT -> geoPointMapping(map);\n-            case TEXT -> textMapping(request, new HashMap<>());\n-            case IP -> ipMapping(map);\n-            case CONSTANT_KEYWORD -> constantKeywordMapping(new HashMap<>());\n-            case WILDCARD -> wildcardMapping(new HashMap<>());\n+            case KEYWORD -> keywordMapping(request);\n+            case LONG, INTEGER, SHORT, BYTE, DOUBLE, FLOAT, HALF_FLOAT, UNSIGNED_LONG -> numberMapping(fieldType);\n+            case SCALED_FLOAT -> scaledFloatMapping();\n+            case COUNTED_KEYWORD -> countedKeywordMapping();\n+            case BOOLEAN -> booleanMapping();\n+            case DATE -> dateMapping();\n+            case GEO_POINT -> geoPointMapping();\n+            case TEXT -> textMapping(request);\n+            case IP -> ipMapping();\n+            case CONSTANT_KEYWORD -> constantKeywordMapping();\n+            case WILDCARD -> wildcardMapping();\n         });\n     }\n \n-    private Supplier<Map<String, Object>> plain(Map<String, Object> injected) {\n-        return () -> injected;\n-    }\n-\n-    private Supplier<Map<String, Object>> numberMapping(Map<String, Object> injected, FieldType fieldType) {\n+    private Supplier<Map<String, Object>> numberMapping(FieldType fieldType) {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n             if (ESTestCase.randomDouble() <= 0.2) {\n                 Number value = switch (fieldType) {\n@@ -77,18 +70,17 @@ private Supplier<Map<String, Object>> numberMapping(Map<String, Object> injected\n                     default -> throw new IllegalStateException(\"Unexpected field type\");\n                 };\n \n-                injected.put(\"null_value\", value);\n+                mapping.put(\"null_value\", value);\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    public static Supplier<Map<String, Object>> keywordMapping(\n-        DataSourceRequest.LeafMappingParametersGenerator request,\n-        Map<String, Object> injected\n-    ) {\n+    private Supplier<Map<String, Object>> keywordMapping(DataSourceRequest.LeafMappingParametersGenerator request) {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             // Inject copy_to sometimes but reflect that it is not widely used in reality.\n             // We only add copy_to to keywords because we get into trouble with numeric fields that are copied to dynamic fields.\n             // If first copied value is numeric, dynamic field is created with numeric field type and then copy of text values fail.\n@@ -100,152 +92,169 @@ public static Supplier<Map<String, Object>> keywordMapping(\n                     .collect(Collectors.toSet());\n \n                 if (options.isEmpty() == false) {\n-                    injected.put(\"copy_to\", ESTestCase.randomFrom(options));\n+                    mapping.put(\"copy_to\", ESTestCase.randomFrom(options));\n                 }\n             }\n \n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n+                mapping.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n             }\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n+                mapping.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> scaledFloatMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> scaledFloatMapping() {\n         return () -> {\n-            injected.put(\"scaling_factor\", ESTestCase.randomFrom(10, 1000, 100000, 100.5));\n+            var mapping = commonMappingParameters();\n+\n+            mapping.put(\"scaling_factor\", ESTestCase.randomFrom(10, 1000, 100000, 100.5));\n \n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomDouble());\n+                mapping.put(\"null_value\", ESTestCase.randomDouble());\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> booleanMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> countedKeywordMapping() {\n+        return () -> Map.of(\"index\", ESTestCase.randomBoolean());\n+    }\n+\n+    private Supplier<Map<String, Object>> booleanMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomFrom(true, false, \"true\", \"false\"));\n+                mapping.put(\"null_value\", ESTestCase.randomFrom(true, false, \"true\", \"false\"));\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n     // just a custom format, specific format does not matter\n     private static final String FORMAT = \"yyyy_MM_dd_HH_mm_ss_n\";\n \n-    private Supplier<Map<String, Object>> dateMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> dateMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             String format = null;\n             if (ESTestCase.randomBoolean()) {\n                 format = FORMAT;\n-                injected.put(\"format\", format);\n+                mapping.put(\"format\", format);\n             }\n \n             if (ESTestCase.randomDouble() <= 0.2) {\n                 var instant = ESTestCase.randomInstantBetween(Instant.parse(\"2300-01-01T00:00:00Z\"), Instant.parse(\"2350-01-01T00:00:00Z\"));\n \n                 if (format == null) {\n-                    injected.put(\"null_value\", instant.toEpochMilli());\n+                    mapping.put(\"null_value\", instant.toEpochMilli());\n                 } else {\n-                    injected.put(\n+                    mapping.put(\n                         \"null_value\",\n                         DateTimeFormatter.ofPattern(format, Locale.ROOT).withZone(ZoneId.from(ZoneOffset.UTC)).format(instant)\n                     );\n                 }\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> geoPointMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> geoPointMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n                 var point = GeometryTestUtils.randomPoint(false);\n-                injected.put(\"null_value\", WellKnownText.toWKT(point));\n+                mapping.put(\"null_value\", WellKnownText.toWKT(point));\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    public static Supplier<Map<String, Object>> textMapping(\n-        DataSourceRequest.LeafMappingParametersGenerator request,\n-        Map<String, Object> injected\n-    ) {\n+    private Supplier<Map<String, Object>> textMapping(DataSourceRequest.LeafMappingParametersGenerator request) {\n         return () -> {\n-            injected.put(\"store\", ESTestCase.randomBoolean());\n-            injected.put(\"index\", ESTestCase.randomBoolean());\n+            var mapping = new HashMap<String, Object>();\n+\n+            mapping.put(\"store\", ESTestCase.randomBoolean());\n+            mapping.put(\"index\", ESTestCase.randomBoolean());\n \n             if (ESTestCase.randomDouble() <= 0.1) {\n-                var keywordMultiFieldMapping = keywordMapping(request, commonMappingParameters()).get();\n+                var keywordMultiFieldMapping = keywordMapping(request).get();\n                 keywordMultiFieldMapping.put(\"type\", \"keyword\");\n                 keywordMultiFieldMapping.remove(\"copy_to\");\n \n-                injected.put(\"fields\", Map.of(\"kwd\", keywordMultiFieldMapping));\n+                mapping.put(\"fields\", Map.of(\"kwd\", keywordMultiFieldMapping));\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> ipMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> ipMapping() {\n         return () -> {\n+            var mapping = commonMappingParameters();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", NetworkAddress.format(ESTestCase.randomIp(ESTestCase.randomBoolean())));\n+                mapping.put(\"null_value\", NetworkAddress.format(ESTestCase.randomIp(ESTestCase.randomBoolean())));\n             }\n \n             if (ESTestCase.randomBoolean()) {\n-                injected.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n+                mapping.put(\"ignore_malformed\", ESTestCase.randomBoolean());\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> constantKeywordMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> constantKeywordMapping() {\n         return () -> {\n+            var mapping = new HashMap<String, Object>();\n+\n             // value is optional and can be set from the first document\n             // we don't cover this case here\n-            injected.put(\"value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n+            mapping.put(\"value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n-    private Supplier<Map<String, Object>> wildcardMapping(Map<String, Object> injected) {\n+    private Supplier<Map<String, Object>> wildcardMapping() {\n         return () -> {\n+            var mapping = new HashMap<String, Object>();\n+\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n+                mapping.put(\"ignore_above\", ESTestCase.randomIntBetween(1, 100));\n             }\n             if (ESTestCase.randomDouble() <= 0.2) {\n-                injected.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n+                mapping.put(\"null_value\", ESTestCase.randomAlphaOfLengthBetween(0, 10));\n             }\n \n-            return injected;\n+            return mapping;\n         };\n     }\n \n@@ -254,6 +263,11 @@ public static HashMap<String, Object> commonMappingParameters() {\n         map.put(\"store\", ESTestCase.randomBoolean());\n         map.put(\"index\", ESTestCase.randomBoolean());\n         map.put(\"doc_values\", ESTestCase.randomBoolean());\n+\n+        if (ESTestCase.randomBoolean()) {\n+            map.put(Mapper.SYNTHETIC_SOURCE_KEEP_PARAM, ESTestCase.randomFrom(\"none\", \"arrays\", \"all\"));\n+        }\n+\n         return map;\n     }\n ",
      "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java",
      "status": "modified",
      "changes": 156,
      "additions": 85,
      "deletions": 71
    },
    {
      "id": 1829,
      "pr_id": 2487052561,
      "path": "test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java",
      "patch": "@@ -104,6 +104,7 @@ private void generateMapping(\n                 var mappingParametersGenerator = specification.dataSource()\n                     .get(\n                         new DataSourceRequest.LeafMappingParametersGenerator(\n+                            specification.dataSource(),\n                             fieldName,\n                             leaf.type(),\n                             context.eligibleCopyToDestinations(),",
      "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java",
      "status": "modified",
      "changes": 1,
      "additions": 1,
      "deletions": 0
    },
    {
      "id": 1832,
      "pr_id": 2487052561,
      "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java",
      "patch": "@@ -11,24 +11,13 @@\n \n import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n \n-import org.apache.lucene.index.DirectoryReader;\n-import org.apache.lucene.index.LeafReaderContext;\n-import org.apache.lucene.store.Directory;\n-import org.apache.lucene.tests.index.RandomIndexWriter;\n-import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.datageneration.DataGeneratorSpecification;\n import org.elasticsearch.datageneration.DocumentGenerator;\n-import org.elasticsearch.datageneration.Mapping;\n import org.elasticsearch.datageneration.MappingGenerator;\n import org.elasticsearch.datageneration.Template;\n import org.elasticsearch.datageneration.datasource.DataSourceHandler;\n import org.elasticsearch.datageneration.datasource.DataSourceRequest;\n import org.elasticsearch.datageneration.datasource.DataSourceResponse;\n-import org.elasticsearch.index.IndexSettings;\n-import org.elasticsearch.index.fieldvisitor.StoredFieldLoader;\n-import org.elasticsearch.plugins.internal.XContentMeteringParserDecorator;\n-import org.elasticsearch.search.fetch.StoredFieldsSpec;\n-import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n \n@@ -38,7 +27,6 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import java.util.stream.Stream;\n \n public abstract class BlockLoaderTestCase extends MapperServiceTestCase {\n@@ -60,46 +48,26 @@ public static List<Object[]> args() {\n \n     public record Params(boolean syntheticSource, MappedFieldType.FieldExtractPreference preference) {}\n \n-    public record TestContext(boolean forceFallbackSyntheticSource) {}\n+    public record TestContext(boolean forceFallbackSyntheticSource, boolean isMultifield) {}\n \n     private final String fieldType;\n     protected final Params params;\n+    private final Collection<DataSourceHandler> customDataSourceHandlers;\n+    private final BlockLoaderTestRunner runner;\n \n     private final String fieldName;\n-    private final MappingGenerator mappingGenerator;\n-    private final DocumentGenerator documentGenerator;\n \n     protected BlockLoaderTestCase(String fieldType, Params params) {\n         this(fieldType, List.of(), params);\n     }\n \n-    protected BlockLoaderTestCase(String fieldType, Collection<DataSourceHandler> customHandlers, Params params) {\n+    protected BlockLoaderTestCase(String fieldType, Collection<DataSourceHandler> customDataSourceHandlers, Params params) {\n         this.fieldType = fieldType;\n         this.params = params;\n+        this.customDataSourceHandlers = customDataSourceHandlers;\n+        this.runner = new BlockLoaderTestRunner(params);\n \n         this.fieldName = randomAlphaOfLengthBetween(5, 10);\n-\n-        var specification = DataGeneratorSpecification.builder()\n-            .withFullyDynamicMapping(false)\n-            // Disable dynamic mapping and disabled objects\n-            .withDataSourceHandlers(List.of(new DataSourceHandler() {\n-                @Override\n-                public DataSourceResponse.DynamicMappingGenerator handle(DataSourceRequest.DynamicMappingGenerator request) {\n-                    return new DataSourceResponse.DynamicMappingGenerator(isObject -> false);\n-                }\n-\n-                @Override\n-                public DataSourceResponse.ObjectMappingParametersGenerator handle(\n-                    DataSourceRequest.ObjectMappingParametersGenerator request\n-                ) {\n-                    return new DataSourceResponse.ObjectMappingParametersGenerator(HashMap::new); // just defaults\n-                }\n-            }))\n-            .withDataSourceHandlers(customHandlers)\n-            .build();\n-\n-        this.mappingGenerator = new MappingGenerator(specification);\n-        this.documentGenerator = new DocumentGenerator(specification);\n     }\n \n     @Override\n@@ -114,9 +82,19 @@ public void testFieldHasValueWithEmptyFieldInfos() {\n \n     public void testBlockLoader() throws IOException {\n         var template = new Template(Map.of(fieldName, new Template.Leaf(fieldName, fieldType)));\n-        var mapping = mappingGenerator.generate(template);\n+        var specification = buildSpecification(customDataSourceHandlers);\n+\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n+\n+        Object expected = expected(mapping.lookup().get(fieldName), getFieldValue(document, fieldName), new TestContext(false, false));\n+\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+        var mapperService = params.syntheticSource\n+            ? createSytheticSourceMapperService(mappingXContent)\n+            : createMapperService(mappingXContent);\n \n-        runTest(template, mapping, fieldName, new TestContext(false));\n+        runner.runTest(mapperService, document, expected, fieldName);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n@@ -140,39 +118,131 @@ public void testBlockLoaderForFieldInObject() throws IOException {\n         currentLevel.put(fieldName, new Template.Leaf(fieldName, fieldType));\n         var template = new Template(top);\n \n-        var mapping = mappingGenerator.generate(template);\n+        var specification = buildSpecification(customDataSourceHandlers);\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n \n-        TestContext testContext = new TestContext(false);\n+        TestContext testContext = new TestContext(false, false);\n \n         if (params.syntheticSource && randomBoolean()) {\n             // force fallback synthetic source in the hierarchy\n             var docMapping = (Map<String, Object>) mapping.raw().get(\"_doc\");\n             var topLevelMapping = (Map<String, Object>) ((Map<String, Object>) docMapping.get(\"properties\")).get(\"top\");\n             topLevelMapping.put(\"synthetic_source_keep\", \"all\");\n \n-            testContext = new TestContext(true);\n+            testContext = new TestContext(true, false);\n         }\n \n-        runTest(template, mapping, fullFieldName.toString(), testContext);\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+        var mapperService = params.syntheticSource\n+            ? createSytheticSourceMapperService(mappingXContent)\n+            : createMapperService(mappingXContent);\n+\n+        Object expected = expected(\n+            mapping.lookup().get(fullFieldName.toString()),\n+            getFieldValue(document, fullFieldName.toString()),\n+            testContext\n+        );\n+\n+        runner.runTest(mapperService, document, expected, fullFieldName.toString());\n     }\n \n-    private void runTest(Template template, Mapping mapping, String fieldName, TestContext testContext) throws IOException {\n-        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // We are going to have a parent field and a multi field of the same type in order to be sure we can index data.\n+        // Then we'll test block loader of the multi field.\n+        var template = new Template(Map.of(\"parent\", new Template.Leaf(\"parent\", fieldType)));\n+\n+        var customHandlers = new ArrayList<DataSourceHandler>();\n+        customHandlers.add(new DataSourceHandler() {\n+            @Override\n+            public DataSourceResponse.LeafMappingParametersGenerator handle(DataSourceRequest.LeafMappingParametersGenerator request) {\n+                // This is a bit tricky meta-logic.\n+                // We want to customize mapping but to do this we need the mapping for the same field type\n+                // so we use name to untangle this.\n+                if (request.fieldName().equals(\"parent\") == false) {\n+                    return null;\n+                }\n+\n+                return new DataSourceResponse.LeafMappingParametersGenerator(() -> {\n+                    var dataSource = request.dataSource();\n+\n+                    // We need parent field to have the same mapping as multi field due to different behavior caused f.e. by\n+                    // ignore_malformed.\n+                    // The name here should be different from \"parent\".\n+                    var mapping = dataSource.get(\n+                        new DataSourceRequest.LeafMappingParametersGenerator(\n+                            dataSource,\n+                            \"_field\",\n+                            request.fieldType(),\n+                            request.eligibleCopyToFields(),\n+                            request.dynamicMapping()\n+                        )\n+                    ).mappingGenerator().get();\n+\n+                    var parentMapping = new HashMap<>(mapping);\n+                    var multiFieldMapping = new HashMap<>(mapping);\n \n+                    multiFieldMapping.put(\"type\", fieldType);\n+                    multiFieldMapping.remove(\"fields\");\n+\n+                    parentMapping.put(\"fields\", Map.of(\"mf\", multiFieldMapping));\n+\n+                    return parentMapping;\n+                });\n+            }\n+        });\n+        customHandlers.addAll(customDataSourceHandlers);\n+        var specification = buildSpecification(customHandlers);\n+        var mapping = new MappingGenerator(specification).generate(template);\n+        var fieldMapping = (Map<String, Object>) ((Map<String, Object>) mapping.lookup().get(\"parent\").get(\"fields\")).get(\"mf\");\n+\n+        var document = new DocumentGenerator(specification).generate(template, mapping);\n+\n+        Object expected = expected(fieldMapping, getFieldValue(document, \"parent\"), new TestContext(false, true));\n+        var mappingXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(mapping.raw());\n         var mapperService = params.syntheticSource\n             ? createSytheticSourceMapperService(mappingXContent)\n             : createMapperService(mappingXContent);\n \n-        var document = documentGenerator.generate(template, mapping);\n-        var documentXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(document);\n+        runner.runTest(mapperService, document, expected, \"parent.mf\");\n+    }\n+\n+    public static DataGeneratorSpecification buildSpecification(Collection<DataSourceHandler> customHandlers) {\n+        return DataGeneratorSpecification.builder()\n+            .withFullyDynamicMapping(false)\n+            // Disable dynamic mapping and disabled objects\n+            .withDataSourceHandlers(List.of(new DataSourceHandler() {\n+                @Override\n+                public DataSourceResponse.DynamicMappingGenerator handle(DataSourceRequest.DynamicMappingGenerator request) {\n+                    return new DataSourceResponse.DynamicMappingGenerator(isObject -> false);\n+                }\n \n-        Object expected = expected(mapping.lookup().get(fieldName), getFieldValue(document, fieldName), testContext);\n-        Object blockLoaderResult = setupAndInvokeBlockLoader(mapperService, documentXContent, blockLoaderFieldName(fieldName));\n-        assertEquals(expected, blockLoaderResult);\n+                @Override\n+                public DataSourceResponse.ObjectMappingParametersGenerator handle(\n+                    DataSourceRequest.ObjectMappingParametersGenerator request\n+                ) {\n+                    return new DataSourceResponse.ObjectMappingParametersGenerator(HashMap::new); // just defaults\n+                }\n+            }))\n+            .withDataSourceHandlers(customHandlers)\n+            .build();\n     }\n \n     protected abstract Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext);\n \n+    protected static Object maybeFoldList(List<?> list) {\n+        if (list.isEmpty()) {\n+            return null;\n+        }\n+\n+        if (list.size() == 1) {\n+            return list.get(0);\n+        }\n+\n+        return list;\n+    }\n+\n     protected Object getFieldValue(Map<String, Object> document, String fieldName) {\n         var rawValues = new ArrayList<>();\n         processLevel(document, fieldName, rawValues);\n@@ -204,128 +274,7 @@ private void processLevel(Map<String, Object> level, String field, ArrayList<Obj\n         }\n     }\n \n-    protected static Object maybeFoldList(List<?> list) {\n-        if (list.isEmpty()) {\n-            return null;\n-        }\n-\n-        if (list.size() == 1) {\n-            return list.get(0);\n-        }\n-\n-        return list;\n-    }\n-\n-    /**\n-        Allows to change the field name used to obtain a block loader.\n-        Useful f.e. to test block loaders of multi fields.\n-     */\n-    protected String blockLoaderFieldName(String originalName) {\n-        return originalName;\n-    }\n-\n-    private Object setupAndInvokeBlockLoader(MapperService mapperService, XContentBuilder document, String fieldName) throws IOException {\n-        try (Directory directory = newDirectory()) {\n-            RandomIndexWriter iw = new RandomIndexWriter(random(), directory);\n-\n-            var source = new SourceToParse(\n-                \"1\",\n-                BytesReference.bytes(document),\n-                XContentType.JSON,\n-                null,\n-                Map.of(),\n-                true,\n-                XContentMeteringParserDecorator.NOOP\n-            );\n-            LuceneDocument doc = mapperService.documentMapper().parse(source).rootDoc();\n-\n-            iw.addDocument(doc);\n-            iw.close();\n-\n-            try (DirectoryReader reader = DirectoryReader.open(directory)) {\n-                LeafReaderContext context = reader.leaves().get(0);\n-                return load(createBlockLoader(mapperService, fieldName), context, mapperService);\n-            }\n-        }\n-    }\n-\n-    private Object load(BlockLoader blockLoader, LeafReaderContext context, MapperService mapperService) throws IOException {\n-        // `columnAtATimeReader` is tried first, we mimic `ValuesSourceReaderOperator`\n-        var columnAtATimeReader = blockLoader.columnAtATimeReader(context);\n-        if (columnAtATimeReader != null) {\n-            var block = (TestBlock) columnAtATimeReader.read(TestBlock.factory(context.reader().numDocs()), TestBlock.docs(0));\n-            if (block.size() == 0) {\n-                return null;\n-            }\n-            return block.get(0);\n-        }\n-\n-        StoredFieldsSpec storedFieldsSpec = blockLoader.rowStrideStoredFieldSpec();\n-        SourceLoader.Leaf leafSourceLoader = null;\n-        if (storedFieldsSpec.requiresSource()) {\n-            var sourceLoader = mapperService.mappingLookup().newSourceLoader(null, SourceFieldMetrics.NOOP);\n-            leafSourceLoader = sourceLoader.leaf(context.reader(), null);\n-            storedFieldsSpec = storedFieldsSpec.merge(\n-                new StoredFieldsSpec(true, storedFieldsSpec.requiresMetadata(), sourceLoader.requiredStoredFields())\n-            );\n-        }\n-        BlockLoaderStoredFieldsFromLeafLoader storedFieldsLoader = new BlockLoaderStoredFieldsFromLeafLoader(\n-            StoredFieldLoader.fromSpec(storedFieldsSpec).getLoader(context, null),\n-            leafSourceLoader\n-        );\n-        storedFieldsLoader.advanceTo(0);\n-\n-        BlockLoader.Builder builder = blockLoader.builder(TestBlock.factory(context.reader().numDocs()), 1);\n-        blockLoader.rowStrideReader(context).read(0, storedFieldsLoader, builder);\n-        var block = (TestBlock) builder.build();\n-        if (block.size() == 0) {\n-            return null;\n-        }\n-        return block.get(0);\n-    }\n-\n-    private BlockLoader createBlockLoader(MapperService mapperService, String fieldName) {\n-        SearchLookup searchLookup = new SearchLookup(mapperService.mappingLookup().fieldTypesLookup()::get, null, null);\n-\n-        return mapperService.fieldType(fieldName).blockLoader(new MappedFieldType.BlockLoaderContext() {\n-            @Override\n-            public String indexName() {\n-                return mapperService.getIndexSettings().getIndex().getName();\n-            }\n-\n-            @Override\n-            public IndexSettings indexSettings() {\n-                return mapperService.getIndexSettings();\n-            }\n-\n-            @Override\n-            public MappedFieldType.FieldExtractPreference fieldExtractPreference() {\n-                return params.preference;\n-            }\n-\n-            @Override\n-            public SearchLookup lookup() {\n-                return searchLookup;\n-            }\n-\n-            @Override\n-            public Set<String> sourcePaths(String name) {\n-                return mapperService.mappingLookup().sourcePaths(name);\n-            }\n-\n-            @Override\n-            public String parentField(String field) {\n-                return mapperService.mappingLookup().parentField(field);\n-            }\n-\n-            @Override\n-            public FieldNamesFieldMapper.FieldNamesFieldType fieldNames() {\n-                return (FieldNamesFieldMapper.FieldNamesFieldType) mapperService.fieldType(FieldNamesFieldMapper.NAME);\n-            }\n-        });\n-    }\n-\n-    protected static boolean hasDocValues(Map<String, Object> fieldMapping, boolean defaultValue) {\n+    public static boolean hasDocValues(Map<String, Object> fieldMapping, boolean defaultValue) {\n         return (boolean) fieldMapping.getOrDefault(\"doc_values\", defaultValue);\n     }\n }",
      "filename": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java",
      "status": "modified",
      "changes": 295,
      "additions": 122,
      "deletions": 173
    },
    {
      "id": 1833,
      "pr_id": 2487052561,
      "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java",
      "patch": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.tests.index.RandomIndexWriter;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fieldvisitor.StoredFieldLoader;\n+import org.elasticsearch.plugins.internal.XContentMeteringParserDecorator;\n+import org.elasticsearch.search.fetch.StoredFieldsSpec;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xcontent.XContentType;\n+import org.junit.Assert;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.lucene.tests.util.LuceneTestCase.newDirectory;\n+import static org.apache.lucene.tests.util.LuceneTestCase.random;\n+\n+public class BlockLoaderTestRunner {\n+    private final BlockLoaderTestCase.Params params;\n+\n+    public BlockLoaderTestRunner(BlockLoaderTestCase.Params params) {\n+        this.params = params;\n+    }\n+\n+    public void runTest(MapperService mapperService, Map<String, Object> document, Object expected, String blockLoaderFieldName)\n+        throws IOException {\n+        var documentXContent = XContentBuilder.builder(XContentType.JSON.xContent()).map(document);\n+\n+        Object blockLoaderResult = setupAndInvokeBlockLoader(mapperService, documentXContent, blockLoaderFieldName);\n+        Assert.assertEquals(expected, blockLoaderResult);\n+    }\n+\n+    private Object setupAndInvokeBlockLoader(MapperService mapperService, XContentBuilder document, String fieldName) throws IOException {\n+        try (Directory directory = newDirectory()) {\n+            RandomIndexWriter iw = new RandomIndexWriter(random(), directory);\n+\n+            var source = new SourceToParse(\n+                \"1\",\n+                BytesReference.bytes(document),\n+                XContentType.JSON,\n+                null,\n+                Map.of(),\n+                true,\n+                XContentMeteringParserDecorator.NOOP\n+            );\n+            LuceneDocument doc = mapperService.documentMapper().parse(source).rootDoc();\n+\n+            iw.addDocument(doc);\n+            iw.close();\n+\n+            try (DirectoryReader reader = DirectoryReader.open(directory)) {\n+                LeafReaderContext context = reader.leaves().get(0);\n+                return load(createBlockLoader(mapperService, fieldName), context, mapperService);\n+            }\n+        }\n+    }\n+\n+    private Object load(BlockLoader blockLoader, LeafReaderContext context, MapperService mapperService) throws IOException {\n+        // `columnAtATimeReader` is tried first, we mimic `ValuesSourceReaderOperator`\n+        var columnAtATimeReader = blockLoader.columnAtATimeReader(context);\n+        if (columnAtATimeReader != null) {\n+            var block = (TestBlock) columnAtATimeReader.read(TestBlock.factory(context.reader().numDocs()), TestBlock.docs(0));\n+            if (block.size() == 0) {\n+                return null;\n+            }\n+            return block.get(0);\n+        }\n+\n+        StoredFieldsSpec storedFieldsSpec = blockLoader.rowStrideStoredFieldSpec();\n+        SourceLoader.Leaf leafSourceLoader = null;\n+        if (storedFieldsSpec.requiresSource()) {\n+            var sourceLoader = mapperService.mappingLookup().newSourceLoader(null, SourceFieldMetrics.NOOP);\n+            leafSourceLoader = sourceLoader.leaf(context.reader(), null);\n+            storedFieldsSpec = storedFieldsSpec.merge(\n+                new StoredFieldsSpec(true, storedFieldsSpec.requiresMetadata(), sourceLoader.requiredStoredFields())\n+            );\n+        }\n+        BlockLoaderStoredFieldsFromLeafLoader storedFieldsLoader = new BlockLoaderStoredFieldsFromLeafLoader(\n+            StoredFieldLoader.fromSpec(storedFieldsSpec).getLoader(context, null),\n+            leafSourceLoader\n+        );\n+        storedFieldsLoader.advanceTo(0);\n+\n+        BlockLoader.Builder builder = blockLoader.builder(TestBlock.factory(context.reader().numDocs()), 1);\n+        blockLoader.rowStrideReader(context).read(0, storedFieldsLoader, builder);\n+        var block = (TestBlock) builder.build();\n+        if (block.size() == 0) {\n+            return null;\n+        }\n+        return block.get(0);\n+    }\n+\n+    private BlockLoader createBlockLoader(MapperService mapperService, String fieldName) {\n+        SearchLookup searchLookup = new SearchLookup(mapperService.mappingLookup().fieldTypesLookup()::get, null, null);\n+\n+        return mapperService.fieldType(fieldName).blockLoader(new MappedFieldType.BlockLoaderContext() {\n+            @Override\n+            public String indexName() {\n+                return mapperService.getIndexSettings().getIndex().getName();\n+            }\n+\n+            @Override\n+            public IndexSettings indexSettings() {\n+                return mapperService.getIndexSettings();\n+            }\n+\n+            @Override\n+            public MappedFieldType.FieldExtractPreference fieldExtractPreference() {\n+                return params.preference();\n+            }\n+\n+            @Override\n+            public SearchLookup lookup() {\n+                return searchLookup;\n+            }\n+\n+            @Override\n+            public Set<String> sourcePaths(String name) {\n+                return mapperService.mappingLookup().sourcePaths(name);\n+            }\n+\n+            @Override\n+            public String parentField(String field) {\n+                return mapperService.mappingLookup().parentField(field);\n+            }\n+\n+            @Override\n+            public FieldNamesFieldMapper.FieldNamesFieldType fieldNames() {\n+                return (FieldNamesFieldMapper.FieldNamesFieldType) mapperService.fieldType(FieldNamesFieldMapper.NAME);\n+            }\n+        });\n+    }\n+}",
      "filename": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java",
      "status": "added",
      "changes": 148,
      "additions": 148,
      "deletions": 0
    },
    {
      "id": 1834,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java",
      "patch": "@@ -15,6 +15,7 @@\n import org.elasticsearch.xpack.aggregatemetric.AggregateMetricMapperPlugin;\n import org.elasticsearch.xpack.aggregatemetric.mapper.datageneration.AggregateMetricDoubleDataSourceHandler;\n \n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashMap;\n@@ -33,6 +34,11 @@ public DataSourceResponse.ObjectArrayGenerator handle(DataSourceRequest.ObjectAr\n         }), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for aggregate_metric_double.\n+    }\n+\n     @Override\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\n         if (value instanceof Map<?, ?> map) {",
      "filename": "x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java",
      "status": "modified",
      "changes": 6,
      "additions": 6,
      "deletions": 0
    },
    {
      "id": 1835,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java",
      "patch": "@@ -13,6 +13,7 @@\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.xpack.constantkeyword.ConstantKeywordMapperPlugin;\n \n+import java.io.IOException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n@@ -22,6 +23,11 @@ public ConstantKeywordFieldBlockLoaderTests(Params params) {\n         super(FieldType.CONSTANT_KEYWORD.toString(), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for constant_keyword.\n+    }\n+\n     @Override\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {\n         return new BytesRef((String) fieldMapping.get(\"value\"));",
      "filename": "x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java",
      "status": "modified",
      "changes": 6,
      "additions": 6,
      "deletions": 0
    },
    {
      "id": 1836,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java",
      "patch": "@@ -379,7 +379,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             if (hasDocValues() && (blContext.fieldExtractPreference() != FieldExtractPreference.STORED || isSyntheticSource)) {\n                 return new BlockDocValuesReader.LongsBlockLoader(name());\n             }\n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return new FallbackSyntheticSourceBlockLoader(fallbackSyntheticSourceBlockLoaderReader(), name()) {\n                     @Override\n                     public Builder builder(BlockFactory factory, int expectedCount) {",
      "filename": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1837,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java",
      "patch": "@@ -313,7 +313,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n             if (blContext.fieldExtractPreference() == FieldExtractPreference.EXTRACT_SPATIAL_BOUNDS) {\n                 return new GeoBoundsBlockLoader(name());\n             }\n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n ",
      "filename": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1838,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java",
      "patch": "@@ -201,7 +201,8 @@ public BlockLoader blockLoader(BlockLoaderContext blContext) {\n                 return new CartesianBoundsBlockLoader(name());\n             }\n \n-            if (isSyntheticSource) {\n+            // Multi fields don't have fallback synthetic source.\n+            if (isSyntheticSource && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n ",
      "filename": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java",
      "status": "modified",
      "changes": 3,
      "additions": 2,
      "deletions": 1
    },
    {
      "id": 1839,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java",
      "patch": "@@ -24,6 +24,7 @@\n import org.elasticsearch.xpack.spatial.LocalStateSpatialPlugin;\n import org.elasticsearch.xpack.spatial.datageneration.GeoShapeDataSourceHandler;\n \n+import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.Collection;\n import java.util.Collections;\n@@ -36,6 +37,11 @@ public GeoShapeFieldBlockLoaderTests(Params params) {\n         super(\"geo_shape\", List.of(new GeoShapeDataSourceHandler()), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for geo_shape.\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {",
      "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java",
      "status": "modified",
      "changes": 6,
      "additions": 6,
      "deletions": 0
    },
    {
      "id": 1840,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java",
      "patch": "@@ -19,6 +19,7 @@\n import org.elasticsearch.xpack.spatial.common.CartesianPoint;\n import org.elasticsearch.xpack.spatial.datageneration.PointDataSourceHandler;\n \n+import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -32,6 +33,11 @@ public PointFieldBlockLoaderTests(Params params) {\n         super(\"point\", List.of(new PointDataSourceHandler()), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for point.\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {",
      "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java",
      "status": "modified",
      "changes": 6,
      "additions": 6,
      "deletions": 0
    },
    {
      "id": 1842,
      "pr_id": 2487052561,
      "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java",
      "patch": "@@ -22,6 +22,7 @@\n import org.elasticsearch.xpack.spatial.LocalStateSpatialPlugin;\n import org.elasticsearch.xpack.spatial.datageneration.ShapeDataSourceHandler;\n \n+import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.Collection;\n import java.util.Collections;\n@@ -34,6 +35,11 @@ public ShapeFieldBlockLoaderTests(Params params) {\n         super(\"shape\", List.of(new ShapeDataSourceHandler()), params);\n     }\n \n+    @Override\n+    public void testBlockLoaderOfMultiField() throws IOException {\n+        // Multi fields are noop for shape.\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     protected Object expected(Map<String, Object> fieldMapping, Object value, TestContext testContext) {",
      "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java",
      "status": "modified",
      "changes": 6,
      "additions": 6,
      "deletions": 0
    }
  ],
  "ai_reviews": [
    {
      "id": 8,
      "pr_id": 2487052561,
      "summary": "This PR aims to enhance the testing coverage for block loaders associated with multifields in the Elasticsearch codebase. The changes span 22 files, primarily focusing on various field mappers, including `ScaledFloatFieldMapper`, `BooleanFieldMapper`, `DateFieldMapper`, `GeoPointFieldMapper`, and `IpFieldMapper`. \n\nSignificant modifications include the addition of test cases that validate the functionality and reliability of these mappers when handling multifields. For instance, the `GeoPointFieldMapper` has seen the most extensive changes, with 9 additions and 3 deletions, indicating a substantial update to its testing logic.\n\nWhile the addition of tests is a positive step towards improving code quality and ensuring robustness, potential concerns include the need for thorough review of the new test cases to ensure they cover edge cases and do not introduce regressions. Additionally, it would be beneficial to assess the performance impact of these tests, especially if they are extensive or complex.\n\nOverall, this PR is a constructive contribution to the project, enhancing the reliability of multifield handling in Elasticsearch, but careful consideration should be given to the quality and coverage of the new tests.",
      "full_review": "# AI Review \ud83e\udd16\n\n## Summary\nThis PR aims to enhance the testing coverage for block loaders associated with multifields in the Elasticsearch codebase. The changes span 22 files, primarily focusing on various field mappers, including `ScaledFloatFieldMapper`, `BooleanFieldMapper`, `DateFieldMapper`, `GeoPointFieldMapper`, and `IpFieldMapper`. \n\nSignificant modifications include the addition of test cases that validate the functionality and reliability of these mappers when handling multifields. For instance, the `GeoPointFieldMapper` has seen the most extensive changes, with 9 additions and 3 deletions, indicating a substantial update to its testing logic.\n\nWhile the addition of tests is a positive step towards improving code quality and ensuring robustness, potential concerns include the need for thorough review of the new test cases to ensure they cover edge cases and do not introduce regressions. Additionally, it would be beneficial to assess the performance impact of these tests, especially if they are extensive or complex.\n\nOverall, this PR is a constructive contribution to the project, enhancing the reliability of multifield handling in Elasticsearch, but careful consideration should be given to the quality and coverage of the new tests.\n\n## Detailed Review\n\n### modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java\nOverall, the code diff appears to be a logical modification aimed at improving the handling of synthetic sources in the `ScaledFloatFieldMapper` class. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 378: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition to prevent fallback synthetic sources for multi-fields. However, ensure that `blContext.parentField(name())` correctly identifies multi-fields in all scenarios. If there are edge cases where this might not behave as expected, it could lead to unintended behavior.\n\n2. **Performance Issues**:\n   - There are no immediate performance issues in the diff. The added condition is a safeguard that should not introduce any significant overhead.\n\n3. **Security Vulnerabilities**:\n   - There are no apparent security vulnerabilities introduced by this change. However, ensure that the `blContext` and its methods are properly validated elsewhere in the codebase to prevent any misuse.\n\n4. **Code Style and Best Practices**:\n   - The comments added before the new condition are helpful for understanding the rationale behind the change. Ensure that similar comments are consistently used throughout the codebase to maintain clarity.\n   - Consider using more descriptive variable names if `blContext` is not immediately clear to all readers. While it's common to use abbreviations, clarity should be prioritized.\n\n5. **Potential Edge Cases**:\n   - Ensure that the logic for `blContext.parentField(name())` is robust against null values or unexpected states. If `parentField` can return null or throw exceptions, it should be handled gracefully.\n   - Consider what happens if `isSyntheticSource` is true but `blContext.parentField(name())` returns an unexpected value. It might be worth adding logging or assertions to catch such cases during development.\n\nIn summary, while the changes made in the diff are logical and improve the handling of synthetic sources, attention should be given to the robustness of the `blContext` checks and ensuring that the code remains clear and maintainable. \n\nOverall, the code looks good with these considerations in mind.\n### server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for the parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 352: The added condition `blContext.parentField(name()) == null` is a good safeguard against multi-fields having a fallback synthetic source. However, ensure that this logic aligns with the intended behavior of the application. If there are cases where a synthetic source should still be allowed even if `parentField` is not null, this could lead to unintended behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 351: The comment `// Multi fields don't have fallback synthetic source.` is helpful for understanding the rationale behind the condition. However, consider expanding it slightly to clarify why this is the case, which could aid future maintainers in understanding the context better.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext` and its method `parentField(name())` are robust against null values or unexpected states. If `blContext` can be null or if `parentField` can throw exceptions, it would be prudent to add null checks or exception handling to prevent runtime errors.\n\n4. **Performance Issues**:\n   - The performance impact of the additional condition is likely negligible, but if `parentField(name())` is an expensive operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive addition, ensure that the logic aligns with the overall design and consider adding more context in comments for clarity.\n### server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for multi fields that do not have a fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 949: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition, but it assumes that `blContext.parentField(name())` will return `null` for all multi fields. Ensure that this assumption holds true in all cases, as it could lead to unexpected behavior if there are edge cases where a parent field exists but is not properly recognized.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the condition is helpful for understanding the rationale behind the change. However, consider rephrasing it for clarity. For example, \"Multi fields do not support fallback synthetic sources.\" This makes it more direct and easier to understand.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext` object is not `null` before calling `blContext.parentField(name())`. If `blContext` can be `null`, this could lead to a `NullPointerException`. Adding a null check would enhance the robustness of the code.\n\n4. **Performance Issues**:\n   - The performance impact of the additional condition is likely negligible, but if `blContext.parentField(name())` is an expensive operation, consider caching the result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive step, it would benefit from additional null checks and a slight rephrasing of the comment for clarity.\n### server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\nOverall, the code diff appears to be well-structured and addresses some improvements in the `GeoPointFieldMapper` class. However, there are a few points worth noting:\n\n1. **Bugs or Logical Errors**:\n   - No apparent bugs or logical errors were identified in the changes made.\n\n2. **Performance Issues**:\n   - The changes do not introduce any performance issues. The addition of the `text()` method in the `GeoHashMultiFieldParser` class is a straightforward enhancement that should not impact performance negatively.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities were identified in the changes. The modifications do not introduce any new security risks.\n\n4. **Code Style and Best Practices**:\n   - The comments have been improved for clarity, which is a good practice. However, consider using a more consistent style for comments. For example, the comment about consumers could be rephrased for better readability:\n     ```java\n     // We rely on the fact that consumers only read text from the parser and never advance tokens.\n     ```\n   - Ensure that all comments are consistently formatted and provide clear context.\n\n5. **Potential Edge Cases**:\n   - The added condition in the `if` statement on line 545 is a good safeguard against potential issues with multi-fields. However, it would be beneficial to document this logic in the comments to clarify why this condition is necessary. This will help future maintainers understand the reasoning behind the check.\n\nIn summary, the changes made in the diff are positive, with improvements in clarity and functionality. Just ensure that comments are consistently formatted and provide adequate context for future maintainers. \n\nOverall, the code looks good. \n\n**LGTM! (Looks Good To Me)**\n### server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java\nOverall Assessment:\nThe code diff introduces a conditional check to ensure that synthetic sources are only used when there is no parent field. This is a reasonable change, but it is important to ensure that the logic is sound and does not introduce any unintended consequences.\n\nSpecific Issues:\n\n1. **Logical Error (Line 8)**:\n   - The condition `isSyntheticSource && blContext.parentField(name()) == null` may lead to unexpected behavior if `blContext.parentField(name())` is not properly validated. Ensure that `parentField` can return null safely and that this condition accurately reflects the intended logic for when to use the fallback synthetic source.\n\n2. **Code Clarity (Line 7-8)**:\n   - The comment `// Multi fields don't have fallback synthetic source.` is helpful, but it could be more descriptive. Consider elaborating on why multi fields do not have a fallback synthetic source and what implications this has for the logic. This will aid future maintainers in understanding the rationale behind the condition.\n\n3. **Performance Consideration**:\n   - If `blContext.parentField(name())` involves a non-trivial computation or lookup, consider caching the result in a local variable before the conditional check to avoid potential performance hits in scenarios where this method is called frequently.\n\n4. **Edge Cases**:\n   - Ensure that there are tests covering scenarios where `isSyntheticSource` is true and `blContext.parentField(name())` returns both null and non-null values. This will help confirm that the new logic behaves as expected across different cases.\n\n5. **Code Style**:\n   - The indentation and spacing are consistent, which is good. However, consider following a consistent commenting style throughout the codebase. If other comments use full sentences, it might be beneficial to do the same here for uniformity.\n\nIn summary, while the change appears to be a logical improvement, it is essential to validate the assumptions made in the new condition and ensure that the code is well-documented and tested.\n### server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for a parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 8: The comment states that \"Multi fields don't have fallback synthetic source.\" This could be misleading if not properly documented elsewhere. Ensure that the behavior of multi-fields is clearly defined in the documentation to avoid confusion for future maintainers.\n\n2. **Code Style and Best Practices**:\n   - Line 7: The comment could be more descriptive. Instead of just stating the fact, it could explain why this condition is necessary. For example, \"Check for parent field to prevent fallback synthetic source loading for multi-fields.\"\n\n3. **Potential Edge Cases**:\n   - Line 8: Consider what happens if `blContext.parentField(name())` returns an unexpected value (e.g., a non-null but invalid parent field). It might be beneficial to add additional checks or logging to handle such cases gracefully.\n\n4. **Performance Issues**:\n   - There are no immediate performance issues in this diff, but ensure that the `parentField` method is efficient, as it will be called in this conditional check. If it involves complex logic or database calls, it could impact performance.\n\nIn summary, while the change is a step in the right direction, enhancing the comments and considering edge cases would improve the clarity and robustness of the code.\n### server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java\nOverall, the code diff appears to be a logical improvement by adding a condition to check for multi-fields that do not have a fallback synthetic source. However, there are a few points to consider:\n\n1. **Logical Errors**:\n   - Line 1974: The added condition checks if `blContext.parentField(name())` is `null` to determine if the synthetic source should be used. Ensure that this logic aligns with the intended behavior of the application. If `parentField` can return a non-null value for valid multi-fields, this could lead to unexpected behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 1974: The comment added before the condition is helpful, but it could be more descriptive. Consider explaining why multi-fields do not have a fallback synthetic source, which would provide better context for future maintainers.\n\n3. **Potential Edge Cases**:\n   - The check for `isSyntheticSource` and `blContext.parentField(name()) == null` should be thoroughly tested to ensure that it covers all edge cases, especially in scenarios where the context might not be straightforward. For example, consider what happens if `blContext` is in an unexpected state or if `name()` returns an unexpected value.\n\n4. **Performance Issues**:\n   - There are no apparent performance issues introduced by this change. However, if `blContext.parentField(name())` is a costly operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change seems to improve the logic regarding synthetic sources, ensure that the new condition is thoroughly tested and consider enhancing the comment for clarity.\n### server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\nOverall, the code diff appears to be well-structured and introduces a new parameter to several methods to handle multifield adjustments for `GeoPoint` objects. However, there are a few areas that could be improved or warrant further consideration.\n\n### Specific Issues:\n\n1. **Line 35-36**: The switch statement for `nullValue` handling is clear, but the error message in the default case could be more descriptive. Instead of \"Unexpected null_value format\", consider specifying what formats are expected.\n\n2. **Line 67-68**: The method `exactValuesFromSource` is called multiple times with the same parameters. If the logic for `needsMultifieldAdjustment` is consistent across these calls, consider refactoring to avoid redundancy. This could improve maintainability.\n\n3. **Line 94**: The `toWKB(normalize(convert(values, nullValue, false)))` call could potentially lead to a performance hit if `convert` returns a large number of values. Consider profiling this section if performance becomes an issue.\n\n4. **Line 180-188**: The `convert` method has multiple return points, which can make it harder to follow. Consider using early returns or restructuring the method to reduce complexity. Additionally, the exception handling could be more specific; catching a general `Exception` can mask other issues.\n\n5. **Line 188-189**: The `possiblyAdjustMultifieldValue` method is a good addition, but ensure that the logic for resetting from a geohash is well-tested. If the geohash representation is malformed, it could lead to unexpected behavior.\n\n6. **Line 188**: The comment about the multifield adjustment not applying to block loader from source is helpful, but it could be clearer. Consider explaining why this distinction is important for future maintainers.\n\n7. **Line 188-189**: The method `resetFromString` should be reviewed to ensure it handles edge cases, such as invalid geohash strings. If it does not, it could lead to runtime exceptions.\n\n### Performance Considerations:\n- The use of streams and lambda expressions is generally efficient, but if the list of values is large, consider whether parallel streams could improve performance. However, be cautious of thread safety and order of processing.\n\n### Security Vulnerabilities:\n- Ensure that any input to the `GeoPoint` constructor is validated. If the input can be influenced by users, it could lead to injection vulnerabilities or unexpected behavior.\n\n### Code Style and Best Practices:\n- The code follows Java conventions well, but consider adding JavaDoc comments for public methods to improve documentation and maintainability.\n- Consistent use of whitespace and indentation is observed, which is good for readability.\n\n### Potential Edge Cases:\n- Consider what happens if `nullValue` is `null` and `value` is also `null`. The current logic seems to handle this, but ensure that all paths are tested.\n- Ensure that the handling of `List<Object>` in the `convert` method is robust against unexpected types within the list.\n\nIn summary, while the changes are generally positive and enhance the functionality, attention to detail in error handling, performance, and documentation will improve the overall quality of the code.\n### server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java\nOverall, the code diff shows a significant refactor of the `TextFieldWithParentBlockLoaderTests` class, transitioning from extending `BlockLoaderTestCase` to `MapperServiceTestCase`. The changes appear to enhance the test's structure and clarity, but there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 9-10**: The import statements for `DefaultMappingParametersHandler` have been removed. If this class is no longer used, it's fine, but ensure that any functionality it provided is adequately replaced or refactored.\n\n2. **Line 51-52**: The comment about \"This is a bit tricky meta-logic\" could be more descriptive. Consider explaining why this logic is necessary for future maintainers.\n\n3. **Line 66**: The method `expected` is now private. If this method is intended to be used only within this class, this is appropriate. However, if it might be useful for subclasses or other classes, consider changing it back to protected.\n\n4. **Line 70**: The variable `normalizer` is retrieved but not used. If it's not needed, consider removing it to clean up the code.\n\n5. **Line 73**: The method `expectedValue` from `TextFieldBlockLoaderTests` is called with `params` and `testContext`. Ensure that these parameters are indeed necessary and that they are being used correctly in the context of the new test structure.\n\n6. **Line 78**: The method `blockLoaderFieldName` has been removed. If this method was providing necessary functionality, consider whether it should be retained or if its logic has been adequately integrated elsewhere.\n\n### Performance Issues:\n- The use of `Map.of` for creating mappings is efficient for small maps, but if the mappings grow larger or are modified frequently, consider using a mutable map instead to avoid the overhead of creating new instances.\n\n### Security Vulnerabilities:\n- There are no apparent security vulnerabilities in the provided code. However, ensure that any data generated or processed does not expose sensitive information, especially when dealing with document generation.\n\n### Code Style and Best Practices:\n- The code generally follows good practices, but consider adding more comments to explain complex logic, especially in the `testBlockLoaderOfParentField` method.\n- Ensure consistent formatting and indentation throughout the code for better readability.\n\n### Potential Edge Cases:\n- Consider what happens if the `DataSourceRequest` does not return the expected mappings. Adding error handling or assertions could help catch issues early in the test.\n\nIn summary, while the refactor improves the structure of the tests, attention to detail in comments, unused variables, and potential edge cases will enhance maintainability and clarity.\n### test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java\nOverall Assessment: The code diff introduces a new field `dataSource` to the `LeafMappingParametersGenerator` record. While the change appears straightforward, there are a few considerations to address.\n\n1. **Bugs or Logical Errors**:\n   - None identified in the diff itself, but the impact of adding `dataSource` should be reviewed in the context of how `LeafMappingParametersGenerator` is used throughout the codebase.\n\n2. **Performance Issues**:\n   - None identified directly from the diff. However, if `DataSource` is a large object, consider whether it is necessary to hold a reference to it in this record. If it is only needed temporarily, passing it as a parameter to methods might be more efficient.\n\n3. **Security Vulnerabilities**:\n   - Ensure that the `DataSource` object does not expose sensitive information inadvertently. If `DataSource` contains any sensitive data, consider implementing proper access controls or sanitization.\n\n4. **Code Style and Best Practices**:\n   - The addition of the `dataSource` field should be accompanied by appropriate documentation or comments explaining its purpose and usage within the `LeafMappingParametersGenerator`. This will help maintain clarity for future developers.\n   - Ensure that the naming conventions are consistent with the rest of the codebase. The name `dataSource` is clear, but verify that it aligns with existing naming patterns.\n\n5. **Potential Edge Cases**:\n   - Consider what happens if `dataSource` is null. If the `LeafMappingParametersGenerator` is instantiated without a valid `DataSource`, it could lead to `NullPointerExceptions` later in the code. Implement null checks or use `Optional<DataSource>` if appropriate.\n\nIn summary, while the change itself is simple, it is essential to consider the broader implications of adding the `dataSource` field, particularly regarding performance, security, and potential null handling.\n### test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java\nOverall, the code diff shows a significant refactoring of the `DefaultMappingParametersHandler` class, with a focus on simplifying the mapping parameter generation. The changes appear to improve readability and maintainability by reducing the number of parameters passed around. However, there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 36-38**: The removal of the `map` variable initialization and the conditional addition of the `SYNTHETIC_SOURCE_KEEP_PARAM` could lead to unintended behavior if this parameter is necessary for certain mappings. Ensure that this parameter is not required for the functionality of the mappings.\n\n2. **Line 70-72**: The `numberMapping` method now directly uses `commonMappingParameters()` to create a new mapping each time. If `commonMappingParameters()` is expensive to compute, this could lead to performance issues, especially if `numberMapping` is called frequently. Consider caching the result if the parameters do not change.\n\n3. **Line 92-94**: Similar to the previous point, the `keywordMapping` method creates a new mapping each time it is called. If `commonMappingParameters()` is costly, this could lead to performance degradation. Again, consider caching or reusing the mapping if possible.\n\n4. **Line 169-171**: The `booleanMapping` method also creates a new mapping each time. The same performance concern applies here. \n\n5. **Line 100-102**: The comment regarding `copy_to` is informative, but it might be beneficial to add a brief explanation of why this is important for maintainability or performance, especially for future developers who may not be familiar with the implications of copying numeric fields.\n\n6. **Line 77-79**: The `null_value` assignment in `numberMapping` and other similar methods should be reviewed to ensure that the values being assigned are valid for the expected data types. Consider adding validation to ensure that the generated values conform to the expected types.\n\n7. **Line 100-102**: The use of `ESTestCase.randomFrom` and similar methods for generating random values should be documented to clarify their purpose and ensure that they are used correctly. This is especially important for maintainability and understanding the randomness in the generated mappings.\n\n### Conclusion:\nWhile the refactoring improves the structure of the code, attention should be paid to performance implications and the necessity of certain parameters. Additionally, ensuring that the generated mappings are valid and well-documented will help maintain the code's integrity. \n\nConsider addressing the above points to enhance the robustness and performance of the code.\n### test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java\nOverall Assessment: The code diff shows a minor modification where an additional parameter is passed to the `LeafMappingParametersGenerator` constructor. While the change appears straightforward, it's essential to ensure that this modification does not introduce any unintended side effects or issues.\n\n1. **Bugs or Logical Errors**:\n   - **Line 105**: The addition of `specification.dataSource()` as a parameter should be verified to ensure that it is the correct data source intended for the `LeafMappingParametersGenerator`. If the previous implementation relied on a different data source, this could lead to logical errors in mapping generation.\n\n2. **Performance Issues**:\n   - No immediate performance issues are evident from this change. However, if `specification.dataSource()` involves heavy computation or resource allocation, consider caching the result if it is used multiple times in the method.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities are apparent in this diff. However, ensure that the `dataSource()` method does not expose sensitive information or allow for injection attacks, especially if it interacts with external data sources.\n\n4. **Code Style and Best Practices**:\n   - The code style appears consistent with Java conventions. However, consider adding comments to clarify why `specification.dataSource()` is being passed to the `LeafMappingParametersGenerator`, especially if this is a change in behavior.\n\n5. **Potential Edge Cases**:\n   - Ensure that `specification.dataSource()` does not return null or an invalid state that could lead to a `NullPointerException` or other runtime exceptions when passed to the `LeafMappingParametersGenerator`. Adding null checks or assertions could help mitigate this risk.\n\nIn summary, while the change seems minor, it is crucial to validate the correctness of the data source being passed and to consider potential edge cases that could arise from this modification.\n### test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java\nOverall, the code diff shows a significant refactor of the `BlockLoaderTestCase` class, with a focus on improving the handling of data source handlers and the generation of mappings and documents. The changes appear to enhance the structure and readability of the code. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Unused Imports**:\n   - Lines 3-7: The imports for `DirectoryReader`, `LeafReaderContext`, `Directory`, `RandomIndexWriter`, and `Mapping` are removed, which is good for cleanliness. Ensure that no other parts of the code rely on these imports.\n\n2. **Redundant Variable Initialization**:\n   - Lines 48-49: The `customDataSourceHandlers` and `runner` are initialized in the constructor, which is fine, but ensure that `runner` is always used. If it is not used in all scenarios, consider lazy initialization or checking if it can be removed.\n\n3. **Potential Null Pointer Exception**:\n   - Lines 114-115: The `mapping.lookup().get(fieldName)` and `getFieldValue(document, fieldName)` could potentially return null. If either of these methods can return null, it may lead to a `NullPointerException` when passed to the `expected` method. Consider adding null checks or handling these cases appropriately.\n\n4. **Test Context Initialization**:\n   - Lines 140-141: The `TestContext` is initialized with `false` for `isMultifield` in multiple places. Ensure that this is the intended behavior and that the context is correctly set for all test cases. If `isMultifield` is relevant for the tests, consider making it more explicit in the test names or comments.\n\n5. **Code Duplication**:\n   - The code for generating `mapping` and `document` is repeated in both `testBlockLoader` and `testBlockLoaderForFieldInObject`. Consider extracting this logic into a private method to reduce duplication and improve maintainability.\n\n6. **Comment Clarity**:\n   - The comment in `testBlockLoaderOfMultiField` could be clearer. It mentions \"parent field and a multi field of the same type,\" but it might be beneficial to explain why this is necessary for the test. Clearer comments can help future maintainers understand the intent behind the tests.\n\n7. **Edge Cases**:\n   - Ensure that edge cases are covered in the tests, such as what happens if the `template` is empty or if the `customDataSourceHandlers` list is empty. Adding tests for these scenarios can help ensure robustness.\n\n### Conclusion:\nThe refactor improves the structure and readability of the code, but attention should be paid to potential null pointer exceptions, code duplication, and ensuring that edge cases are adequately tested. Addressing these points will enhance the reliability and maintainability of the code.\n\nOverall, the changes are promising, but a few adjustments are recommended.\n### test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java\nOverall, the code appears to be well-structured and follows good practices for unit testing in Java, particularly in the context of Elasticsearch. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Error Handling (Line 66)**:\n   - The method `setupAndInvokeBlockLoader` does not handle potential exceptions that could arise from `iw.addDocument(doc);`. If an exception occurs here, it will propagate up, which may not be the desired behavior. Consider adding error handling or logging to provide more context in case of failure.\n\n2. **Resource Management (Lines 66-67)**:\n   - The `RandomIndexWriter` is created but not explicitly closed in a `finally` block. While it is closed in the `try-with-resources` statement, it is good practice to ensure that resources are managed properly, especially in case of exceptions. Consider using a `try-with-resources` for `RandomIndexWriter` as well.\n\n3. **Potential Null Pointer Exception (Line 113)**:\n   - The method `load` assumes that `columnAtATimeReader` will not be null after the call to `blockLoader.columnAtATimeReader(context)`. If it is null, the subsequent call to `columnAtATimeReader.read(...)` will throw a `NullPointerException`. It would be prudent to add a null check and handle this case appropriately.\n\n4. **Performance Considerations (Line 113)**:\n   - The method `load` creates a new `BlockLoaderStoredFieldsFromLeafLoader` every time it is called. If this method is called frequently, it could lead to performance issues. Consider caching or reusing instances where possible.\n\n5. **Code Style (Line 45)**:\n   - The use of `var` is acceptable in Java 10 and above, but it is generally recommended to use explicit types for better readability, especially in public APIs or complex expressions. Consider replacing `var` with explicit types for clarity.\n\n6. **Documentation**:\n   - The class and methods lack JavaDoc comments. Adding documentation would improve maintainability and help other developers understand the purpose and usage of the class and its methods.\n\n7. **Edge Cases**:\n   - The method `runTest` does not handle cases where the `document` map is empty or null. It would be beneficial to validate the input and handle such cases gracefully.\n\n### Conclusion:\nWhile the code is generally well-structured, addressing the above points will enhance its robustness, maintainability, and performance. Consider implementing these suggestions to improve the overall quality of the code.\n### x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java\nOverall, the code diff appears to be a straightforward addition of a test method that indicates a no-operation (noop) for multi-fields in the `AggregateMetricDoubleFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Test Method Implementation**:\n   - **Line 36**: The newly added test method `testBlockLoaderOfMultiField` is currently empty except for a comment. While it is acceptable to have a placeholder for future implementation, it is generally better to either implement a meaningful test or remove the method until it can be properly defined. This helps maintain clarity in the test suite.\n\n2. **Comment Clarity**:\n   - **Line 37**: The comment `// Multi fields are noop for aggregate_metric_double.` could be expanded to provide more context. For example, explaining why multi-fields are no-ops in this context could be beneficial for future maintainers or reviewers.\n\n3. **Exception Handling**:\n   - **Line 36**: The method signature includes `throws IOException`, which is appropriate if the method is expected to handle I/O operations in the future. However, if the method remains a noop, consider whether this exception is necessary. If no I/O operations are performed, it might be better to remove it.\n\n4. **Code Style**:\n   - The code style appears consistent with Java conventions. However, ensure that the rest of the test class follows the same style for consistency.\n\n5. **Potential Edge Cases**:\n   - Since the method is currently a noop, consider adding a comment or a TODO note to remind future developers to think about edge cases related to multi-fields when they implement the test. This could include scenarios where multi-fields might inadvertently affect the behavior of the `AggregateMetricDouble` functionality.\n\nIn summary, while the addition is simple and does not introduce any bugs or performance issues, it could benefit from further elaboration and consideration of future implementation. \n\n**Actionable Feedback**:\n- Consider implementing a meaningful test or removing the method until it can be defined.\n- Expand the comment for clarity.\n- Review the necessity of the `throws IOException` declaration.\n\nOverall, the code is on the right track but could use some refinement.\n### x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java\nOverall, the code diff looks good and appears to be a straightforward addition of a method to handle multi-fields in the `ConstantKeywordFieldBlockLoaderTests` class. However, there are a few points worth mentioning:\n\n1. **Method Implementation**:\n   - **Line 25**: The `testBlockLoaderOfMultiField` method is currently a placeholder with a comment indicating that multi-fields are a no-op for `constant_keyword`. While this is acceptable for a test method, it would be beneficial to include an assertion or a log statement to explicitly indicate that this test is being skipped or is intentionally empty. This can help future maintainers understand the intent without needing to infer it from the comment.\n\n2. **Code Style**:\n   - **Line 23**: The method name `testBlockLoaderOfMultiField` could be more descriptive. Consider renaming it to something like `testMultiFieldNoOp` to clearly convey that this test is verifying that multi-fields do not have any effect.\n\n3. **Documentation**:\n   - It might be helpful to add a Javadoc comment above the `testBlockLoaderOfMultiField` method to explain why this test is a no-op and what the expected behavior is. This can improve code readability and maintainability.\n\n4. **Edge Cases**:\n   - While the current implementation is correct, consider whether there are any edge cases related to multi-fields that should be tested in the future. For example, if there are specific configurations or scenarios where multi-fields might interact with `constant_keyword`, it would be prudent to document those considerations.\n\nIn summary, while the code is functional, enhancing clarity through better naming, documentation, and possibly adding assertions would improve the overall quality of the test. \n\nOverall, the changes are acceptable, but consider the suggestions for improvement.\n### x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for multi-fields that do not have a fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 380: The condition `blContext.parentField(name()) == null` is added to check for multi-fields. Ensure that this logic correctly identifies when a field is a multi-field and that it does not inadvertently exclude valid cases where a synthetic source should be used.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the new condition is helpful for understanding the rationale behind the change. However, consider rephrasing it for clarity. For example, \"Check for multi-fields that do not have a fallback synthetic source.\" This makes it clearer what the condition is checking for.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `parentField(name())` method behaves as expected in all scenarios. If there are edge cases where this method could return unexpected results (e.g., if the field name is not found), it could lead to incorrect behavior. It might be beneficial to add unit tests to cover these scenarios.\n\n4. **Performance Issues**:\n   - The added condition introduces an additional method call (`blContext.parentField(name())`). If this method is computationally expensive or if it is called frequently in a performance-critical path, consider caching the result if applicable.\n\nIn summary, while the change seems to enhance the functionality by preventing fallback synthetic sources for multi-fields, ensure that the logic is robust and consider potential performance implications.\n### x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java\nOverall Assessment:\nThe code diff introduces a condition to check if the `blContext.parentField(name())` is null before proceeding with the fallback synthetic source. This change appears to be a logical improvement to prevent unnecessary fallback loading for multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 314**: The comment added is helpful for understanding the context of the change. However, it could be more descriptive. Consider rephrasing it to clarify why multi-fields do not have a fallback synthetic source, which would enhance maintainability.\n\n2. **Line 315**: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition, but ensure that `blContext.parentField(name())` is not computationally expensive. If it involves a complex lookup, it could impact performance, especially if this method is called frequently. If performance is a concern, consider caching the result if applicable.\n\n3. **Edge Cases**: Ensure that the logic correctly handles cases where `blContext` might be null or improperly initialized. Although this is likely managed elsewhere, it's good practice to validate assumptions about the state of objects being used.\n\n4. **Testing**: Ensure that there are adequate unit tests covering this new condition. Specifically, tests should verify that the fallback synthetic source is not called for multi-fields and that the behavior is as expected when `blContext.parentField(name())` is null.\n\n5. **Code Style**: The code adheres to standard Java conventions. However, consider adding a brief comment above the method to describe its purpose and the significance of the new condition for future maintainers.\n\nIn summary, while the change is a positive improvement, attention to performance implications, edge cases, and documentation will enhance the robustness of the code.\n### x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java\nOverall Assessment:\nThe code change introduces a condition to check if the `blContext.parentField(name())` is `null` when `isSyntheticSource` is true. This is a reasonable modification to prevent fallback synthetic source loading for multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 202**: The comment added is helpful for understanding the rationale behind the condition. However, it could be more descriptive. Consider explaining what \"multi fields\" are in this context or why they don't have a fallback synthetic source. This would improve maintainability for future developers.\n\n2. **Line 203**: The new condition checks for `blContext.parentField(name()) == null`. Ensure that this method call is efficient and does not introduce performance overhead, especially if it involves complex logic or data retrieval. If `parentField` is a costly operation, consider caching the result if it is called multiple times in the same context.\n\n3. **Edge Cases**: Consider what happens if `blContext` is `null`. Although it may be guaranteed by the surrounding code, adding a null check could prevent potential `NullPointerExceptions` in edge cases.\n\n4. **Testing**: Ensure that there are adequate unit tests covering this new condition. Specifically, tests should verify that the fallback synthetic source is not called for multi-fields and that the logic behaves correctly when `blContext.parentField(name())` returns both `null` and non-null values.\n\n5. **Code Style**: The code adheres to standard Java conventions. However, ensure that the surrounding code maintains consistent formatting, especially regarding indentation and spacing, to enhance readability.\n\nIn summary, while the change is logical and seems to improve the handling of synthetic sources, attention to documentation, performance considerations, edge cases, and testing will enhance the robustness of this modification.\n### x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java\nOverall, the code diff looks good and appears to be a straightforward addition of a method that overrides a test case for multi-fields in the `GeoShapeFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 36-39**: The newly added method `testBlockLoaderOfMultiField()` is currently a placeholder with a comment indicating that multi-fields are no-ops for `geo_shape`. While this is acceptable for a test that is not meant to perform any operations, it would be beneficial to include a more descriptive comment explaining why this is the case. This can help future maintainers understand the rationale behind the no-op.\n\n2. **Code Style**:\n   - **Line 36**: The method name `testBlockLoaderOfMultiField` could be more descriptive. Consider renaming it to something like `testMultiFieldNoOpForGeoShape` to better convey its purpose.\n\n3. **Documentation**:\n   - It might be helpful to add a Javadoc comment for the new method to clarify its intent and any relevant context about the behavior of multi-fields in relation to `geo_shape`.\n\n4. **Test Coverage**:\n   - Ensure that there are other tests that cover scenarios where multi-fields are used with `geo_shape`, even if they are expected to be no-ops. This will help ensure that the behavior is well-documented and verified.\n\n5. **Potential Edge Cases**:\n   - While the current implementation is straightforward, consider if there are any edge cases related to multi-fields that should be documented or tested in the future, even if they are not applicable at this moment.\n\nIn summary, while the code change is simple and functional, enhancing the documentation and naming conventions would improve clarity and maintainability. \n\nOverall, the code looks good with minor suggestions for improvement. \n\n**LGTM! (Looks Good To Me)**\n### x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java\nOverall, the code diff appears to be a straightforward addition of a method that overrides an existing method in the `PointFieldBlockLoaderTests` class. The new method is a placeholder that indicates that multi-fields are a no-op for point types. Here are some specific points to consider:\n\n1. **Bugs or Logical Errors**: \n   - There are no apparent bugs or logical errors in the new method. It correctly overrides the existing method and provides a comment explaining its purpose.\n\n2. **Performance Issues**: \n   - There are no performance issues introduced by this change. The method is a no-op, so it does not add any overhead.\n\n3. **Security Vulnerabilities**: \n   - There are no security vulnerabilities present in this diff. The method does not handle any sensitive data or perform any operations that could introduce security risks.\n\n4. **Code Style and Best Practices**: \n   - The code adheres to standard Java conventions. The comment clearly explains the purpose of the overridden method, which is a good practice for maintainability.\n\n5. **Potential Edge Cases**: \n   - Since the method is a no-op, there are no edge cases to consider in this context. However, it might be beneficial to ensure that any tests that rely on this method are aware of its no-op nature to avoid confusion in the future.\n\nIn summary, the changes made in this diff are clear and appropriate for the context. \n\nLGTM! (Looks Good To Me)\n### x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java\nOverall, the code diff appears to be straightforward, with the addition of a method that overrides a test case for multi-fields in the `ShapeFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 35**: The method `testBlockLoaderOfMultiField()` is currently a placeholder with a comment indicating that multi-fields are a no-op for shape. While this is acceptable for a test case, it would be beneficial to include a more descriptive comment explaining why this is the case. This can help future developers understand the rationale behind this implementation.\n\n2. **Code Style**:\n   - **Line 34-36**: The method could benefit from a JavaDoc comment to describe its purpose, especially since it overrides a method from a superclass. This would improve readability and maintainability.\n\n3. **Test Coverage**:\n   - While the method is marked as a no-op, it might be useful to consider adding a simple assertion or logging statement to confirm that the method is being called during tests. This can help ensure that the test suite is functioning as expected and that the no-op behavior is intentional.\n\n4. **Exception Handling**:\n   - **Line 35**: The method signature declares that it throws `IOException`, but since the method body is empty, it will never actually throw this exception. If the method is intended to remain a no-op, consider removing the `throws IOException` declaration to avoid confusion.\n\n5. **Potential Edge Cases**:\n   - If there are any specific scenarios where multi-fields could potentially lead to issues in the context of shape fields, it might be worth documenting those in the comment or considering how to handle them in the future.\n\nIn summary, while the code is functional, enhancing comments and documentation would improve clarity and maintainability. \n\n### Suggested Changes:\n- Add a JavaDoc comment to `testBlockLoaderOfMultiField()`.\n- Consider removing the `throws IOException` declaration if the method is truly a no-op.\n\nOverall, the changes are minor, and the code is on the right track. \n\n**Final Assessment**: LGTM! (Looks Good To Me) with minor suggestions for improvement.\n\n\n---\n*This review was automatically generated by an AI assistant.*",
      "created_at": "2025-04-29T01:22:26",
      "file_reviews": [
        {
          "id": 68,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical modification aimed at improving the handling of synthetic sources in the `ScaledFloatFieldMapper` class. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 378: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition to prevent fallback synthetic sources for multi-fields. However, ensure that `blContext.parentField(name())` correctly identifies multi-fields in all scenarios. If there are edge cases where this might not behave as expected, it could lead to unintended behavior.\n\n2. **Performance Issues**:\n   - There are no immediate performance issues in the diff. The added condition is a safeguard that should not introduce any significant overhead.\n\n3. **Security Vulnerabilities**:\n   - There are no apparent security vulnerabilities introduced by this change. However, ensure that the `blContext` and its methods are properly validated elsewhere in the codebase to prevent any misuse.\n\n4. **Code Style and Best Practices**:\n   - The comments added before the new condition are helpful for understanding the rationale behind the change. Ensure that similar comments are consistently used throughout the codebase to maintain clarity.\n   - Consider using more descriptive variable names if `blContext` is not immediately clear to all readers. While it's common to use abbreviations, clarity should be prioritized.\n\n5. **Potential Edge Cases**:\n   - Ensure that the logic for `blContext.parentField(name())` is robust against null values or unexpected states. If `parentField` can return null or throw exceptions, it should be handled gracefully.\n   - Consider what happens if `isSyntheticSource` is true but `blContext.parentField(name())` returns an unexpected value. It might be worth adding logging or assertions to catch such cases during development.\n\nIn summary, while the changes made in the diff are logical and improve the handling of synthetic sources, attention should be given to the robustness of the `blContext` checks and ensuring that the code remains clear and maintainable. \n\nOverall, the code looks good with these considerations in mind.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 69,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for the parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 352: The added condition `blContext.parentField(name()) == null` is a good safeguard against multi-fields having a fallback synthetic source. However, ensure that this logic aligns with the intended behavior of the application. If there are cases where a synthetic source should still be allowed even if `parentField` is not null, this could lead to unintended behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 351: The comment `// Multi fields don't have fallback synthetic source.` is helpful for understanding the rationale behind the condition. However, consider expanding it slightly to clarify why this is the case, which could aid future maintainers in understanding the context better.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext` and its method `parentField(name())` are robust against null values or unexpected states. If `blContext` can be null or if `parentField` can throw exceptions, it would be prudent to add null checks or exception handling to prevent runtime errors.\n\n4. **Performance Issues**:\n   - The performance impact of the additional condition is likely negligible, but if `parentField(name())` is an expensive operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive addition, ensure that the logic aligns with the overall design and consider adding more context in comments for clarity.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 70,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for multi fields that do not have a fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 949: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition, but it assumes that `blContext.parentField(name())` will return `null` for all multi fields. Ensure that this assumption holds true in all cases, as it could lead to unexpected behavior if there are edge cases where a parent field exists but is not properly recognized.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the condition is helpful for understanding the rationale behind the change. However, consider rephrasing it for clarity. For example, \"Multi fields do not support fallback synthetic sources.\" This makes it more direct and easier to understand.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext` object is not `null` before calling `blContext.parentField(name())`. If `blContext` can be `null`, this could lead to a `NullPointerException`. Adding a null check would enhance the robustness of the code.\n\n4. **Performance Issues**:\n   - The performance impact of the additional condition is likely negligible, but if `blContext.parentField(name())` is an expensive operation, consider caching the result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive step, it would benefit from additional null checks and a slight rephrasing of the comment for clarity.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 71,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java",
          "content": "Overall, the code diff appears to be well-structured and addresses some improvements in the `GeoPointFieldMapper` class. However, there are a few points worth noting:\n\n1. **Bugs or Logical Errors**:\n   - No apparent bugs or logical errors were identified in the changes made.\n\n2. **Performance Issues**:\n   - The changes do not introduce any performance issues. The addition of the `text()` method in the `GeoHashMultiFieldParser` class is a straightforward enhancement that should not impact performance negatively.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities were identified in the changes. The modifications do not introduce any new security risks.\n\n4. **Code Style and Best Practices**:\n   - The comments have been improved for clarity, which is a good practice. However, consider using a more consistent style for comments. For example, the comment about consumers could be rephrased for better readability:\n     ```java\n     // We rely on the fact that consumers only read text from the parser and never advance tokens.\n     ```\n   - Ensure that all comments are consistently formatted and provide clear context.\n\n5. **Potential Edge Cases**:\n   - The added condition in the `if` statement on line 545 is a good safeguard against potential issues with multi-fields. However, it would be beneficial to document this logic in the comments to clarify why this condition is necessary. This will help future maintainers understand the reasoning behind the check.\n\nIn summary, the changes made in the diff are positive, with improvements in clarity and functionality. Just ensure that comments are consistently formatted and provide adequate context for future maintainers. \n\nOverall, the code looks good. \n\n**LGTM! (Looks Good To Me)**",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 72,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java",
          "content": "Overall Assessment:\nThe code diff introduces a conditional check to ensure that synthetic sources are only used when there is no parent field. This is a reasonable change, but it is important to ensure that the logic is sound and does not introduce any unintended consequences.\n\nSpecific Issues:\n\n1. **Logical Error (Line 8)**:\n   - The condition `isSyntheticSource && blContext.parentField(name()) == null` may lead to unexpected behavior if `blContext.parentField(name())` is not properly validated. Ensure that `parentField` can return null safely and that this condition accurately reflects the intended logic for when to use the fallback synthetic source.\n\n2. **Code Clarity (Line 7-8)**:\n   - The comment `// Multi fields don't have fallback synthetic source.` is helpful, but it could be more descriptive. Consider elaborating on why multi fields do not have a fallback synthetic source and what implications this has for the logic. This will aid future maintainers in understanding the rationale behind the condition.\n\n3. **Performance Consideration**:\n   - If `blContext.parentField(name())` involves a non-trivial computation or lookup, consider caching the result in a local variable before the conditional check to avoid potential performance hits in scenarios where this method is called frequently.\n\n4. **Edge Cases**:\n   - Ensure that there are tests covering scenarios where `isSyntheticSource` is true and `blContext.parentField(name())` returns both null and non-null values. This will help confirm that the new logic behaves as expected across different cases.\n\n5. **Code Style**:\n   - The indentation and spacing are consistent, which is good. However, consider following a consistent commenting style throughout the codebase. If other comments use full sentences, it might be beneficial to do the same here for uniformity.\n\nIn summary, while the change appears to be a logical improvement, it is essential to validate the assumptions made in the new condition and ensure that the code is well-documented and tested.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 73,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for a parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 8: The comment states that \"Multi fields don't have fallback synthetic source.\" This could be misleading if not properly documented elsewhere. Ensure that the behavior of multi-fields is clearly defined in the documentation to avoid confusion for future maintainers.\n\n2. **Code Style and Best Practices**:\n   - Line 7: The comment could be more descriptive. Instead of just stating the fact, it could explain why this condition is necessary. For example, \"Check for parent field to prevent fallback synthetic source loading for multi-fields.\"\n\n3. **Potential Edge Cases**:\n   - Line 8: Consider what happens if `blContext.parentField(name())` returns an unexpected value (e.g., a non-null but invalid parent field). It might be beneficial to add additional checks or logging to handle such cases gracefully.\n\n4. **Performance Issues**:\n   - There are no immediate performance issues in this diff, but ensure that the `parentField` method is efficient, as it will be called in this conditional check. If it involves complex logic or database calls, it could impact performance.\n\nIn summary, while the change is a step in the right direction, enhancing the comments and considering edge cases would improve the clarity and robustness of the code.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 74,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement by adding a condition to check for multi-fields that do not have a fallback synthetic source. However, there are a few points to consider:\n\n1. **Logical Errors**:\n   - Line 1974: The added condition checks if `blContext.parentField(name())` is `null` to determine if the synthetic source should be used. Ensure that this logic aligns with the intended behavior of the application. If `parentField` can return a non-null value for valid multi-fields, this could lead to unexpected behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 1974: The comment added before the condition is helpful, but it could be more descriptive. Consider explaining why multi-fields do not have a fallback synthetic source, which would provide better context for future maintainers.\n\n3. **Potential Edge Cases**:\n   - The check for `isSyntheticSource` and `blContext.parentField(name()) == null` should be thoroughly tested to ensure that it covers all edge cases, especially in scenarios where the context might not be straightforward. For example, consider what happens if `blContext` is in an unexpected state or if `name()` returns an unexpected value.\n\n4. **Performance Issues**:\n   - There are no apparent performance issues introduced by this change. However, if `blContext.parentField(name())` is a costly operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change seems to improve the logic regarding synthetic sources, ensure that the new condition is thoroughly tested and consider enhancing the comment for clarity.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 75,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be well-structured and introduces a new parameter to several methods to handle multifield adjustments for `GeoPoint` objects. However, there are a few areas that could be improved or warrant further consideration.\n\n### Specific Issues:\n\n1. **Line 35-36**: The switch statement for `nullValue` handling is clear, but the error message in the default case could be more descriptive. Instead of \"Unexpected null_value format\", consider specifying what formats are expected.\n\n2. **Line 67-68**: The method `exactValuesFromSource` is called multiple times with the same parameters. If the logic for `needsMultifieldAdjustment` is consistent across these calls, consider refactoring to avoid redundancy. This could improve maintainability.\n\n3. **Line 94**: The `toWKB(normalize(convert(values, nullValue, false)))` call could potentially lead to a performance hit if `convert` returns a large number of values. Consider profiling this section if performance becomes an issue.\n\n4. **Line 180-188**: The `convert` method has multiple return points, which can make it harder to follow. Consider using early returns or restructuring the method to reduce complexity. Additionally, the exception handling could be more specific; catching a general `Exception` can mask other issues.\n\n5. **Line 188-189**: The `possiblyAdjustMultifieldValue` method is a good addition, but ensure that the logic for resetting from a geohash is well-tested. If the geohash representation is malformed, it could lead to unexpected behavior.\n\n6. **Line 188**: The comment about the multifield adjustment not applying to block loader from source is helpful, but it could be clearer. Consider explaining why this distinction is important for future maintainers.\n\n7. **Line 188-189**: The method `resetFromString` should be reviewed to ensure it handles edge cases, such as invalid geohash strings. If it does not, it could lead to runtime exceptions.\n\n### Performance Considerations:\n- The use of streams and lambda expressions is generally efficient, but if the list of values is large, consider whether parallel streams could improve performance. However, be cautious of thread safety and order of processing.\n\n### Security Vulnerabilities:\n- Ensure that any input to the `GeoPoint` constructor is validated. If the input can be influenced by users, it could lead to injection vulnerabilities or unexpected behavior.\n\n### Code Style and Best Practices:\n- The code follows Java conventions well, but consider adding JavaDoc comments for public methods to improve documentation and maintainability.\n- Consistent use of whitespace and indentation is observed, which is good for readability.\n\n### Potential Edge Cases:\n- Consider what happens if `nullValue` is `null` and `value` is also `null`. The current logic seems to handle this, but ensure that all paths are tested.\n- Ensure that the handling of `List<Object>` in the `convert` method is robust against unexpected types within the list.\n\nIn summary, while the changes are generally positive and enhance the functionality, attention to detail in error handling, performance, and documentation will improve the overall quality of the code.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 76,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java",
          "content": "Overall, the code diff shows a significant refactor of the `TextFieldWithParentBlockLoaderTests` class, transitioning from extending `BlockLoaderTestCase` to `MapperServiceTestCase`. The changes appear to enhance the test's structure and clarity, but there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 9-10**: The import statements for `DefaultMappingParametersHandler` have been removed. If this class is no longer used, it's fine, but ensure that any functionality it provided is adequately replaced or refactored.\n\n2. **Line 51-52**: The comment about \"This is a bit tricky meta-logic\" could be more descriptive. Consider explaining why this logic is necessary for future maintainers.\n\n3. **Line 66**: The method `expected` is now private. If this method is intended to be used only within this class, this is appropriate. However, if it might be useful for subclasses or other classes, consider changing it back to protected.\n\n4. **Line 70**: The variable `normalizer` is retrieved but not used. If it's not needed, consider removing it to clean up the code.\n\n5. **Line 73**: The method `expectedValue` from `TextFieldBlockLoaderTests` is called with `params` and `testContext`. Ensure that these parameters are indeed necessary and that they are being used correctly in the context of the new test structure.\n\n6. **Line 78**: The method `blockLoaderFieldName` has been removed. If this method was providing necessary functionality, consider whether it should be retained or if its logic has been adequately integrated elsewhere.\n\n### Performance Issues:\n- The use of `Map.of` for creating mappings is efficient for small maps, but if the mappings grow larger or are modified frequently, consider using a mutable map instead to avoid the overhead of creating new instances.\n\n### Security Vulnerabilities:\n- There are no apparent security vulnerabilities in the provided code. However, ensure that any data generated or processed does not expose sensitive information, especially when dealing with document generation.\n\n### Code Style and Best Practices:\n- The code generally follows good practices, but consider adding more comments to explain complex logic, especially in the `testBlockLoaderOfParentField` method.\n- Ensure consistent formatting and indentation throughout the code for better readability.\n\n### Potential Edge Cases:\n- Consider what happens if the `DataSourceRequest` does not return the expected mappings. Adding error handling or assertions could help catch issues early in the test.\n\nIn summary, while the refactor improves the structure of the tests, attention to detail in comments, unused variables, and potential edge cases will enhance maintainability and clarity.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 77,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java",
          "content": "Overall Assessment: The code diff introduces a new field `dataSource` to the `LeafMappingParametersGenerator` record. While the change appears straightforward, there are a few considerations to address.\n\n1. **Bugs or Logical Errors**:\n   - None identified in the diff itself, but the impact of adding `dataSource` should be reviewed in the context of how `LeafMappingParametersGenerator` is used throughout the codebase.\n\n2. **Performance Issues**:\n   - None identified directly from the diff. However, if `DataSource` is a large object, consider whether it is necessary to hold a reference to it in this record. If it is only needed temporarily, passing it as a parameter to methods might be more efficient.\n\n3. **Security Vulnerabilities**:\n   - Ensure that the `DataSource` object does not expose sensitive information inadvertently. If `DataSource` contains any sensitive data, consider implementing proper access controls or sanitization.\n\n4. **Code Style and Best Practices**:\n   - The addition of the `dataSource` field should be accompanied by appropriate documentation or comments explaining its purpose and usage within the `LeafMappingParametersGenerator`. This will help maintain clarity for future developers.\n   - Ensure that the naming conventions are consistent with the rest of the codebase. The name `dataSource` is clear, but verify that it aligns with existing naming patterns.\n\n5. **Potential Edge Cases**:\n   - Consider what happens if `dataSource` is null. If the `LeafMappingParametersGenerator` is instantiated without a valid `DataSource`, it could lead to `NullPointerExceptions` later in the code. Implement null checks or use `Optional<DataSource>` if appropriate.\n\nIn summary, while the change itself is simple, it is essential to consider the broader implications of adding the `dataSource` field, particularly regarding performance, security, and potential null handling.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 78,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java",
          "content": "Overall, the code diff shows a significant refactoring of the `DefaultMappingParametersHandler` class, with a focus on simplifying the mapping parameter generation. The changes appear to improve readability and maintainability by reducing the number of parameters passed around. However, there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 36-38**: The removal of the `map` variable initialization and the conditional addition of the `SYNTHETIC_SOURCE_KEEP_PARAM` could lead to unintended behavior if this parameter is necessary for certain mappings. Ensure that this parameter is not required for the functionality of the mappings.\n\n2. **Line 70-72**: The `numberMapping` method now directly uses `commonMappingParameters()` to create a new mapping each time. If `commonMappingParameters()` is expensive to compute, this could lead to performance issues, especially if `numberMapping` is called frequently. Consider caching the result if the parameters do not change.\n\n3. **Line 92-94**: Similar to the previous point, the `keywordMapping` method creates a new mapping each time it is called. If `commonMappingParameters()` is costly, this could lead to performance degradation. Again, consider caching or reusing the mapping if possible.\n\n4. **Line 169-171**: The `booleanMapping` method also creates a new mapping each time. The same performance concern applies here. \n\n5. **Line 100-102**: The comment regarding `copy_to` is informative, but it might be beneficial to add a brief explanation of why this is important for maintainability or performance, especially for future developers who may not be familiar with the implications of copying numeric fields.\n\n6. **Line 77-79**: The `null_value` assignment in `numberMapping` and other similar methods should be reviewed to ensure that the values being assigned are valid for the expected data types. Consider adding validation to ensure that the generated values conform to the expected types.\n\n7. **Line 100-102**: The use of `ESTestCase.randomFrom` and similar methods for generating random values should be documented to clarify their purpose and ensure that they are used correctly. This is especially important for maintainability and understanding the randomness in the generated mappings.\n\n### Conclusion:\nWhile the refactoring improves the structure of the code, attention should be paid to performance implications and the necessity of certain parameters. Additionally, ensuring that the generated mappings are valid and well-documented will help maintain the code's integrity. \n\nConsider addressing the above points to enhance the robustness and performance of the code.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 79,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java",
          "content": "Overall Assessment: The code diff shows a minor modification where an additional parameter is passed to the `LeafMappingParametersGenerator` constructor. While the change appears straightforward, it's essential to ensure that this modification does not introduce any unintended side effects or issues.\n\n1. **Bugs or Logical Errors**:\n   - **Line 105**: The addition of `specification.dataSource()` as a parameter should be verified to ensure that it is the correct data source intended for the `LeafMappingParametersGenerator`. If the previous implementation relied on a different data source, this could lead to logical errors in mapping generation.\n\n2. **Performance Issues**:\n   - No immediate performance issues are evident from this change. However, if `specification.dataSource()` involves heavy computation or resource allocation, consider caching the result if it is used multiple times in the method.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities are apparent in this diff. However, ensure that the `dataSource()` method does not expose sensitive information or allow for injection attacks, especially if it interacts with external data sources.\n\n4. **Code Style and Best Practices**:\n   - The code style appears consistent with Java conventions. However, consider adding comments to clarify why `specification.dataSource()` is being passed to the `LeafMappingParametersGenerator`, especially if this is a change in behavior.\n\n5. **Potential Edge Cases**:\n   - Ensure that `specification.dataSource()` does not return null or an invalid state that could lead to a `NullPointerException` or other runtime exceptions when passed to the `LeafMappingParametersGenerator`. Adding null checks or assertions could help mitigate this risk.\n\nIn summary, while the change seems minor, it is crucial to validate the correctness of the data source being passed and to consider potential edge cases that could arise from this modification.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 80,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java",
          "content": "Overall, the code diff shows a significant refactor of the `BlockLoaderTestCase` class, with a focus on improving the handling of data source handlers and the generation of mappings and documents. The changes appear to enhance the structure and readability of the code. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Unused Imports**:\n   - Lines 3-7: The imports for `DirectoryReader`, `LeafReaderContext`, `Directory`, `RandomIndexWriter`, and `Mapping` are removed, which is good for cleanliness. Ensure that no other parts of the code rely on these imports.\n\n2. **Redundant Variable Initialization**:\n   - Lines 48-49: The `customDataSourceHandlers` and `runner` are initialized in the constructor, which is fine, but ensure that `runner` is always used. If it is not used in all scenarios, consider lazy initialization or checking if it can be removed.\n\n3. **Potential Null Pointer Exception**:\n   - Lines 114-115: The `mapping.lookup().get(fieldName)` and `getFieldValue(document, fieldName)` could potentially return null. If either of these methods can return null, it may lead to a `NullPointerException` when passed to the `expected` method. Consider adding null checks or handling these cases appropriately.\n\n4. **Test Context Initialization**:\n   - Lines 140-141: The `TestContext` is initialized with `false` for `isMultifield` in multiple places. Ensure that this is the intended behavior and that the context is correctly set for all test cases. If `isMultifield` is relevant for the tests, consider making it more explicit in the test names or comments.\n\n5. **Code Duplication**:\n   - The code for generating `mapping` and `document` is repeated in both `testBlockLoader` and `testBlockLoaderForFieldInObject`. Consider extracting this logic into a private method to reduce duplication and improve maintainability.\n\n6. **Comment Clarity**:\n   - The comment in `testBlockLoaderOfMultiField` could be clearer. It mentions \"parent field and a multi field of the same type,\" but it might be beneficial to explain why this is necessary for the test. Clearer comments can help future maintainers understand the intent behind the tests.\n\n7. **Edge Cases**:\n   - Ensure that edge cases are covered in the tests, such as what happens if the `template` is empty or if the `customDataSourceHandlers` list is empty. Adding tests for these scenarios can help ensure robustness.\n\n### Conclusion:\nThe refactor improves the structure and readability of the code, but attention should be paid to potential null pointer exceptions, code duplication, and ensuring that edge cases are adequately tested. Addressing these points will enhance the reliability and maintainability of the code.\n\nOverall, the changes are promising, but a few adjustments are recommended.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 81,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java",
          "content": "Overall, the code appears to be well-structured and follows good practices for unit testing in Java, particularly in the context of Elasticsearch. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Error Handling (Line 66)**:\n   - The method `setupAndInvokeBlockLoader` does not handle potential exceptions that could arise from `iw.addDocument(doc);`. If an exception occurs here, it will propagate up, which may not be the desired behavior. Consider adding error handling or logging to provide more context in case of failure.\n\n2. **Resource Management (Lines 66-67)**:\n   - The `RandomIndexWriter` is created but not explicitly closed in a `finally` block. While it is closed in the `try-with-resources` statement, it is good practice to ensure that resources are managed properly, especially in case of exceptions. Consider using a `try-with-resources` for `RandomIndexWriter` as well.\n\n3. **Potential Null Pointer Exception (Line 113)**:\n   - The method `load` assumes that `columnAtATimeReader` will not be null after the call to `blockLoader.columnAtATimeReader(context)`. If it is null, the subsequent call to `columnAtATimeReader.read(...)` will throw a `NullPointerException`. It would be prudent to add a null check and handle this case appropriately.\n\n4. **Performance Considerations (Line 113)**:\n   - The method `load` creates a new `BlockLoaderStoredFieldsFromLeafLoader` every time it is called. If this method is called frequently, it could lead to performance issues. Consider caching or reusing instances where possible.\n\n5. **Code Style (Line 45)**:\n   - The use of `var` is acceptable in Java 10 and above, but it is generally recommended to use explicit types for better readability, especially in public APIs or complex expressions. Consider replacing `var` with explicit types for clarity.\n\n6. **Documentation**:\n   - The class and methods lack JavaDoc comments. Adding documentation would improve maintainability and help other developers understand the purpose and usage of the class and its methods.\n\n7. **Edge Cases**:\n   - The method `runTest` does not handle cases where the `document` map is empty or null. It would be beneficial to validate the input and handle such cases gracefully.\n\n### Conclusion:\nWhile the code is generally well-structured, addressing the above points will enhance its robustness, maintainability, and performance. Consider implementing these suggestions to improve the overall quality of the code.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 82,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be a straightforward addition of a test method that indicates a no-operation (noop) for multi-fields in the `AggregateMetricDoubleFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Test Method Implementation**:\n   - **Line 36**: The newly added test method `testBlockLoaderOfMultiField` is currently empty except for a comment. While it is acceptable to have a placeholder for future implementation, it is generally better to either implement a meaningful test or remove the method until it can be properly defined. This helps maintain clarity in the test suite.\n\n2. **Comment Clarity**:\n   - **Line 37**: The comment `// Multi fields are noop for aggregate_metric_double.` could be expanded to provide more context. For example, explaining why multi-fields are no-ops in this context could be beneficial for future maintainers or reviewers.\n\n3. **Exception Handling**:\n   - **Line 36**: The method signature includes `throws IOException`, which is appropriate if the method is expected to handle I/O operations in the future. However, if the method remains a noop, consider whether this exception is necessary. If no I/O operations are performed, it might be better to remove it.\n\n4. **Code Style**:\n   - The code style appears consistent with Java conventions. However, ensure that the rest of the test class follows the same style for consistency.\n\n5. **Potential Edge Cases**:\n   - Since the method is currently a noop, consider adding a comment or a TODO note to remind future developers to think about edge cases related to multi-fields when they implement the test. This could include scenarios where multi-fields might inadvertently affect the behavior of the `AggregateMetricDouble` functionality.\n\nIn summary, while the addition is simple and does not introduce any bugs or performance issues, it could benefit from further elaboration and consideration of future implementation. \n\n**Actionable Feedback**:\n- Consider implementing a meaningful test or removing the method until it can be defined.\n- Expand the comment for clarity.\n- Review the necessity of the `throws IOException` declaration.\n\nOverall, the code is on the right track but could use some refinement.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 83,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java",
          "content": "Overall, the code diff looks good and appears to be a straightforward addition of a method to handle multi-fields in the `ConstantKeywordFieldBlockLoaderTests` class. However, there are a few points worth mentioning:\n\n1. **Method Implementation**:\n   - **Line 25**: The `testBlockLoaderOfMultiField` method is currently a placeholder with a comment indicating that multi-fields are a no-op for `constant_keyword`. While this is acceptable for a test method, it would be beneficial to include an assertion or a log statement to explicitly indicate that this test is being skipped or is intentionally empty. This can help future maintainers understand the intent without needing to infer it from the comment.\n\n2. **Code Style**:\n   - **Line 23**: The method name `testBlockLoaderOfMultiField` could be more descriptive. Consider renaming it to something like `testMultiFieldNoOp` to clearly convey that this test is verifying that multi-fields do not have any effect.\n\n3. **Documentation**:\n   - It might be helpful to add a Javadoc comment above the `testBlockLoaderOfMultiField` method to explain why this test is a no-op and what the expected behavior is. This can improve code readability and maintainability.\n\n4. **Edge Cases**:\n   - While the current implementation is correct, consider whether there are any edge cases related to multi-fields that should be tested in the future. For example, if there are specific configurations or scenarios where multi-fields might interact with `constant_keyword`, it would be prudent to document those considerations.\n\nIn summary, while the code is functional, enhancing clarity through better naming, documentation, and possibly adding assertions would improve the overall quality of the test. \n\nOverall, the changes are acceptable, but consider the suggestions for improvement.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 84,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for multi-fields that do not have a fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 380: The condition `blContext.parentField(name()) == null` is added to check for multi-fields. Ensure that this logic correctly identifies when a field is a multi-field and that it does not inadvertently exclude valid cases where a synthetic source should be used.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the new condition is helpful for understanding the rationale behind the change. However, consider rephrasing it for clarity. For example, \"Check for multi-fields that do not have a fallback synthetic source.\" This makes it clearer what the condition is checking for.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `parentField(name())` method behaves as expected in all scenarios. If there are edge cases where this method could return unexpected results (e.g., if the field name is not found), it could lead to incorrect behavior. It might be beneficial to add unit tests to cover these scenarios.\n\n4. **Performance Issues**:\n   - The added condition introduces an additional method call (`blContext.parentField(name())`). If this method is computationally expensive or if it is called frequently in a performance-critical path, consider caching the result if applicable.\n\nIn summary, while the change seems to enhance the functionality by preventing fallback synthetic sources for multi-fields, ensure that the logic is robust and consider potential performance implications.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 85,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java",
          "content": "Overall Assessment:\nThe code diff introduces a condition to check if the `blContext.parentField(name())` is null before proceeding with the fallback synthetic source. This change appears to be a logical improvement to prevent unnecessary fallback loading for multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 314**: The comment added is helpful for understanding the context of the change. However, it could be more descriptive. Consider rephrasing it to clarify why multi-fields do not have a fallback synthetic source, which would enhance maintainability.\n\n2. **Line 315**: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition, but ensure that `blContext.parentField(name())` is not computationally expensive. If it involves a complex lookup, it could impact performance, especially if this method is called frequently. If performance is a concern, consider caching the result if applicable.\n\n3. **Edge Cases**: Ensure that the logic correctly handles cases where `blContext` might be null or improperly initialized. Although this is likely managed elsewhere, it's good practice to validate assumptions about the state of objects being used.\n\n4. **Testing**: Ensure that there are adequate unit tests covering this new condition. Specifically, tests should verify that the fallback synthetic source is not called for multi-fields and that the behavior is as expected when `blContext.parentField(name())` is null.\n\n5. **Code Style**: The code adheres to standard Java conventions. However, consider adding a brief comment above the method to describe its purpose and the significance of the new condition for future maintainers.\n\nIn summary, while the change is a positive improvement, attention to performance implications, edge cases, and documentation will enhance the robustness of the code.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 86,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java",
          "content": "Overall Assessment:\nThe code change introduces a condition to check if the `blContext.parentField(name())` is `null` when `isSyntheticSource` is true. This is a reasonable modification to prevent fallback synthetic source loading for multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 202**: The comment added is helpful for understanding the rationale behind the condition. However, it could be more descriptive. Consider explaining what \"multi fields\" are in this context or why they don't have a fallback synthetic source. This would improve maintainability for future developers.\n\n2. **Line 203**: The new condition checks for `blContext.parentField(name()) == null`. Ensure that this method call is efficient and does not introduce performance overhead, especially if it involves complex logic or data retrieval. If `parentField` is a costly operation, consider caching the result if it is called multiple times in the same context.\n\n3. **Edge Cases**: Consider what happens if `blContext` is `null`. Although it may be guaranteed by the surrounding code, adding a null check could prevent potential `NullPointerExceptions` in edge cases.\n\n4. **Testing**: Ensure that there are adequate unit tests covering this new condition. Specifically, tests should verify that the fallback synthetic source is not called for multi-fields and that the logic behaves correctly when `blContext.parentField(name())` returns both `null` and non-null values.\n\n5. **Code Style**: The code adheres to standard Java conventions. However, ensure that the surrounding code maintains consistent formatting, especially regarding indentation and spacing, to enhance readability.\n\nIn summary, while the change is logical and seems to improve the handling of synthetic sources, attention to documentation, performance considerations, edge cases, and testing will enhance the robustness of this modification.",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 87,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java",
          "content": "Overall, the code diff looks good and appears to be a straightforward addition of a method that overrides a test case for multi-fields in the `GeoShapeFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 36-39**: The newly added method `testBlockLoaderOfMultiField()` is currently a placeholder with a comment indicating that multi-fields are no-ops for `geo_shape`. While this is acceptable for a test that is not meant to perform any operations, it would be beneficial to include a more descriptive comment explaining why this is the case. This can help future maintainers understand the rationale behind the no-op.\n\n2. **Code Style**:\n   - **Line 36**: The method name `testBlockLoaderOfMultiField` could be more descriptive. Consider renaming it to something like `testMultiFieldNoOpForGeoShape` to better convey its purpose.\n\n3. **Documentation**:\n   - It might be helpful to add a Javadoc comment for the new method to clarify its intent and any relevant context about the behavior of multi-fields in relation to `geo_shape`.\n\n4. **Test Coverage**:\n   - Ensure that there are other tests that cover scenarios where multi-fields are used with `geo_shape`, even if they are expected to be no-ops. This will help ensure that the behavior is well-documented and verified.\n\n5. **Potential Edge Cases**:\n   - While the current implementation is straightforward, consider if there are any edge cases related to multi-fields that should be documented or tested in the future, even if they are not applicable at this moment.\n\nIn summary, while the code change is simple and functional, enhancing the documentation and naming conventions would improve clarity and maintainability. \n\nOverall, the code looks good with minor suggestions for improvement. \n\n**LGTM! (Looks Good To Me)**",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 88,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be a straightforward addition of a method that overrides an existing method in the `PointFieldBlockLoaderTests` class. The new method is a placeholder that indicates that multi-fields are a no-op for point types. Here are some specific points to consider:\n\n1. **Bugs or Logical Errors**: \n   - There are no apparent bugs or logical errors in the new method. It correctly overrides the existing method and provides a comment explaining its purpose.\n\n2. **Performance Issues**: \n   - There are no performance issues introduced by this change. The method is a no-op, so it does not add any overhead.\n\n3. **Security Vulnerabilities**: \n   - There are no security vulnerabilities present in this diff. The method does not handle any sensitive data or perform any operations that could introduce security risks.\n\n4. **Code Style and Best Practices**: \n   - The code adheres to standard Java conventions. The comment clearly explains the purpose of the overridden method, which is a good practice for maintainability.\n\n5. **Potential Edge Cases**: \n   - Since the method is a no-op, there are no edge cases to consider in this context. However, it might be beneficial to ensure that any tests that rely on this method are aware of its no-op nature to avoid confusion in the future.\n\nIn summary, the changes made in this diff are clear and appropriate for the context. \n\nLGTM! (Looks Good To Me)",
          "created_at": "2025-04-29T01:22:26"
        },
        {
          "id": 89,
          "review_id": 8,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be straightforward, with the addition of a method that overrides a test case for multi-fields in the `ShapeFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 35**: The method `testBlockLoaderOfMultiField()` is currently a placeholder with a comment indicating that multi-fields are a no-op for shape. While this is acceptable for a test case, it would be beneficial to include a more descriptive comment explaining why this is the case. This can help future developers understand the rationale behind this implementation.\n\n2. **Code Style**:\n   - **Line 34-36**: The method could benefit from a JavaDoc comment to describe its purpose, especially since it overrides a method from a superclass. This would improve readability and maintainability.\n\n3. **Test Coverage**:\n   - While the method is marked as a no-op, it might be useful to consider adding a simple assertion or logging statement to confirm that the method is being called during tests. This can help ensure that the test suite is functioning as expected and that the no-op behavior is intentional.\n\n4. **Exception Handling**:\n   - **Line 35**: The method signature declares that it throws `IOException`, but since the method body is empty, it will never actually throw this exception. If the method is intended to remain a no-op, consider removing the `throws IOException` declaration to avoid confusion.\n\n5. **Potential Edge Cases**:\n   - If there are any specific scenarios where multi-fields could potentially lead to issues in the context of shape fields, it might be worth documenting those in the comment or considering how to handle them in the future.\n\nIn summary, while the code is functional, enhancing comments and documentation would improve clarity and maintainability. \n\n### Suggested Changes:\n- Add a JavaDoc comment to `testBlockLoaderOfMultiField()`.\n- Consider removing the `throws IOException` declaration if the method is truly a no-op.\n\nOverall, the changes are minor, and the code is on the right track. \n\n**Final Assessment**: LGTM! (Looks Good To Me) with minor suggestions for improvement.",
          "created_at": "2025-04-29T01:22:26"
        }
      ]
    },
    {
      "id": 1,
      "pr_id": 2487052561,
      "summary": "This PR aims to enhance the testing coverage for block loaders associated with multifields in the Elasticsearch codebase. The changes span 22 files, primarily focusing on various field mappers, including `ScaledFloatFieldMapper`, `BooleanFieldMapper`, `DateFieldMapper`, `GeoPointFieldMapper`, and `IpFieldMapper`. \n\nSignificant modifications include the addition of test cases that validate the functionality and reliability of the block loaders, ensuring they handle multifield scenarios correctly. The changes involve minor code adjustments, with a total of 27 additions and 6 deletions across the modified files, indicating a focused effort on improving test coverage without extensive alterations to existing logic.\n\nPotential concerns include ensuring that the new tests are comprehensive enough to cover edge cases and that they do not introduce any performance regressions. Additionally, it would be beneficial to review the test execution time to ensure that the added tests do not significantly slow down the overall test suite. \n\nOverall, this PR is a positive step towards improving the robustness of the multifield handling in Elasticsearch, but careful consideration should be given to the quality and performance of the new tests.",
      "full_review": "# AI Review \ud83e\udd16\n\n## Summary\nThis PR aims to enhance the testing coverage for block loaders associated with multifields in the Elasticsearch codebase. The changes span 22 files, primarily focusing on various field mappers, including `ScaledFloatFieldMapper`, `BooleanFieldMapper`, `DateFieldMapper`, `GeoPointFieldMapper`, and `IpFieldMapper`. \n\nSignificant modifications include the addition of test cases that validate the functionality and reliability of the block loaders, ensuring they handle multifield scenarios correctly. The changes involve minor code adjustments, with a total of 27 additions and 6 deletions across the modified files, indicating a focused effort on improving test coverage without extensive alterations to existing logic.\n\nPotential concerns include ensuring that the new tests are comprehensive enough to cover edge cases and that they do not introduce any performance regressions. Additionally, it would be beneficial to review the test execution time to ensure that the added tests do not significantly slow down the overall test suite. \n\nOverall, this PR is a positive step towards improving the robustness of the multifield handling in Elasticsearch, but careful consideration should be given to the quality and performance of the new tests.\n\n## Detailed Review\n\n### modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java\nOverall, the code diff appears to be a logical modification aimed at improving the handling of synthetic sources in the `ScaledFloatFieldMapper` class. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - **Line 379**: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition to prevent fallback synthetic sources for multi-fields. However, ensure that `blContext.parentField(name())` correctly identifies multi-fields in all scenarios. If there are edge cases where this might not behave as expected, it could lead to unintended behavior.\n\n2. **Performance Issues**:\n   - No significant performance issues are apparent in this diff. The changes seem to maintain the existing performance characteristics while adding necessary checks.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities are evident in this change. The logic appears to be safe as it deals with internal field handling.\n\n4. **Code Style and Best Practices**:\n   - The comments added are helpful for understanding the rationale behind the condition. However, consider using a more descriptive comment that explains why multi-fields don't have a fallback synthetic source, as this could aid future maintainers in understanding the context better.\n\n5. **Potential Edge Cases**:\n   - Ensure that the `blContext.parentField(name())` method behaves as expected in all scenarios, especially in cases where the field might not exist or when dealing with complex mappings. It would be prudent to add unit tests that cover these edge cases to ensure robustness.\n\nIn summary, the changes made are logical and improve the code's handling of synthetic sources. Just ensure thorough testing around the new condition to avoid any edge cases that might arise.\n### server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for the parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 351: The added condition `blContext.parentField(name()) == null` is a good safeguard against multi-fields having a fallback synthetic source. However, ensure that this logic aligns with the intended behavior of the application. If there are cases where a synthetic source should still be allowed even if `parentField` is not null, this could lead to unintended behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 350: The comment `// Multi fields don't have fallback synthetic source.` is helpful for understanding the rationale behind the condition. However, consider expanding it to explain why this is the case or under what circumstances this rule applies. This can aid future maintainers in understanding the context better.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext` and its method `parentField(name())` are well-defined and handle all expected cases. If `parentField` can return unexpected values or throw exceptions, consider adding error handling or assertions to manage those scenarios.\n\n4. **Performance Issues**:\n   - The performance impact of the additional condition is likely negligible, but if `parentField(name())` is a costly operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive addition, ensure that the logic aligns with the overall design and consider enhancing comments for clarity.\n### server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for multi fields that do not have a fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 949: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition, but it assumes that `blContext.parentField(name())` will return `null` for all multi fields. Ensure that this assumption holds true in all cases, as it could lead to unexpected behavior if there are edge cases where a parent field exists but is not properly recognized.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the condition is helpful for understanding the rationale behind the change. However, consider rephrasing it for clarity. For example, \"Check if the field is synthetic and ensure it does not belong to a multi-field context.\" This makes it clearer that the check is specifically about the context of multi-fields.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext.parentField(name())` method is robust and handles all possible scenarios, including cases where the field name might not exist or where the context might be in an unexpected state. It would be beneficial to add unit tests that cover these edge cases to ensure the new logic behaves as expected.\n\n4. **Performance Issues**:\n   - There are no immediate performance issues with the change itself, but if `blContext.parentField(name())` is a costly operation, consider caching the result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive step, ensure that the assumptions made about the context and the behavior of `blContext.parentField(name())` are thoroughly validated. Adding tests for edge cases will help solidify the reliability of this modification.\n### server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\nOverall, the code diff appears to be well-structured and addresses some clarity issues in comments and method implementations. However, there are a few points worth noting:\n\n1. **Comment Clarity**:\n   - **Line 318**: The comment has been improved for clarity, which is good. However, consider rephrasing \"consumers only ever read text from the parser\" to \"consumers are expected to only read text from the parser\" for better readability.\n\n2. **Method Override**:\n   - **Lines 332-335**: The addition of the `text()` method is a good enhancement, ensuring that the `value` is accessible through this method. Ensure that this method is adequately tested to confirm it behaves as expected in all scenarios.\n\n3. **Logical Condition**:\n   - **Line 546**: The condition `blContext.parentField(name()) == null` is a new addition that changes the logic of when to use the fallback synthetic source. Ensure that this condition is well understood and tested, as it could potentially lead to different behavior in cases where multi-fields are involved. It would be beneficial to add a comment explaining why this condition is necessary.\n\n4. **Performance Considerations**:\n   - The changes do not introduce any obvious performance issues, but ensure that the new method `text()` does not introduce any unnecessary overhead. Profiling may be necessary if this method is called frequently.\n\n5. **Edge Cases**:\n   - Ensure that the new logic in the block loader handles all edge cases, especially with multi-fields. It would be prudent to add unit tests that cover scenarios with and without doc values, as well as cases with multi-fields to ensure robustness.\n\nIn summary, while the changes are generally positive, attention should be paid to the new logical condition and ensuring comprehensive testing around it.\n### server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java\nOverall Assessment:\nThe code change introduces a condition to check if the `blContext.parentField(name())` is `null` before proceeding with the fallback synthetic source. This is a reasonable modification to prevent unnecessary fallback for multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 468**: The comment added is helpful for understanding the context of the change. However, it could be more descriptive. Consider explaining why multi-fields don't have a fallback synthetic source, as this could aid future maintainers.\n\n2. **Line 469**: The condition `isSyntheticSource && blContext.parentField(name()) == null` is logically sound, but ensure that `blContext.parentField(name())` is not computationally expensive. If it involves a lookup or computation, it might be worth caching the result if this method is called frequently.\n\n3. **Edge Cases**: Ensure that the `blContext` is always valid and not `null` before calling `blContext.parentField(name())`. If there's a possibility that `blContext` could be `null`, it would lead to a `NullPointerException`. Adding a null check would enhance robustness.\n\n4. **Code Style**: The code adheres to standard Java conventions. However, consider using more descriptive variable names if `blContext` is not immediately clear to all readers. A more descriptive name could improve readability.\n\n5. **Testing**: Ensure that there are adequate unit tests covering this new condition. Specifically, tests should verify that the fallback synthetic source is not called for multi-fields and that the behavior is as expected when `blContext.parentField(name())` is `null`.\n\nIn summary, while the change is a positive improvement, consider enhancing documentation, checking for potential null values, and ensuring performance is not impacted by the new condition.\n### server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for a parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 8: The comment states that \"Multi fields don't have fallback synthetic source.\" This could be misleading if not properly documented elsewhere. Ensure that the behavior of multi-fields is clearly defined in the documentation to avoid confusion for future maintainers.\n\n2. **Code Style and Best Practices**:\n   - Line 7: The comment could be more descriptive. Instead of just stating the fact, it could explain why this condition is necessary. For example, \"Check for parent field to prevent fallback synthetic source loading for multi-fields.\"\n\n3. **Potential Edge Cases**:\n   - Line 8: Consider what happens if `blContext.parentField(name())` returns an unexpected value (e.g., an object that is not null but not a valid parent field). It might be beneficial to add additional checks or logging to handle such cases gracefully.\n\n4. **Performance Issues**:\n   - There are no immediate performance issues in this diff, but ensure that the `parentField` method is efficient, as it will be called in this conditional check. If it involves complex logic or database calls, it could impact performance.\n\nIn summary, while the change is a positive step, enhancing the comments for clarity and considering edge cases would improve the code's maintainability and robustness.\n### server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java\nOverall, the code diff appears to be a logical improvement by adding a condition to check for multi-fields that do not have a fallback synthetic source. However, there are a few points to consider:\n\n1. **Logical Errors**:\n   - Line 1974: The added condition checks if `blContext.parentField(name())` is `null` to determine if the synthetic source should be used. Ensure that this logic aligns with the intended behavior of the application. If `parentField` can return a non-null value for valid cases, this could lead to unexpected behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 1973: The comment added before the condition is helpful, but it could be more descriptive. Consider explaining why multi-fields do not have a fallback synthetic source, which would provide better context for future maintainers.\n\n3. **Potential Edge Cases**:\n   - The check for `isSyntheticSource` and `blContext.parentField(name()) == null` should be thoroughly tested to ensure that it covers all scenarios where a synthetic source might be expected. Consider edge cases where `blContext` might be in an unexpected state or where `name()` could lead to ambiguous results.\n\n4. **Performance Issues**:\n   - There are no apparent performance issues introduced by this change. However, if `parentField(name())` is a costly operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change seems to improve the logic, ensure that the new condition is thoroughly tested and consider enhancing the comment for clarity.\n### server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\nOverall, the code diff appears to be well-structured and introduces a new parameter to several methods to handle multifield adjustments for `GeoPoint` objects. However, there are a few areas that could be improved or warrant further consideration.\n\n### Specific Issues:\n\n1. **Line 35-36**: The switch statement for `nullValue` handling is clear, but consider adding a comment to explain the purpose of the `convert` method and the significance of the `false` parameter. This will improve code readability for future maintainers.\n\n2. **Line 67-68**: Similar to the previous point, adding a comment about why `exactValuesFromSource` is called with `false` for `needsMultifieldAdjustment` would enhance clarity.\n\n3. **Line 94**: The method `toWKB(normalize(convert(values, nullValue, false)))` could potentially throw a `NullPointerException` if `convert` returns `null`. Ensure that `normalize` can handle `null` gracefully, or add a check before calling `normalize`.\n\n4. **Line 168**: The `convert` method now has a new parameter, but the handling of `nullValue` could be clearer. The check for `nullValue` should be combined with the multifield adjustment logic to avoid returning `null` when `nullValue` is not `null`. This could lead to confusion.\n\n5. **Line 188-189**: The `GeoPoint` constructor is called multiple times with similar logic. Consider extracting this into a private method to reduce code duplication and improve maintainability.\n\n6. **Line 205-206**: The `possiblyAdjustMultifieldValue` method is a good addition, but ensure that the logic for resetting from a geohash is well-tested. If the geohash is malformed or invalid, it could lead to unexpected behavior. Consider adding error handling or validation.\n\n7. **Performance Consideration**: The use of streams and lambda expressions is generally good for readability, but if performance is a concern (especially with large lists), consider using traditional loops for better performance in critical sections.\n\n8. **Edge Cases**: Ensure that edge cases are handled, such as:\n   - What happens if `coordinates` in the GeoJSON representation are empty or have fewer than two elements?\n   - How does the code behave with malformed input strings for `GeoPoint`?\n\n### Conclusion:\nThe code changes are generally well-implemented, but there are areas for improvement in terms of clarity, error handling, and performance considerations. Addressing the above points will enhance the robustness and maintainability of the code.\n\n### Recommendation:\nConsider adding unit tests that cover edge cases and potential failure scenarios to ensure the new logic behaves as expected. \n\nOverall, the changes are promising, but attention to the mentioned details will improve the quality of the code.\n### server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java\nOverall, the code diff shows a significant refactor of the `TextFieldWithParentBlockLoaderTests` class, transitioning from extending `BlockLoaderTestCase` to `MapperServiceTestCase`. The changes appear to enhance the test's structure and clarity, but there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 9-10**: The import statements for `DefaultMappingParametersHandler` have been removed. If this class is no longer used, it's fine, but ensure that any functionality it provided is adequately replaced or refactored.\n\n2. **Line 51-52**: The comment about the \"tricky meta-logic\" could be clearer. Consider rephrasing to explain why this logic is necessary for future maintainers.\n\n3. **Line 66**: The method `expected` is now private. If this method is intended to be used in subclasses or other test cases, consider changing it back to protected. If it is only used within this class, then it is fine as private.\n\n4. **Line 68**: The variable `normalizer` is retrieved but not used. If it is not needed, consider removing this line to avoid confusion.\n\n5. **Line 70**: The assertion `assert fieldMapping.containsKey(\"fields\");` could throw a `NullPointerException` if `fieldMapping` is null. Consider adding a null check before this assertion to prevent potential runtime exceptions.\n\n6. **Line 73**: The mapping retrieval for `textFieldMapping` assumes that the key \"mf\" will always exist. If it does not, this will lead to a `NullPointerException`. Consider adding a check to ensure that \"mf\" exists in the `fields` map before attempting to access it.\n\n7. **Line 75**: The method `TextFieldBlockLoaderTests.expectedValue` is called with `params` and `testContext`. Ensure that these parameters are valid and that `expectedValue` can handle any edge cases that might arise from them.\n\n### Performance Issues:\n- The use of `Map.of` creates immutable maps. If these maps are frequently created in a loop or high-frequency context, consider using mutable maps to avoid the overhead of creating new instances.\n\n### Code Style and Best Practices:\n- Consider adding JavaDoc comments to public methods and classes to improve code readability and maintainability.\n- Ensure consistent formatting, especially with spacing and indentation, to enhance readability.\n\n### Potential Edge Cases:\n- Ensure that the `DataSourceHandler` implementation can handle unexpected input gracefully. For example, if `request.fieldName()` returns a value that is not expected, the method should handle it without throwing exceptions.\n- Consider what happens if the `DataSourceResponse` does not return the expected mappings. Implement error handling to manage such cases.\n\nIn summary, while the refactor improves the structure of the test class, attention should be paid to potential null pointer exceptions, clarity in comments, and ensuring that all edge cases are handled appropriately.\n### test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java\nOverall Assessment:\nThe code diff introduces a new field `dataSource` to the `LeafMappingParametersGenerator` record. While the change appears straightforward, there are a few considerations to address regarding code style and potential implications of this addition.\n\nSpecific Issues:\n\n1. **Line 200**: The addition of the `dataSource` field should be accompanied by a comment explaining its purpose and how it will be used within the `LeafMappingParametersGenerator`. This will improve code readability and maintainability.\n\n2. **Line 200**: Ensure that the `DataSource` class is properly imported if it is not already. If the import is missing, it could lead to compilation errors.\n\n3. **Line 201**: Consider whether the `dataSource` field should be final. If it is intended to be immutable after the record is created, marking it as `final` would be a good practice.\n\n4. **Line 201**: If `DataSource` contains sensitive information or is mutable, consider the implications of exposing it in this record. If the `dataSource` is mutable, it could lead to unintended side effects if the state is changed after the record is created.\n\n5. **Documentation**: Update any relevant documentation or comments in the codebase to reflect the addition of the `dataSource` field, especially if it affects the behavior of the `LeafMappingParametersGenerator`.\n\n6. **Testing**: Ensure that there are corresponding unit tests that cover the new functionality introduced by the `dataSource` field. This will help catch any potential issues early.\n\nIn summary, while the change itself is not inherently problematic, attention to detail regarding documentation, immutability, and testing will enhance the quality of the code.\n### test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java\nOverall, the code diff shows a significant refactoring of the `DefaultMappingParametersHandler` class, with a focus on simplifying the mapping parameter generation. While the changes improve readability and reduce the number of parameters passed around, there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 36-38**: The removal of the `map` variable and the conditional addition of the `SYNTHETIC_SOURCE_KEEP_PARAM` could lead to a loss of functionality. If this parameter is necessary for certain mappings, its absence may cause issues in the generated mappings.\n\n2. **Line 70-72**: The `numberMapping` method now directly uses `commonMappingParameters()` to create a new mapping each time. If `commonMappingParameters()` is expensive to compute, this could lead to performance issues, especially if `numberMapping` is called frequently. Consider caching the result if the parameters do not change.\n\n3. **Line 92-94**: Similar to the previous point, the `keywordMapping` method creates a new mapping each time it is called. If `commonMappingParameters()` is costly, this could lead to performance degradation. Again, consider caching or reusing the mapping if possible.\n\n4. **Line 100-102**: The logic for injecting parameters into the mapping is now more streamlined, but ensure that the randomness introduced (e.g., `ESTestCase.randomDouble() <= 0.2`) does not lead to unexpected behavior in production. It might be beneficial to log or handle cases where certain parameters are not set due to randomness.\n\n5. **Line 169-171**: The `booleanMapping` method has been simplified, but ensure that the randomness does not lead to a situation where critical parameters are omitted. Consider adding validation to ensure that the generated mapping meets the expected schema.\n\n6. **Line 177-179**: The `dateMapping` method also follows the same pattern of creating a new mapping each time. Again, consider the performance implications of this change.\n\n### Code Style and Best Practices:\n\n- **Consistency**: The code has been made more consistent in terms of how mappings are generated. However, ensure that all methods that generate mappings follow the same pattern for clarity and maintainability.\n\n- **Documentation**: Consider adding comments to explain the purpose of each mapping method, especially since the logic has been abstracted away. This will help future maintainers understand the intent behind the changes.\n\n### Potential Edge Cases:\n\n- **Randomness**: The use of randomness in generating mapping parameters could lead to edge cases where certain expected parameters are not included. Ensure that there are sufficient tests to cover these scenarios.\n\n- **Null Handling**: Ensure that the generated mappings handle null values appropriately, especially since the code introduces randomness in setting `null_value`. This could lead to unexpected behavior if not handled correctly.\n\nIn summary, while the refactoring improves readability and reduces parameter passing, attention should be paid to performance implications, potential loss of functionality, and the handling of randomness in mapping generation. Consider adding tests to cover edge cases introduced by the changes.\n### test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java\nOverall Assessment: The code diff shows a minor modification where an additional parameter is passed to the `LeafMappingParametersGenerator` constructor. While the change itself does not introduce any obvious bugs or performance issues, it is important to ensure that the new parameter is necessary and correctly utilized.\n\n1. **Bugs or Logical Errors**:\n   - Line 105: Ensure that `specification.dataSource()` is not null before passing it to the `LeafMappingParametersGenerator`. If it is null, it could lead to a `NullPointerException`.\n\n2. **Performance Issues**:\n   - No performance issues are evident in this change. However, if `specification.dataSource()` involves heavy computation or resource allocation, consider caching its result if it is called multiple times.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities are apparent in this diff. However, ensure that the data source being passed does not expose sensitive information or allow for injection attacks.\n\n4. **Code Style and Best Practices**:\n   - The code style appears consistent with Java conventions. However, consider adding a comment explaining why `specification.dataSource()` is being passed to improve code readability for future maintainers.\n\n5. **Potential Edge Cases**:\n   - Line 105: Consider what happens if `context.eligibleCopyToDestinations()` returns an empty list or null. Ensure that the downstream code can handle such cases gracefully.\n\nIn summary, while the change itself is straightforward, it is crucial to validate the inputs and consider potential edge cases to ensure robustness.\n### test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java\nOverall, the code diff shows a significant refactor of the `BlockLoaderTestCase` class, with a focus on improving the handling of data source handlers and the generation of mappings and documents. The changes appear to enhance the structure and readability of the code. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Unused Imports**:\n   - Lines 4-10: Several imports have been removed, which is good for cleanliness. However, ensure that any remaining imports are necessary. If there are any unused imports left, they should be removed to maintain code clarity.\n\n2. **Variable Naming**:\n   - Line 27: The variable `customDataSourceHandlers` is well-named, but consider renaming `customHandlers` in the `buildSpecification` method to maintain consistency. Using `customDataSourceHandlers` throughout would improve clarity.\n\n3. **Error Handling**:\n   - Lines 82-83 and 118-119: The `runTest` method calls do not seem to handle potential exceptions that could arise from `createSytheticSourceMapperService` or `createMapperService`. Consider adding try-catch blocks to handle `IOException` or other relevant exceptions gracefully.\n\n4. **Test Context Initialization**:\n   - Lines 118-120: The `TestContext` is initialized with `false` for `isMultifield` in multiple places. If this is a common case, consider creating a method or a constant to avoid magic values and improve readability.\n\n5. **Potential Null Pointer Exceptions**:\n   - Lines 114 and 140: The calls to `mapping.lookup().get(fieldName)` and `mapping.lookup().get(fullFieldName.toString())` could potentially return `null`. Ensure that there is a check for null values before using them to avoid `NullPointerException`.\n\n6. **Performance Considerations**:\n   - The creation of `MappingGenerator` and `DocumentGenerator` in the `testBlockLoader` and `testBlockLoaderForFieldInObject` methods could be optimized if they are reused. If the specifications do not change, consider initializing them once and reusing them to avoid unnecessary object creation.\n\n7. **Code Duplication**:\n   - The logic for creating `mappingXContent` and `mapperService` is duplicated in both `testBlockLoader` and `testBlockLoaderForFieldInObject`. Consider extracting this logic into a separate method to reduce duplication and improve maintainability.\n\n### Conclusion:\nThe refactor improves the structure and readability of the code, but attention should be paid to error handling, potential null pointer exceptions, and code duplication. Addressing these issues will enhance the robustness and maintainability of the code.\n\nOverall, the changes are positive, but the above points should be considered for further improvement.\n### test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java\nOverall, the code appears to be well-structured and follows good practices for unit testing in Java, particularly in the context of Elasticsearch. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Error Handling (Line 66)**:\n   - The method `setupAndInvokeBlockLoader` does not handle potential exceptions that may arise from `iw.addDocument(doc);`. If an exception occurs here, it will propagate up without any context. Consider adding logging or handling specific exceptions to provide more insight into failures.\n\n2. **Resource Management (Lines 66-67)**:\n   - The `RandomIndexWriter` is closed immediately after adding a document. If an exception occurs before the `iw.close()` line, the writer may not be closed properly. Consider using a try-with-resources statement for `RandomIndexWriter` to ensure it is always closed.\n\n3. **Null Checks (Line 92)**:\n   - The method `load` assumes that `columnAtATimeReader` will not be null after the check. If it is null, the method will proceed to the next block of code, which may lead to a `NullPointerException`. Consider adding a null check and handling this case appropriately.\n\n4. **Performance Considerations (Line 118)**:\n   - The method `load` creates a new `BlockLoaderStoredFieldsFromLeafLoader` every time it is called. If this method is called frequently, it could lead to performance issues. Consider caching or reusing instances where possible.\n\n5. **Code Style (Line 36)**:\n   - The method `runTest` uses `var` for variable declaration. While this is valid in Java, it may reduce readability for some developers. Consider using explicit types for clarity, especially in public methods.\n\n6. **Potential Edge Cases (Line 118)**:\n   - The method `load` does not handle the case where `storedFieldsSpec` might be null after the merge operation. Ensure that this is checked before proceeding to use it.\n\n7. **Documentation**:\n   - The class and methods lack JavaDoc comments. Adding documentation would improve maintainability and help other developers understand the purpose and usage of the class and its methods.\n\n### Summary:\nWhile the code is generally well-implemented, addressing the above points will enhance its robustness, maintainability, and performance. Consider implementing the suggested changes to improve the overall quality of the code.\n### x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java\nOverall, the code diff appears to be a straightforward addition of a test method that indicates a no-operation (noop) for multi-fields in the `AggregateMetricDoubleFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Test Method Implementation**:\n   - **Line 36**: The newly added test method `testBlockLoaderOfMultiField` is currently empty except for a comment. While it is acceptable to have a placeholder for a test, it is generally better to include at least a simple assertion or a `fail()` statement to indicate that the test is intentionally not implemented yet. This helps in identifying unimplemented tests during test runs.\n\n2. **Comment Clarity**:\n   - **Line 37**: The comment `// Multi fields are noop for aggregate_metric_double.` could be expanded for clarity. It might be beneficial to explain why multi-fields are a no-op in this context, especially for future maintainers who may not be familiar with the specifics of the `aggregate_metric_double` functionality.\n\n3. **Code Style**:\n   - The code style appears consistent with Java conventions. However, ensure that the rest of the class follows the same formatting and naming conventions for consistency.\n\n4. **Potential Edge Cases**:\n   - While the method is a no-op, consider documenting any edge cases that might arise when multi-fields are involved, even if they are not applicable in this specific implementation. This can help future developers understand the implications of this design choice.\n\nIn summary, while the addition is simple and does not introduce any bugs or performance issues, enhancing the test method with assertions and improving comment clarity would be beneficial for maintainability and understanding.\n\n### Suggested Changes:\n- Add an assertion or a `fail()` statement in `testBlockLoaderOfMultiField`.\n- Expand the comment to provide more context about why multi-fields are a no-op.\n\nOverall, the code is on the right track but could use some minor improvements for clarity and completeness.\n### x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java\nOverall Assessment:\nThe code diff appears to be a straightforward addition of a method to handle multi-fields in the `ConstantKeywordFieldBlockLoaderTests` class. The implementation is a no-op, which is appropriate given the context. However, there are a few points worth noting regarding code style and best practices.\n\nSpecific Issues:\n\n1. **Line 24**: The method `testBlockLoaderOfMultiField` is marked as `throws IOException`, but it does not contain any code that could throw this exception. If the method is intended to be a no-op, consider removing the `throws IOException` declaration to avoid confusion.\n\n2. **Line 25**: The comment `// Multi fields are noop for constant_keyword.` is clear, but it could be more informative. Consider expanding it to explain why multi-fields are a no-op for `constant_keyword`, which could help future maintainers understand the rationale behind this implementation.\n\n3. **Code Style**: Ensure that the comment style is consistent with the rest of the codebase. If other comments use a specific format (e.g., Javadoc style), it might be beneficial to follow that convention for consistency.\n\n4. **Test Coverage**: While the method is a no-op, it might be useful to include a test case that explicitly verifies that multi-fields do not affect the behavior of the `ConstantKeywordFieldBlockLoader`. This could help ensure that future changes do not inadvertently alter this behavior.\n\n5. **Documentation**: If this is part of a larger framework or library, consider documenting this behavior in the relevant documentation to inform users about the handling of multi-fields with `constant_keyword`.\n\nIn summary, while the code change is simple and seems appropriate, addressing the points above could improve clarity and maintainability.\n### x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\nOverall, the code diff appears to be a logical improvement, adding a condition to check for a parent field before allowing the fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 380: The added condition `blContext.parentField(name()) == null` is a good safeguard against multi-fields having a fallback synthetic source. However, ensure that this logic aligns with the intended behavior of the application. If there are cases where a synthetic source should be allowed even with a parent field, this could lead to unexpected behavior.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the new condition is helpful for understanding the rationale behind the change. However, consider using a more descriptive comment that explains why multi-fields should not have a fallback synthetic source. This can help future maintainers understand the context better.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `parentField(name())` method behaves as expected in all scenarios. If there are edge cases where this method could return unexpected results (e.g., if `name()` is not properly defined or if there are issues with the context), it could lead to bugs.\n\n4. **Performance Issues**:\n   - The performance impact of the additional check is likely negligible, but it\u2019s worth profiling if this method is called frequently in performance-critical paths. If `parentField(name())` is an expensive operation, consider caching its result if it is called multiple times.\n\nIn summary, while the change seems to improve the logic, ensure that the new condition aligns with the overall design and intended functionality of the system. Additionally, consider enhancing the comment for clarity.\n### x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java\nOverall Assessment:\nThe code diff introduces a condition to check if the `blContext.parentField(name())` is null before proceeding with the fallback synthetic source logic. This change appears to be a safeguard against multi-fields, which is a good addition. However, there are a few points to consider for clarity and potential edge cases.\n\nSpecific Issues:\n\n1. **Line 4**: The comment `// Multi fields don't have fallback synthetic source.` is helpful, but it could be more descriptive. Consider explaining why multi-fields don't have a fallback synthetic source and what implications this has for the logic. This will aid future maintainers in understanding the rationale behind the condition.\n\n2. **Line 5**: The condition `blContext.parentField(name()) == null` is a good check, but it would be beneficial to ensure that `name()` is not returning a null value itself. If `name()` can potentially return null, it could lead to a `NullPointerException`. Consider adding a null check for `name()` before this condition.\n\n3. **Performance Consideration**: If `blContext.parentField(name())` is an expensive operation, it might be worth caching the result in a local variable before the condition check. This would prevent multiple calls to the same method if the condition is used in more complex logic later.\n\n4. **Edge Cases**: Ensure that the logic correctly handles cases where `blContext` might be in an unexpected state. For example, if `blContext` is null or improperly initialized, it could lead to runtime exceptions. Consider adding checks or assertions to validate the state of `blContext` before using it.\n\n5. **Code Style**: The formatting and indentation are consistent, which is good. However, consider using more descriptive variable names if applicable, as it can improve readability. For instance, `blContext` could be expanded to something like `blockLoaderContext` for clarity, depending on the conventions used in the codebase.\n\nIn summary, while the change is a positive addition, addressing the above points will enhance the robustness and maintainability of the code.\n### x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java\nOverall Assessment:\nThe code change introduces a condition to check if the `blContext.parentField(name())` is `null` before calling `blockLoaderFromFallbackSyntheticSource(blContext)`. This is a reasonable modification to prevent unnecessary calls when dealing with multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 201**: The comment added before the condition is helpful for understanding the context. However, it could be more descriptive. Consider rephrasing it to clarify why multi-fields don't have a fallback synthetic source, which would enhance maintainability.\n\n2. **Line 202**: The new condition checks for `blContext.parentField(name()) == null`, which is a good addition. However, ensure that this check is sufficient for all cases where a synthetic source might be expected. It would be beneficial to add a comment explaining the implications of this check, especially for future maintainers.\n\n3. **Performance Consideration**: If `blContext.parentField(name())` involves a non-trivial computation or lookup, consider caching the result if it is used multiple times in the method. This would improve performance, especially if this method is called frequently.\n\n4. **Edge Cases**: Ensure that there are no edge cases where `isSyntheticSource` could be true, but `blContext.parentField(name())` is not `null`, leading to unexpected behavior. It might be worth adding unit tests to cover scenarios involving multi-fields and synthetic sources to validate the new logic.\n\n5. **Code Style**: The code adheres to standard Java conventions. However, ensure that the surrounding code is also well-documented, especially if this method is part of a larger class with complex logic.\n\nIn summary, while the change is a positive improvement, consider enhancing comments for clarity, reviewing performance implications, and ensuring comprehensive testing for edge cases.\n### x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java\nOverall, the code diff looks good and appears to be a straightforward addition of a method to handle multi-fields for the `GeoShapeFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 36**: The `testBlockLoaderOfMultiField` method is currently a placeholder with a comment indicating that multi-fields are no-ops for `geo_shape`. While this is acceptable for a test method, it would be beneficial to include a simple assertion or log statement to confirm that the method is being called during tests. This can help ensure that the test framework recognizes the method and that it is executed as part of the test suite.\n\n2. **Comment Clarity**:\n   - **Line 37**: The comment \"// Multi fields are noop for geo_shape.\" could be expanded for clarity. Consider rephrasing it to explain why multi-fields are no-ops for `geo_shape`, which could be helpful for future maintainers or reviewers who may not be familiar with the context.\n\n3. **Exception Handling**:\n   - **Line 36**: The method signature declares that it throws `IOException`, but since the method body is empty, it may be misleading. If the method is intended to be a no-op, consider removing the `throws IOException` declaration unless you plan to implement logic that could throw this exception in the future.\n\n4. **Code Style**:\n   - The code adheres to standard Java conventions, but ensure that the rest of the class maintains consistent formatting and style, especially regarding comments and method documentation.\n\n5. **Potential Edge Cases**:\n   - Since this method is a no-op, there are no immediate edge cases to consider. However, if future implementations are planned, consider how the method might handle unexpected input or states.\n\nIn summary, while the changes are minimal and mostly correct, enhancing the clarity of comments and ensuring the method's purpose is clear would improve the overall quality of the code. \n\n**Actionable Feedback**:\n- Add a simple assertion or log statement in `testBlockLoaderOfMultiField`.\n- Expand the comment for clarity.\n- Consider removing the `throws IOException` declaration if the method remains a no-op.\n\nOverall, the changes are on the right track, but a few improvements could enhance maintainability and clarity.\n### x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java\nOverall, the code diff appears to be a straightforward addition of a method that overrides an existing method in the `PointFieldBlockLoaderTests` class. The new method is a placeholder indicating that multi-fields are a no-op for point types. Here are some specific points to consider:\n\n1. **Bugs or Logical Errors**: \n   - There are no apparent bugs or logical errors in the new method. It correctly indicates that multi-fields are a no-op for point types.\n\n2. **Performance Issues**: \n   - There are no performance issues introduced by this change. The method is a simple override with no additional processing.\n\n3. **Security Vulnerabilities**: \n   - There are no security vulnerabilities present in this diff. The method does not expose any sensitive data or perform any operations that could lead to security issues.\n\n4. **Code Style and Best Practices**: \n   - The code adheres to standard Java conventions. The method is clearly named and the comment succinctly explains its purpose. However, consider adding a `@Override` annotation to the method for clarity, which is already present in the diff.\n\n5. **Potential Edge Cases**: \n   - Since the method is a no-op, there are no edge cases to consider in this context. However, it might be beneficial to ensure that any tests that rely on this behavior are properly documented or that there are assertions in place to confirm that multi-fields are indeed treated as no-ops.\n\nIn summary, the addition is clear and serves its purpose well. \n\n**LGTM! (Looks Good To Me)**\n### x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java\nOverall, the code diff appears to be straightforward, with the addition of a method that overrides a test case for multi-fields in the `ShapeFieldBlockLoaderTests` class. The implementation seems to be a placeholder indicating that multi-fields are a no-op for shape. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 35**: The method `testBlockLoaderOfMultiField()` is currently empty except for a comment. While it's acceptable to have a no-op test, it might be beneficial to include a simple assertion or log a message to indicate that this test is intentionally skipped. This can help future maintainers understand the purpose of the method without needing to read the comment.\n\n2. **Comment Clarity**:\n   - **Line 36**: The comment `// Multi fields are noop for shape.` could be expanded for clarity. It might be helpful to explain why multi-fields are a no-op for shape, or under what circumstances this behavior is expected. This would provide better context for future developers who may work on this code.\n\n3. **Code Style**:\n   - The code style is consistent with Java conventions. However, ensure that the project follows a specific style guide (e.g., Google Java Style Guide) for consistency across the codebase.\n\n4. **Edge Cases**:\n   - While the current implementation is a no-op, consider whether there are any edge cases that should be documented or tested in the future. For example, if the behavior of multi-fields changes, it might be necessary to revisit this test.\n\n5. **Exception Handling**:\n   - The method signature includes `throws IOException`, but since the method body does not perform any operations that could throw this exception, it may be unnecessary. If the method is intended to remain a no-op, consider removing the `throws IOException` declaration.\n\nIn summary, while the code is functional, enhancing the clarity of the comment and considering future maintainability could improve the overall quality of the test. \n\n**Specific Issues**:\n- **Line 35**: Consider adding an assertion or log message to clarify the purpose of the no-op test.\n- **Line 36**: Expand the comment for better clarity on why multi-fields are a no-op.\n- **Line 35**: Evaluate the necessity of `throws IOException` in the method signature.\n\nOverall, the changes are minor, but addressing them could improve code maintainability and clarity.\n\n\n---\n*This review was automatically generated by an AI assistant.*",
      "created_at": "2025-04-29T01:06:50",
      "file_reviews": [
        {
          "id": 1,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/ScaledFloatFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical modification aimed at improving the handling of synthetic sources in the `ScaledFloatFieldMapper` class. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - **Line 379**: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition to prevent fallback synthetic sources for multi-fields. However, ensure that `blContext.parentField(name())` correctly identifies multi-fields in all scenarios. If there are edge cases where this might not behave as expected, it could lead to unintended behavior.\n\n2. **Performance Issues**:\n   - No significant performance issues are apparent in this diff. The changes seem to maintain the existing performance characteristics while adding necessary checks.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities are evident in this change. The logic appears to be safe as it deals with internal field handling.\n\n4. **Code Style and Best Practices**:\n   - The comments added are helpful for understanding the rationale behind the condition. However, consider using a more descriptive comment that explains why multi-fields don't have a fallback synthetic source, as this could aid future maintainers in understanding the context better.\n\n5. **Potential Edge Cases**:\n   - Ensure that the `blContext.parentField(name())` method behaves as expected in all scenarios, especially in cases where the field might not exist or when dealing with complex mappings. It would be prudent to add unit tests that cover these edge cases to ensure robustness.\n\nIn summary, the changes made are logical and improve the code's handling of synthetic sources. Just ensure thorough testing around the new condition to avoid any edge cases that might arise.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 2,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/BooleanFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for the parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 351: The added condition `blContext.parentField(name()) == null` is a good safeguard against multi-fields having a fallback synthetic source. However, ensure that this logic aligns with the intended behavior of the application. If there are cases where a synthetic source should still be allowed even if `parentField` is not null, this could lead to unintended behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 350: The comment `// Multi fields don't have fallback synthetic source.` is helpful for understanding the rationale behind the condition. However, consider expanding it to explain why this is the case or under what circumstances this rule applies. This can aid future maintainers in understanding the context better.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext` and its method `parentField(name())` are well-defined and handle all expected cases. If `parentField` can return unexpected values or throw exceptions, consider adding error handling or assertions to manage those scenarios.\n\n4. **Performance Issues**:\n   - The performance impact of the additional condition is likely negligible, but if `parentField(name())` is a costly operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive addition, ensure that the logic aligns with the overall design and consider enhancing comments for clarity.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 3,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for multi fields that do not have a fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 949: The condition `isSyntheticSource && blContext.parentField(name()) == null` is a good addition, but it assumes that `blContext.parentField(name())` will return `null` for all multi fields. Ensure that this assumption holds true in all cases, as it could lead to unexpected behavior if there are edge cases where a parent field exists but is not properly recognized.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the condition is helpful for understanding the rationale behind the change. However, consider rephrasing it for clarity. For example, \"Check if the field is synthetic and ensure it does not belong to a multi-field context.\" This makes it clearer that the check is specifically about the context of multi-fields.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `blContext.parentField(name())` method is robust and handles all possible scenarios, including cases where the field name might not exist or where the context might be in an unexpected state. It would be beneficial to add unit tests that cover these edge cases to ensure the new logic behaves as expected.\n\n4. **Performance Issues**:\n   - There are no immediate performance issues with the change itself, but if `blContext.parentField(name())` is a costly operation, consider caching the result if it is called multiple times in the same context.\n\nIn summary, while the change is a positive step, ensure that the assumptions made about the context and the behavior of `blContext.parentField(name())` are thoroughly validated. Adding tests for edge cases will help solidify the reliability of this modification.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 4,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java",
          "content": "Overall, the code diff appears to be well-structured and addresses some clarity issues in comments and method implementations. However, there are a few points worth noting:\n\n1. **Comment Clarity**:\n   - **Line 318**: The comment has been improved for clarity, which is good. However, consider rephrasing \"consumers only ever read text from the parser\" to \"consumers are expected to only read text from the parser\" for better readability.\n\n2. **Method Override**:\n   - **Lines 332-335**: The addition of the `text()` method is a good enhancement, ensuring that the `value` is accessible through this method. Ensure that this method is adequately tested to confirm it behaves as expected in all scenarios.\n\n3. **Logical Condition**:\n   - **Line 546**: The condition `blContext.parentField(name()) == null` is a new addition that changes the logic of when to use the fallback synthetic source. Ensure that this condition is well understood and tested, as it could potentially lead to different behavior in cases where multi-fields are involved. It would be beneficial to add a comment explaining why this condition is necessary.\n\n4. **Performance Considerations**:\n   - The changes do not introduce any obvious performance issues, but ensure that the new method `text()` does not introduce any unnecessary overhead. Profiling may be necessary if this method is called frequently.\n\n5. **Edge Cases**:\n   - Ensure that the new logic in the block loader handles all edge cases, especially with multi-fields. It would be prudent to add unit tests that cover scenarios with and without doc values, as well as cases with multi-fields to ensure robustness.\n\nIn summary, while the changes are generally positive, attention should be paid to the new logical condition and ensuring comprehensive testing around it.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 5,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java",
          "content": "Overall Assessment:\nThe code change introduces a condition to check if the `blContext.parentField(name())` is `null` before proceeding with the fallback synthetic source. This is a reasonable modification to prevent unnecessary fallback for multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 468**: The comment added is helpful for understanding the context of the change. However, it could be more descriptive. Consider explaining why multi-fields don't have a fallback synthetic source, as this could aid future maintainers.\n\n2. **Line 469**: The condition `isSyntheticSource && blContext.parentField(name()) == null` is logically sound, but ensure that `blContext.parentField(name())` is not computationally expensive. If it involves a lookup or computation, it might be worth caching the result if this method is called frequently.\n\n3. **Edge Cases**: Ensure that the `blContext` is always valid and not `null` before calling `blContext.parentField(name())`. If there's a possibility that `blContext` could be `null`, it would lead to a `NullPointerException`. Adding a null check would enhance robustness.\n\n4. **Code Style**: The code adheres to standard Java conventions. However, consider using more descriptive variable names if `blContext` is not immediately clear to all readers. A more descriptive name could improve readability.\n\n5. **Testing**: Ensure that there are adequate unit tests covering this new condition. Specifically, tests should verify that the fallback synthetic source is not called for multi-fields and that the behavior is as expected when `blContext.parentField(name())` is `null`.\n\nIn summary, while the change is a positive improvement, consider enhancing documentation, checking for potential null values, and ensuring performance is not impacted by the new condition.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 6,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for a parent field in the context of synthetic sources. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 8: The comment states that \"Multi fields don't have fallback synthetic source.\" This could be misleading if not properly documented elsewhere. Ensure that the behavior of multi-fields is clearly defined in the documentation to avoid confusion for future maintainers.\n\n2. **Code Style and Best Practices**:\n   - Line 7: The comment could be more descriptive. Instead of just stating the fact, it could explain why this condition is necessary. For example, \"Check for parent field to prevent fallback synthetic source loading for multi-fields.\"\n\n3. **Potential Edge Cases**:\n   - Line 8: Consider what happens if `blContext.parentField(name())` returns an unexpected value (e.g., an object that is not null but not a valid parent field). It might be beneficial to add additional checks or logging to handle such cases gracefully.\n\n4. **Performance Issues**:\n   - There are no immediate performance issues in this diff, but ensure that the `parentField` method is efficient, as it will be called in this conditional check. If it involves complex logic or database calls, it could impact performance.\n\nIn summary, while the change is a positive step, enhancing the comments for clarity and considering edge cases would improve the code's maintainability and robustness.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 7,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement by adding a condition to check for multi-fields that do not have a fallback synthetic source. However, there are a few points to consider:\n\n1. **Logical Errors**:\n   - Line 1974: The added condition checks if `blContext.parentField(name())` is `null` to determine if the synthetic source should be used. Ensure that this logic aligns with the intended behavior of the application. If `parentField` can return a non-null value for valid cases, this could lead to unexpected behavior.\n\n2. **Code Style and Best Practices**:\n   - Line 1973: The comment added before the condition is helpful, but it could be more descriptive. Consider explaining why multi-fields do not have a fallback synthetic source, which would provide better context for future maintainers.\n\n3. **Potential Edge Cases**:\n   - The check for `isSyntheticSource` and `blContext.parentField(name()) == null` should be thoroughly tested to ensure that it covers all scenarios where a synthetic source might be expected. Consider edge cases where `blContext` might be in an unexpected state or where `name()` could lead to ambiguous results.\n\n4. **Performance Issues**:\n   - There are no apparent performance issues introduced by this change. However, if `parentField(name())` is a costly operation, consider caching its result if it is called multiple times in the same context.\n\nIn summary, while the change seems to improve the logic, ensure that the new condition is thoroughly tested and consider enhancing the comment for clarity.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 8,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be well-structured and introduces a new parameter to several methods to handle multifield adjustments for `GeoPoint` objects. However, there are a few areas that could be improved or warrant further consideration.\n\n### Specific Issues:\n\n1. **Line 35-36**: The switch statement for `nullValue` handling is clear, but consider adding a comment to explain the purpose of the `convert` method and the significance of the `false` parameter. This will improve code readability for future maintainers.\n\n2. **Line 67-68**: Similar to the previous point, adding a comment about why `exactValuesFromSource` is called with `false` for `needsMultifieldAdjustment` would enhance clarity.\n\n3. **Line 94**: The method `toWKB(normalize(convert(values, nullValue, false)))` could potentially throw a `NullPointerException` if `convert` returns `null`. Ensure that `normalize` can handle `null` gracefully, or add a check before calling `normalize`.\n\n4. **Line 168**: The `convert` method now has a new parameter, but the handling of `nullValue` could be clearer. The check for `nullValue` should be combined with the multifield adjustment logic to avoid returning `null` when `nullValue` is not `null`. This could lead to confusion.\n\n5. **Line 188-189**: The `GeoPoint` constructor is called multiple times with similar logic. Consider extracting this into a private method to reduce code duplication and improve maintainability.\n\n6. **Line 205-206**: The `possiblyAdjustMultifieldValue` method is a good addition, but ensure that the logic for resetting from a geohash is well-tested. If the geohash is malformed or invalid, it could lead to unexpected behavior. Consider adding error handling or validation.\n\n7. **Performance Consideration**: The use of streams and lambda expressions is generally good for readability, but if performance is a concern (especially with large lists), consider using traditional loops for better performance in critical sections.\n\n8. **Edge Cases**: Ensure that edge cases are handled, such as:\n   - What happens if `coordinates` in the GeoJSON representation are empty or have fewer than two elements?\n   - How does the code behave with malformed input strings for `GeoPoint`?\n\n### Conclusion:\nThe code changes are generally well-implemented, but there are areas for improvement in terms of clarity, error handling, and performance considerations. Addressing the above points will enhance the robustness and maintainability of the code.\n\n### Recommendation:\nConsider adding unit tests that cover edge cases and potential failure scenarios to ensure the new logic behaves as expected. \n\nOverall, the changes are promising, but attention to the mentioned details will improve the quality of the code.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 9,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/TextFieldWithParentBlockLoaderTests.java",
          "content": "Overall, the code diff shows a significant refactor of the `TextFieldWithParentBlockLoaderTests` class, transitioning from extending `BlockLoaderTestCase` to `MapperServiceTestCase`. The changes appear to enhance the test's structure and clarity, but there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 9-10**: The import statements for `DefaultMappingParametersHandler` have been removed. If this class is no longer used, it's fine, but ensure that any functionality it provided is adequately replaced or refactored.\n\n2. **Line 51-52**: The comment about the \"tricky meta-logic\" could be clearer. Consider rephrasing to explain why this logic is necessary for future maintainers.\n\n3. **Line 66**: The method `expected` is now private. If this method is intended to be used in subclasses or other test cases, consider changing it back to protected. If it is only used within this class, then it is fine as private.\n\n4. **Line 68**: The variable `normalizer` is retrieved but not used. If it is not needed, consider removing this line to avoid confusion.\n\n5. **Line 70**: The assertion `assert fieldMapping.containsKey(\"fields\");` could throw a `NullPointerException` if `fieldMapping` is null. Consider adding a null check before this assertion to prevent potential runtime exceptions.\n\n6. **Line 73**: The mapping retrieval for `textFieldMapping` assumes that the key \"mf\" will always exist. If it does not, this will lead to a `NullPointerException`. Consider adding a check to ensure that \"mf\" exists in the `fields` map before attempting to access it.\n\n7. **Line 75**: The method `TextFieldBlockLoaderTests.expectedValue` is called with `params` and `testContext`. Ensure that these parameters are valid and that `expectedValue` can handle any edge cases that might arise from them.\n\n### Performance Issues:\n- The use of `Map.of` creates immutable maps. If these maps are frequently created in a loop or high-frequency context, consider using mutable maps to avoid the overhead of creating new instances.\n\n### Code Style and Best Practices:\n- Consider adding JavaDoc comments to public methods and classes to improve code readability and maintainability.\n- Ensure consistent formatting, especially with spacing and indentation, to enhance readability.\n\n### Potential Edge Cases:\n- Ensure that the `DataSourceHandler` implementation can handle unexpected input gracefully. For example, if `request.fieldName()` returns a value that is not expected, the method should handle it without throwing exceptions.\n- Consider what happens if the `DataSourceResponse` does not return the expected mappings. Implement error handling to manage such cases.\n\nIn summary, while the refactor improves the structure of the test class, attention should be paid to potential null pointer exceptions, clarity in comments, and ensuring that all edge cases are handled appropriately.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 10,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DataSourceRequest.java",
          "content": "Overall Assessment:\nThe code diff introduces a new field `dataSource` to the `LeafMappingParametersGenerator` record. While the change appears straightforward, there are a few considerations to address regarding code style and potential implications of this addition.\n\nSpecific Issues:\n\n1. **Line 200**: The addition of the `dataSource` field should be accompanied by a comment explaining its purpose and how it will be used within the `LeafMappingParametersGenerator`. This will improve code readability and maintainability.\n\n2. **Line 200**: Ensure that the `DataSource` class is properly imported if it is not already. If the import is missing, it could lead to compilation errors.\n\n3. **Line 201**: Consider whether the `dataSource` field should be final. If it is intended to be immutable after the record is created, marking it as `final` would be a good practice.\n\n4. **Line 201**: If `DataSource` contains sensitive information or is mutable, consider the implications of exposing it in this record. If the `dataSource` is mutable, it could lead to unintended side effects if the state is changed after the record is created.\n\n5. **Documentation**: Update any relevant documentation or comments in the codebase to reflect the addition of the `dataSource` field, especially if it affects the behavior of the `LeafMappingParametersGenerator`.\n\n6. **Testing**: Ensure that there are corresponding unit tests that cover the new functionality introduced by the `dataSource` field. This will help catch any potential issues early.\n\nIn summary, while the change itself is not inherently problematic, attention to detail regarding documentation, immutability, and testing will enhance the quality of the code.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 11,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/datasource/DefaultMappingParametersHandler.java",
          "content": "Overall, the code diff shows a significant refactoring of the `DefaultMappingParametersHandler` class, with a focus on simplifying the mapping parameter generation. While the changes improve readability and reduce the number of parameters passed around, there are a few areas that warrant attention.\n\n### Specific Issues:\n\n1. **Line 36-38**: The removal of the `map` variable and the conditional addition of the `SYNTHETIC_SOURCE_KEEP_PARAM` could lead to a loss of functionality. If this parameter is necessary for certain mappings, its absence may cause issues in the generated mappings.\n\n2. **Line 70-72**: The `numberMapping` method now directly uses `commonMappingParameters()` to create a new mapping each time. If `commonMappingParameters()` is expensive to compute, this could lead to performance issues, especially if `numberMapping` is called frequently. Consider caching the result if the parameters do not change.\n\n3. **Line 92-94**: Similar to the previous point, the `keywordMapping` method creates a new mapping each time it is called. If `commonMappingParameters()` is costly, this could lead to performance degradation. Again, consider caching or reusing the mapping if possible.\n\n4. **Line 100-102**: The logic for injecting parameters into the mapping is now more streamlined, but ensure that the randomness introduced (e.g., `ESTestCase.randomDouble() <= 0.2`) does not lead to unexpected behavior in production. It might be beneficial to log or handle cases where certain parameters are not set due to randomness.\n\n5. **Line 169-171**: The `booleanMapping` method has been simplified, but ensure that the randomness does not lead to a situation where critical parameters are omitted. Consider adding validation to ensure that the generated mapping meets the expected schema.\n\n6. **Line 177-179**: The `dateMapping` method also follows the same pattern of creating a new mapping each time. Again, consider the performance implications of this change.\n\n### Code Style and Best Practices:\n\n- **Consistency**: The code has been made more consistent in terms of how mappings are generated. However, ensure that all methods that generate mappings follow the same pattern for clarity and maintainability.\n\n- **Documentation**: Consider adding comments to explain the purpose of each mapping method, especially since the logic has been abstracted away. This will help future maintainers understand the intent behind the changes.\n\n### Potential Edge Cases:\n\n- **Randomness**: The use of randomness in generating mapping parameters could lead to edge cases where certain expected parameters are not included. Ensure that there are sufficient tests to cover these scenarios.\n\n- **Null Handling**: Ensure that the generated mappings handle null values appropriately, especially since the code introduces randomness in setting `null_value`. This could lead to unexpected behavior if not handled correctly.\n\nIn summary, while the refactoring improves readability and reduces parameter passing, attention should be paid to performance implications, potential loss of functionality, and the handling of randomness in mapping generation. Consider adding tests to cover edge cases introduced by the changes.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 12,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/datageneration/MappingGenerator.java",
          "content": "Overall Assessment: The code diff shows a minor modification where an additional parameter is passed to the `LeafMappingParametersGenerator` constructor. While the change itself does not introduce any obvious bugs or performance issues, it is important to ensure that the new parameter is necessary and correctly utilized.\n\n1. **Bugs or Logical Errors**:\n   - Line 105: Ensure that `specification.dataSource()` is not null before passing it to the `LeafMappingParametersGenerator`. If it is null, it could lead to a `NullPointerException`.\n\n2. **Performance Issues**:\n   - No performance issues are evident in this change. However, if `specification.dataSource()` involves heavy computation or resource allocation, consider caching its result if it is called multiple times.\n\n3. **Security Vulnerabilities**:\n   - No security vulnerabilities are apparent in this diff. However, ensure that the data source being passed does not expose sensitive information or allow for injection attacks.\n\n4. **Code Style and Best Practices**:\n   - The code style appears consistent with Java conventions. However, consider adding a comment explaining why `specification.dataSource()` is being passed to improve code readability for future maintainers.\n\n5. **Potential Edge Cases**:\n   - Line 105: Consider what happens if `context.eligibleCopyToDestinations()` returns an empty list or null. Ensure that the downstream code can handle such cases gracefully.\n\nIn summary, while the change itself is straightforward, it is crucial to validate the inputs and consider potential edge cases to ensure robustness.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 13,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestCase.java",
          "content": "Overall, the code diff shows a significant refactor of the `BlockLoaderTestCase` class, with a focus on improving the handling of data source handlers and the generation of mappings and documents. The changes appear to enhance the structure and readability of the code. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Unused Imports**:\n   - Lines 4-10: Several imports have been removed, which is good for cleanliness. However, ensure that any remaining imports are necessary. If there are any unused imports left, they should be removed to maintain code clarity.\n\n2. **Variable Naming**:\n   - Line 27: The variable `customDataSourceHandlers` is well-named, but consider renaming `customHandlers` in the `buildSpecification` method to maintain consistency. Using `customDataSourceHandlers` throughout would improve clarity.\n\n3. **Error Handling**:\n   - Lines 82-83 and 118-119: The `runTest` method calls do not seem to handle potential exceptions that could arise from `createSytheticSourceMapperService` or `createMapperService`. Consider adding try-catch blocks to handle `IOException` or other relevant exceptions gracefully.\n\n4. **Test Context Initialization**:\n   - Lines 118-120: The `TestContext` is initialized with `false` for `isMultifield` in multiple places. If this is a common case, consider creating a method or a constant to avoid magic values and improve readability.\n\n5. **Potential Null Pointer Exceptions**:\n   - Lines 114 and 140: The calls to `mapping.lookup().get(fieldName)` and `mapping.lookup().get(fullFieldName.toString())` could potentially return `null`. Ensure that there is a check for null values before using them to avoid `NullPointerException`.\n\n6. **Performance Considerations**:\n   - The creation of `MappingGenerator` and `DocumentGenerator` in the `testBlockLoader` and `testBlockLoaderForFieldInObject` methods could be optimized if they are reused. If the specifications do not change, consider initializing them once and reusing them to avoid unnecessary object creation.\n\n7. **Code Duplication**:\n   - The logic for creating `mappingXContent` and `mapperService` is duplicated in both `testBlockLoader` and `testBlockLoaderForFieldInObject`. Consider extracting this logic into a separate method to reduce duplication and improve maintainability.\n\n### Conclusion:\nThe refactor improves the structure and readability of the code, but attention should be paid to error handling, potential null pointer exceptions, and code duplication. Addressing these issues will enhance the robustness and maintainability of the code.\n\nOverall, the changes are positive, but the above points should be considered for further improvement.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 14,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "test/framework/src/main/java/org/elasticsearch/index/mapper/BlockLoaderTestRunner.java",
          "content": "Overall, the code appears to be well-structured and follows good practices for unit testing in Java, particularly in the context of Elasticsearch. However, there are a few areas that could be improved or warrant further attention.\n\n### Specific Issues:\n\n1. **Error Handling (Line 66)**:\n   - The method `setupAndInvokeBlockLoader` does not handle potential exceptions that may arise from `iw.addDocument(doc);`. If an exception occurs here, it will propagate up without any context. Consider adding logging or handling specific exceptions to provide more insight into failures.\n\n2. **Resource Management (Lines 66-67)**:\n   - The `RandomIndexWriter` is closed immediately after adding a document. If an exception occurs before the `iw.close()` line, the writer may not be closed properly. Consider using a try-with-resources statement for `RandomIndexWriter` to ensure it is always closed.\n\n3. **Null Checks (Line 92)**:\n   - The method `load` assumes that `columnAtATimeReader` will not be null after the check. If it is null, the method will proceed to the next block of code, which may lead to a `NullPointerException`. Consider adding a null check and handling this case appropriately.\n\n4. **Performance Considerations (Line 118)**:\n   - The method `load` creates a new `BlockLoaderStoredFieldsFromLeafLoader` every time it is called. If this method is called frequently, it could lead to performance issues. Consider caching or reusing instances where possible.\n\n5. **Code Style (Line 36)**:\n   - The method `runTest` uses `var` for variable declaration. While this is valid in Java, it may reduce readability for some developers. Consider using explicit types for clarity, especially in public methods.\n\n6. **Potential Edge Cases (Line 118)**:\n   - The method `load` does not handle the case where `storedFieldsSpec` might be null after the merge operation. Ensure that this is checked before proceeding to use it.\n\n7. **Documentation**:\n   - The class and methods lack JavaDoc comments. Adding documentation would improve maintainability and help other developers understand the purpose and usage of the class and its methods.\n\n### Summary:\nWhile the code is generally well-implemented, addressing the above points will enhance its robustness, maintainability, and performance. Consider implementing the suggested changes to improve the overall quality of the code.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 15,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/mapper-aggregate-metric/src/test/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateMetricDoubleFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be a straightforward addition of a test method that indicates a no-operation (noop) for multi-fields in the `AggregateMetricDoubleFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Test Method Implementation**:\n   - **Line 36**: The newly added test method `testBlockLoaderOfMultiField` is currently empty except for a comment. While it is acceptable to have a placeholder for a test, it is generally better to include at least a simple assertion or a `fail()` statement to indicate that the test is intentionally not implemented yet. This helps in identifying unimplemented tests during test runs.\n\n2. **Comment Clarity**:\n   - **Line 37**: The comment `// Multi fields are noop for aggregate_metric_double.` could be expanded for clarity. It might be beneficial to explain why multi-fields are a no-op in this context, especially for future maintainers who may not be familiar with the specifics of the `aggregate_metric_double` functionality.\n\n3. **Code Style**:\n   - The code style appears consistent with Java conventions. However, ensure that the rest of the class follows the same formatting and naming conventions for consistency.\n\n4. **Potential Edge Cases**:\n   - While the method is a no-op, consider documenting any edge cases that might arise when multi-fields are involved, even if they are not applicable in this specific implementation. This can help future developers understand the implications of this design choice.\n\nIn summary, while the addition is simple and does not introduce any bugs or performance issues, enhancing the test method with assertions and improving comment clarity would be beneficial for maintainability and understanding.\n\n### Suggested Changes:\n- Add an assertion or a `fail()` statement in `testBlockLoaderOfMultiField`.\n- Expand the comment to provide more context about why multi-fields are a no-op.\n\nOverall, the code is on the right track but could use some minor improvements for clarity and completeness.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 16,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/mapper-constant-keyword/src/test/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldBlockLoaderTests.java",
          "content": "Overall Assessment:\nThe code diff appears to be a straightforward addition of a method to handle multi-fields in the `ConstantKeywordFieldBlockLoaderTests` class. The implementation is a no-op, which is appropriate given the context. However, there are a few points worth noting regarding code style and best practices.\n\nSpecific Issues:\n\n1. **Line 24**: The method `testBlockLoaderOfMultiField` is marked as `throws IOException`, but it does not contain any code that could throw this exception. If the method is intended to be a no-op, consider removing the `throws IOException` declaration to avoid confusion.\n\n2. **Line 25**: The comment `// Multi fields are noop for constant_keyword.` is clear, but it could be more informative. Consider expanding it to explain why multi-fields are a no-op for `constant_keyword`, which could help future maintainers understand the rationale behind this implementation.\n\n3. **Code Style**: Ensure that the comment style is consistent with the rest of the codebase. If other comments use a specific format (e.g., Javadoc style), it might be beneficial to follow that convention for consistency.\n\n4. **Test Coverage**: While the method is a no-op, it might be useful to include a test case that explicitly verifies that multi-fields do not affect the behavior of the `ConstantKeywordFieldBlockLoader`. This could help ensure that future changes do not inadvertently alter this behavior.\n\n5. **Documentation**: If this is part of a larger framework or library, consider documenting this behavior in the relevant documentation to inform users about the handling of multi-fields with `constant_keyword`.\n\nIn summary, while the code change is simple and seems appropriate, addressing the points above could improve clarity and maintainability.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 17,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java",
          "content": "Overall, the code diff appears to be a logical improvement, adding a condition to check for a parent field before allowing the fallback synthetic source. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - Line 380: The added condition `blContext.parentField(name()) == null` is a good safeguard against multi-fields having a fallback synthetic source. However, ensure that this logic aligns with the intended behavior of the application. If there are cases where a synthetic source should be allowed even with a parent field, this could lead to unexpected behavior.\n\n2. **Code Style and Best Practices**:\n   - The comment added before the new condition is helpful for understanding the rationale behind the change. However, consider using a more descriptive comment that explains why multi-fields should not have a fallback synthetic source. This can help future maintainers understand the context better.\n\n3. **Potential Edge Cases**:\n   - Ensure that the `parentField(name())` method behaves as expected in all scenarios. If there are edge cases where this method could return unexpected results (e.g., if `name()` is not properly defined or if there are issues with the context), it could lead to bugs.\n\n4. **Performance Issues**:\n   - The performance impact of the additional check is likely negligible, but it\u2019s worth profiling if this method is called frequently in performance-critical paths. If `parentField(name())` is an expensive operation, consider caching its result if it is called multiple times.\n\nIn summary, while the change seems to improve the logic, ensure that the new condition aligns with the overall design and intended functionality of the system. Additionally, consider enhancing the comment for clarity.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 18,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java",
          "content": "Overall Assessment:\nThe code diff introduces a condition to check if the `blContext.parentField(name())` is null before proceeding with the fallback synthetic source logic. This change appears to be a safeguard against multi-fields, which is a good addition. However, there are a few points to consider for clarity and potential edge cases.\n\nSpecific Issues:\n\n1. **Line 4**: The comment `// Multi fields don't have fallback synthetic source.` is helpful, but it could be more descriptive. Consider explaining why multi-fields don't have a fallback synthetic source and what implications this has for the logic. This will aid future maintainers in understanding the rationale behind the condition.\n\n2. **Line 5**: The condition `blContext.parentField(name()) == null` is a good check, but it would be beneficial to ensure that `name()` is not returning a null value itself. If `name()` can potentially return null, it could lead to a `NullPointerException`. Consider adding a null check for `name()` before this condition.\n\n3. **Performance Consideration**: If `blContext.parentField(name())` is an expensive operation, it might be worth caching the result in a local variable before the condition check. This would prevent multiple calls to the same method if the condition is used in more complex logic later.\n\n4. **Edge Cases**: Ensure that the logic correctly handles cases where `blContext` might be in an unexpected state. For example, if `blContext` is null or improperly initialized, it could lead to runtime exceptions. Consider adding checks or assertions to validate the state of `blContext` before using it.\n\n5. **Code Style**: The formatting and indentation are consistent, which is good. However, consider using more descriptive variable names if applicable, as it can improve readability. For instance, `blContext` could be expanded to something like `blockLoaderContext` for clarity, depending on the conventions used in the codebase.\n\nIn summary, while the change is a positive addition, addressing the above points will enhance the robustness and maintainability of the code.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 19,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldMapper.java",
          "content": "Overall Assessment:\nThe code change introduces a condition to check if the `blContext.parentField(name())` is `null` before calling `blockLoaderFromFallbackSyntheticSource(blContext)`. This is a reasonable modification to prevent unnecessary calls when dealing with multi-fields. However, there are a few considerations to address.\n\nSpecific Issues:\n\n1. **Line 201**: The comment added before the condition is helpful for understanding the context. However, it could be more descriptive. Consider rephrasing it to clarify why multi-fields don't have a fallback synthetic source, which would enhance maintainability.\n\n2. **Line 202**: The new condition checks for `blContext.parentField(name()) == null`, which is a good addition. However, ensure that this check is sufficient for all cases where a synthetic source might be expected. It would be beneficial to add a comment explaining the implications of this check, especially for future maintainers.\n\n3. **Performance Consideration**: If `blContext.parentField(name())` involves a non-trivial computation or lookup, consider caching the result if it is used multiple times in the method. This would improve performance, especially if this method is called frequently.\n\n4. **Edge Cases**: Ensure that there are no edge cases where `isSyntheticSource` could be true, but `blContext.parentField(name())` is not `null`, leading to unexpected behavior. It might be worth adding unit tests to cover scenarios involving multi-fields and synthetic sources to validate the new logic.\n\n5. **Code Style**: The code adheres to standard Java conventions. However, ensure that the surrounding code is also well-documented, especially if this method is part of a larger class with complex logic.\n\nIn summary, while the change is a positive improvement, consider enhancing comments for clarity, reviewing performance implications, and ensuring comprehensive testing for edge cases.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 20,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeFieldBlockLoaderTests.java",
          "content": "Overall, the code diff looks good and appears to be a straightforward addition of a method to handle multi-fields for the `GeoShapeFieldBlockLoaderTests` class. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 36**: The `testBlockLoaderOfMultiField` method is currently a placeholder with a comment indicating that multi-fields are no-ops for `geo_shape`. While this is acceptable for a test method, it would be beneficial to include a simple assertion or log statement to confirm that the method is being called during tests. This can help ensure that the test framework recognizes the method and that it is executed as part of the test suite.\n\n2. **Comment Clarity**:\n   - **Line 37**: The comment \"// Multi fields are noop for geo_shape.\" could be expanded for clarity. Consider rephrasing it to explain why multi-fields are no-ops for `geo_shape`, which could be helpful for future maintainers or reviewers who may not be familiar with the context.\n\n3. **Exception Handling**:\n   - **Line 36**: The method signature declares that it throws `IOException`, but since the method body is empty, it may be misleading. If the method is intended to be a no-op, consider removing the `throws IOException` declaration unless you plan to implement logic that could throw this exception in the future.\n\n4. **Code Style**:\n   - The code adheres to standard Java conventions, but ensure that the rest of the class maintains consistent formatting and style, especially regarding comments and method documentation.\n\n5. **Potential Edge Cases**:\n   - Since this method is a no-op, there are no immediate edge cases to consider. However, if future implementations are planned, consider how the method might handle unexpected input or states.\n\nIn summary, while the changes are minimal and mostly correct, enhancing the clarity of comments and ensuring the method's purpose is clear would improve the overall quality of the code. \n\n**Actionable Feedback**:\n- Add a simple assertion or log statement in `testBlockLoaderOfMultiField`.\n- Expand the comment for clarity.\n- Consider removing the `throws IOException` declaration if the method remains a no-op.\n\nOverall, the changes are on the right track, but a few improvements could enhance maintainability and clarity.",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 21,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be a straightforward addition of a method that overrides an existing method in the `PointFieldBlockLoaderTests` class. The new method is a placeholder indicating that multi-fields are a no-op for point types. Here are some specific points to consider:\n\n1. **Bugs or Logical Errors**: \n   - There are no apparent bugs or logical errors in the new method. It correctly indicates that multi-fields are a no-op for point types.\n\n2. **Performance Issues**: \n   - There are no performance issues introduced by this change. The method is a simple override with no additional processing.\n\n3. **Security Vulnerabilities**: \n   - There are no security vulnerabilities present in this diff. The method does not expose any sensitive data or perform any operations that could lead to security issues.\n\n4. **Code Style and Best Practices**: \n   - The code adheres to standard Java conventions. The method is clearly named and the comment succinctly explains its purpose. However, consider adding a `@Override` annotation to the method for clarity, which is already present in the diff.\n\n5. **Potential Edge Cases**: \n   - Since the method is a no-op, there are no edge cases to consider in this context. However, it might be beneficial to ensure that any tests that rely on this behavior are properly documented or that there are assertions in place to confirm that multi-fields are indeed treated as no-ops.\n\nIn summary, the addition is clear and serves its purpose well. \n\n**LGTM! (Looks Good To Me)**",
          "created_at": "2025-04-29T01:06:50"
        },
        {
          "id": 22,
          "review_id": 1,
          "pr_id": 2487052561,
          "filename": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/ShapeFieldBlockLoaderTests.java",
          "content": "Overall, the code diff appears to be straightforward, with the addition of a method that overrides a test case for multi-fields in the `ShapeFieldBlockLoaderTests` class. The implementation seems to be a placeholder indicating that multi-fields are a no-op for shape. However, there are a few points worth noting:\n\n1. **Method Implementation**:\n   - **Line 35**: The method `testBlockLoaderOfMultiField()` is currently empty except for a comment. While it's acceptable to have a no-op test, it might be beneficial to include a simple assertion or log a message to indicate that this test is intentionally skipped. This can help future maintainers understand the purpose of the method without needing to read the comment.\n\n2. **Comment Clarity**:\n   - **Line 36**: The comment `// Multi fields are noop for shape.` could be expanded for clarity. It might be helpful to explain why multi-fields are a no-op for shape, or under what circumstances this behavior is expected. This would provide better context for future developers who may work on this code.\n\n3. **Code Style**:\n   - The code style is consistent with Java conventions. However, ensure that the project follows a specific style guide (e.g., Google Java Style Guide) for consistency across the codebase.\n\n4. **Edge Cases**:\n   - While the current implementation is a no-op, consider whether there are any edge cases that should be documented or tested in the future. For example, if the behavior of multi-fields changes, it might be necessary to revisit this test.\n\n5. **Exception Handling**:\n   - The method signature includes `throws IOException`, but since the method body does not perform any operations that could throw this exception, it may be unnecessary. If the method is intended to remain a no-op, consider removing the `throws IOException` declaration.\n\nIn summary, while the code is functional, enhancing the clarity of the comment and considering future maintainability could improve the overall quality of the test. \n\n**Specific Issues**:\n- **Line 35**: Consider adding an assertion or log message to clarify the purpose of the no-op test.\n- **Line 36**: Expand the comment for better clarity on why multi-fields are a no-op.\n- **Line 35**: Evaluate the necessity of `throws IOException` in the method signature.\n\nOverall, the changes are minor, but addressing them could improve code maintainability and clarity.",
          "created_at": "2025-04-29T01:06:50"
        }
      ]
    }
  ]
}