{
  "id": 2485565973,
  "repo_owner": "elastic",
  "repo_name": "elasticsearch",
  "number": 127458,
  "title": "[Failure Store] Fix resolved alias retrieval for failure indices",
  "created_at": "2025-04-28T11:26:46",
  "updated_at": "2025-04-28T22:54:55",
  "state": "open",
  "user_login": "gmarouli",
  "diffs": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java\nindex 6b9315cd40157..95936f3ee9caf 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java\n@@ -25,7 +25,6 @@\n import org.elasticsearch.cluster.routing.ShardIterator;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.service.ClusterService;\n-import org.elasticsearch.core.Predicates;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.injection.guice.Inject;\n@@ -105,14 +104,7 @@ protected void masterOperation(\n         Set<ResolvedExpression> indicesAndAliases = indexNameExpressionResolver.resolveExpressions(project.metadata(), request.indices());\n         for (String index : concreteIndices) {\n             final AliasFilter aliasFilter = indicesService.buildAliasFilter(project, index, indicesAndAliases);\n-            final String[] aliases = indexNameExpressionResolver.indexAliases(\n-                project.metadata(),\n-                index,\n-                Predicates.always(),\n-                Predicates.always(),\n-                true,\n-                indicesAndAliases\n-            );\n+            final String[] aliases = indexNameExpressionResolver.allIndexAliases(project.metadata(), index, indicesAndAliases);\n             indicesAndFilters.put(index, AliasFilter.of(aliasFilter.getQueryBuilder(), aliases));\n         }\n \ndiff --git a/server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java b/server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java\nindex 2b13ac7bd2ae0..21eeaedb7ea54 100644\n--- a/server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java\n@@ -62,7 +62,6 @@\n import org.elasticsearch.common.util.Maps;\n import org.elasticsearch.common.util.concurrent.CountDown;\n import org.elasticsearch.common.util.concurrent.EsExecutors;\n-import org.elasticsearch.core.Predicates;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.IndexNotFoundException;\n@@ -232,14 +231,7 @@ private Map<String, OriginalIndices> buildPerIndexOriginalIndices(\n                 blocks.indexBlockedRaiseException(projectState.projectId(), ClusterBlockLevel.READ, index);\n             }\n \n-            String[] aliases = indexNameExpressionResolver.indexAliases(\n-                projectState.metadata(),\n-                index,\n-                Predicates.always(),\n-                Predicates.always(),\n-                true,\n-                indicesAndAliases\n-            );\n+            String[] aliases = indexNameExpressionResolver.allIndexAliases(projectState.metadata(), index, indicesAndAliases);\n             String[] finalIndices = Strings.EMPTY_ARRAY;\n             if (aliases == null\n                 || aliases.length == 0\ndiff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\nindex 5b6a5dc08adad..267b6bec14dce 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n@@ -59,6 +59,7 @@\n import java.util.Set;\n import java.util.SortedMap;\n import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n import java.util.function.Function;\n import java.util.function.LongSupplier;\n import java.util.function.Predicate;\n@@ -80,6 +81,13 @@ public class IndexNameExpressionResolver {\n     public static final String EXCLUDED_DATA_STREAMS_KEY = \"es.excluded_ds\";\n     public static final IndexVersion SYSTEM_INDEX_ENFORCEMENT_INDEX_VERSION = IndexVersions.V_8_0_0;\n \n+    private static final BiPredicate<DataStreamAlias, Boolean> ALL_DATA_STREAM_ALIASES = (ignoredAlias, ignoredIsData) -> true;\n+    // Alias filters are not applied against indices in an abstraction's failure component.\n+    // They do not match the mapping of the data stream nor are the documents mapped for searching.\n+    private static final BiPredicate<DataStreamAlias, Boolean> ONLY_FILTERING_DATA_STREAM_ALIASES = (\n+        dataStreamAlias,\n+        isData) -> dataStreamAlias.filteringRequired() && isData;\n+\n     private final ThreadContext threadContext;\n     private final SystemIndices systemIndices;\n     private final ProjectResolver projectResolver;\n@@ -1054,12 +1062,21 @@ public String[] filteringAliases(ProjectMetadata project, String index, Set<Reso\n             project,\n             index,\n             AliasMetadata::filteringRequired,\n-            DataStreamAlias::filteringRequired,\n+            ONLY_FILTERING_DATA_STREAM_ALIASES,\n             false,\n             resolvedExpressions\n         );\n     }\n \n+    /**\n+     * Iterates through the list of indices and selects the effective list of all aliases for the\n+     * given index. Aliases are returned even if the index is included in the resolved expressions.\n+     * <b>NOTE</b>: The provided expressions must have been resolved already via {@link #resolveExpressions}.\n+     */\n+    public String[] allIndexAliases(ProjectMetadata project, String index, Set<ResolvedExpression> resolvedExpressions) {\n+        return indexAliases(project, index, Predicates.always(), ALL_DATA_STREAM_ALIASES, true, resolvedExpressions);\n+    }\n+\n     /**\n      * Whether to generate the candidate set from index aliases, or from the set of resolved expressions.\n      * @param indexAliasesSize        the number of aliases of the index\n@@ -1080,7 +1097,7 @@ public String[] indexAliases(\n         ProjectMetadata project,\n         String index,\n         Predicate<AliasMetadata> requiredAlias,\n-        Predicate<DataStreamAlias> requiredDataStreamAlias,\n+        BiPredicate<DataStreamAlias, Boolean> requiredDataStreamAlias,\n         boolean skipIdentity,\n         Set<ResolvedExpression> resolvedExpressions\n     ) {\n@@ -1107,13 +1124,8 @@ public String[] indexAliases(\n         IndexAbstraction ia = project.getIndicesLookup().get(index);\n         DataStream dataStream = ia.getParentDataStream();\n         if (dataStream != null) {\n-            if (dataStream.getFailureComponent().containsIndex(index)) {\n-                // Alias filters are not applied against indices in an abstraction's failure component.\n-                // They do not match the mapping of the data stream nor are the documents mapped for searching.\n-                return null;\n-            }\n-\n-            if (skipIdentity == false && resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStream.getName())) {\n+            boolean isData = dataStream.isFailureStoreIndex(index) == false;\n+            if (skipIdentity == false && resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStream.getName(), isData)) {\n                 // skip the filters when the request targets the data stream name + selector directly\n                 return null;\n             }\n@@ -1122,12 +1134,14 @@ public String[] indexAliases(\n             if (iterateIndexAliases(dataStreamAliases.size(), resolvedExpressions.size())) {\n                 aliasesForDataStream = dataStreamAliases.values()\n                     .stream()\n-                    .filter(dataStreamAlias -> resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStreamAlias.getName()))\n+                    .filter(\n+                        dataStreamAlias -> resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStreamAlias.getName(), isData)\n+                    )\n                     .filter(dataStreamAlias -> dataStreamAlias.getDataStreams().contains(dataStream.getName()))\n                     .toList();\n             } else {\n                 aliasesForDataStream = resolvedExpressions.stream()\n-                    .filter(expression -> expression.selector() == null || expression.selector().shouldIncludeData())\n+                    .filter(expression -> (expression.selector() == null || expression.selector().shouldIncludeData()) == isData)\n                     .map(ResolvedExpression::resource)\n                     .map(dataStreamAliases::get)\n                     .filter(dataStreamAlias -> dataStreamAlias != null && dataStreamAlias.getDataStreams().contains(dataStream.getName()))\n@@ -1136,11 +1150,12 @@ public String[] indexAliases(\n \n             List<String> requiredAliases = null;\n             for (DataStreamAlias dataStreamAlias : aliasesForDataStream) {\n-                if (requiredDataStreamAlias.test(dataStreamAlias)) {\n+                if (requiredDataStreamAlias.test(dataStreamAlias, isData)) {\n                     if (requiredAliases == null) {\n                         requiredAliases = new ArrayList<>(aliasesForDataStream.size());\n                     }\n-                    requiredAliases.add(dataStreamAlias.getName());\n+                    String alias = isData ? dataStreamAlias.getName() : dataStreamAlias.getName() + \"::failures\";\n+                    requiredAliases.add(alias);\n                 } else {\n                     // we have a non-required alias for this data stream so no need to check further\n                     return null;\n@@ -1162,7 +1177,7 @@ public String[] indexAliases(\n                 // Indices can only be referenced with a data selector, or a null selector if selectors are disabled\n                 for (AliasMetadata aliasMetadata : indexAliases.values()) {\n                     var alias = aliasMetadata.alias();\n-                    if (resolvedExpressionsContainsAbstraction(resolvedExpressions, alias)) {\n+                    if (resolvedExpressionsContainsAbstraction(resolvedExpressions, alias, true)) {\n                         if (requiredAlias.test(aliasMetadata) == false) {\n                             return null;\n                         }\n@@ -1185,9 +1200,16 @@ public String[] indexAliases(\n         }\n     }\n \n-    private static boolean resolvedExpressionsContainsAbstraction(Set<ResolvedExpression> resolvedExpressions, String abstractionName) {\n-        return resolvedExpressions.contains(new ResolvedExpression(abstractionName))\n-            || resolvedExpressions.contains(new ResolvedExpression(abstractionName, IndexComponentSelector.DATA));\n+    private static boolean resolvedExpressionsContainsAbstraction(\n+        Set<ResolvedExpression> resolvedExpressions,\n+        String abstractionName,\n+        boolean isData\n+    ) {\n+        if (isData) {\n+            return resolvedExpressions.contains(new ResolvedExpression(abstractionName))\n+                || resolvedExpressions.contains(new ResolvedExpression(abstractionName, IndexComponentSelector.DATA));\n+        }\n+        return resolvedExpressions.contains(new ResolvedExpression(abstractionName, IndexComponentSelector.FAILURES));\n     }\n \n     /**\ndiff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\nindex 8ef2205f2c127..4915f55b0405e 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\n@@ -1668,7 +1668,7 @@ public void testIndexAliases() {\n             .build();\n         Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"test-*\");\n \n-        String[] strings = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, true, resolvedExpressions);\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(project, \"test-0\", resolvedExpressions);\n         Arrays.sort(strings);\n         assertArrayEquals(new String[] { \"test-alias-0\", \"test-alias-1\", \"test-alias-non-filtering\" }, strings);\n \n@@ -1676,7 +1676,7 @@ public void testIndexAliases() {\n             project,\n             \"test-0\",\n             x -> x.alias().equals(\"test-alias-1\"),\n-            x -> false,\n+            (x, y) -> randomBoolean(),\n             true,\n             resolvedExpressions\n         );\n@@ -1700,52 +1700,52 @@ public void testIndexAliasesDataStreamAliases() {\n         projectBuilder.put(\"logs_baz2\", dataStreamName2, null, null);\n         ProjectMetadata project = projectBuilder.build();\n         {\n-            // Only resolve aliases with with that refer to dataStreamName1\n+            // Only resolve aliases that refer to dataStreamName1\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex1.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(project, index, x -> true, x -> true, true, resolvedExpressions);\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n             assertThat(result, arrayContainingInAnyOrder(\"logs_foo\", \"logs\", \"logs_bar\"));\n         }\n         {\n-            // Only resolve aliases with with that refer to dataStreamName2\n+            // Only resolve aliases that refer to dataStreamName2\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex2.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(project, index, x -> true, x -> true, true, resolvedExpressions);\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n             assertThat(result, arrayContainingInAnyOrder(\"logs_baz\", \"logs_baz2\"));\n         }\n         {\n             // Null is returned, because skipping identity check and resolvedExpressions contains the backing index name\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex2.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(project, index, x -> true, x -> true, false, resolvedExpressions);\n+            String[] result = indexNameExpressionResolver.indexAliases(\n+                project,\n+                index,\n+                x -> randomBoolean(),\n+                (x, y) -> true,\n+                false,\n+                resolvedExpressions\n+            );\n             assertThat(result, nullValue());\n         }\n         {\n             // Null is returned, because the wildcard expands to a list of aliases containing an unfiltered alias for dataStreamName1\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex1.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(\n-                project,\n-                index,\n-                x -> true,\n-                DataStreamAlias::filteringRequired,\n-                true,\n-                resolvedExpressions\n-            );\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n             assertThat(result, nullValue());\n         }\n         {\n             // Null is returned, because an unfiltered alias is targeting the same data stream\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"logs_bar\", \"logs\");\n             String index = backingIndex1.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(\n-                project,\n-                index,\n-                x -> true,\n-                DataStreamAlias::filteringRequired,\n-                true,\n-                resolvedExpressions\n-            );\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n+        {\n+            // Null is returned because we target the data stream name and skipIdentity is false\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, dataStreamName1, \"logs\");\n+            String index = backingIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n             assertThat(result, nullValue());\n         }\n         {\n@@ -1756,26 +1756,74 @@ public void testIndexAliasesDataStreamAliases() {\n                 project,\n                 index,\n                 x -> true,\n-                DataStreamAlias::filteringRequired,\n+                (alias, isData) -> alias.filteringRequired() && isData,\n                 true,\n                 resolvedExpressions\n             );\n             assertThat(result, arrayContainingInAnyOrder(\"logs\"));\n         }\n+    }\n+\n+    public void testIndexAliasesDataStreamFailureStoreAndAliases() {\n+        final String dataStreamName1 = \"logs-foobar\";\n+        final String dataStreamName2 = \"logs-barbaz\";\n+        IndexMetadata backingIndex1 = createBackingIndex(dataStreamName1, 1).build();\n+        IndexMetadata failureIndex1 = createFailureStore(dataStreamName1, 2).build();\n+        IndexMetadata backingIndex2 = createBackingIndex(dataStreamName2, 1).build();\n+        ProjectMetadata.Builder projectBuilder = ProjectMetadata.builder(Metadata.DEFAULT_PROJECT_ID)\n+            .put(backingIndex1, false)\n+            .put(backingIndex2, false)\n+            .put(failureIndex1, false)\n+            .put(newInstance(dataStreamName1, List.of(backingIndex1.getIndex()), List.of(failureIndex1.getIndex())))\n+            .put(newInstance(dataStreamName2, List.of(backingIndex2.getIndex())));\n+        projectBuilder.put(\"logs_foo\", dataStreamName1, null, \"{ \\\"term\\\": \\\"foo\\\"}\");\n+        projectBuilder.put(\"logs\", dataStreamName1, null, \"{ \\\"term\\\": \\\"logs\\\"}\");\n+        projectBuilder.put(\"logs_bar\", dataStreamName1, null, null);\n+        projectBuilder.put(\"logs_baz\", dataStreamName2, null, \"{ \\\"term\\\": \\\"logs\\\"}\");\n+        projectBuilder.put(\"logs_baz2\", dataStreamName2, null, null);\n+        ProjectMetadata project = projectBuilder.build();\n         {\n-            // Null is returned because we target the data stream name and skipIdentity is false\n-            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, dataStreamName1, \"logs\");\n-            String index = backingIndex1.getIndex().getName();\n+            // Resolving the failure component with a backing index should return null\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = randomBoolean() ? backingIndex1.getIndex().getName() : backingIndex2.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n+        {\n+            // Only resolve aliases that refer to dataStreamName1 failure store\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = failureIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n+            assertThat(result, arrayContainingInAnyOrder(\"logs_foo::failures\", \"logs::failures\", \"logs_bar::failures\"));\n+        }\n+        {\n+            // Null is returned, because we perform the identity check and resolvedExpressions contains the failure index name\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = failureIndex1.getIndex().getName();\n             String[] result = indexNameExpressionResolver.indexAliases(\n                 project,\n                 index,\n                 x -> true,\n-                DataStreamAlias::filteringRequired,\n+                (x, y) -> true,\n                 false,\n                 resolvedExpressions\n             );\n             assertThat(result, nullValue());\n         }\n+        {\n+            // Null is returned, because the wildcard expands to a list of aliases containing an unfiltered alias for dataStreamName1\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = failureIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n+        {\n+            // Null is returned because we target the failure store of the data stream\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"logs::failures\");\n+            String index = failureIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n     }\n \n     public void testIndexAliasesSkipIdentity() {\n@@ -1788,15 +1836,22 @@ public void testIndexAliasesSkipIdentity() {\n             .build();\n \n         Set<ResolvedExpression> resolvedExpressions = resolvedExpressionsSet(\"test-0\", \"test-alias\");\n-        String[] aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, false, resolvedExpressions);\n+        String[] aliases = indexNameExpressionResolver.indexAliases(\n+            project,\n+            \"test-0\",\n+            x -> true,\n+            (x, y) -> true,\n+            false,\n+            resolvedExpressions\n+        );\n         assertNull(aliases);\n-        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, true, resolvedExpressions);\n+        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, (x, y) -> true, true, resolvedExpressions);\n         assertArrayEquals(new String[] { \"test-alias\" }, aliases);\n \n         resolvedExpressions = Collections.singleton(new ResolvedExpression(\"other-alias\"));\n-        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, false, resolvedExpressions);\n+        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, (x, y) -> true, false, resolvedExpressions);\n         assertArrayEquals(new String[] { \"other-alias\" }, aliases);\n-        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, true, resolvedExpressions);\n+        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, (x, y) -> true, true, resolvedExpressions);\n         assertArrayEquals(new String[] { \"other-alias\" }, aliases);\n     }\n \n@@ -1809,14 +1864,7 @@ public void testConcreteWriteIndexSuccessful() {\n             )\n             .build();\n \n-        String[] strings = indexNameExpressionResolver.indexAliases(\n-            project,\n-            \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n-            resolvedExpressionsSet(\"test-0\", \"test-alias\")\n-        );\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(project, \"test-0\", resolvedExpressionsSet(\"test-0\", \"test-alias\"));\n         Arrays.sort(strings);\n         assertArrayEquals(new String[] { \"test-alias\" }, strings);\n         IndicesRequest request = new IndicesRequest() {\n@@ -1888,12 +1936,9 @@ public void testConcreteWriteIndexWithWildcardExpansion() {\n                     .putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(testZeroWriteIndex ? randomFrom(false, null) : true))\n             )\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(\n             project,\n             \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n             resolvedExpressionsSet(\"test-0\", \"test-1\", \"test-alias\")\n         );\n         Arrays.sort(strings);\n@@ -1926,14 +1971,7 @@ public void testConcreteWriteIndexWithNoWriteIndexWithSingleIndex() {\n         ProjectMetadata project = ProjectMetadata.builder(Metadata.DEFAULT_PROJECT_ID)\n             .put(indexBuilder(\"test-0\").state(State.OPEN).putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(false)))\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n-            project,\n-            \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n-            resolvedExpressionsSet(\"test-0\", \"test-alias\")\n-        );\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(project, \"test-0\", resolvedExpressionsSet(\"test-0\", \"test-alias\"));\n         Arrays.sort(strings);\n         assertArrayEquals(new String[] { \"test-alias\" }, strings);\n         DocWriteRequest<?> request = randomFrom(\n@@ -1960,12 +1998,9 @@ public void testConcreteWriteIndexWithNoWriteIndexWithMultipleIndices() {\n             .put(indexBuilder(\"test-0\").state(State.OPEN).putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(randomFrom(false, null))))\n             .put(indexBuilder(\"test-1\").state(State.OPEN).putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(randomFrom(false, null))))\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(\n             project,\n             \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n             Set.of(new ResolvedExpression(\"test-0\"), new ResolvedExpression(\"test-1\"), new ResolvedExpression(\"test-alias\"))\n         );\n         Arrays.sort(strings);\n@@ -2001,12 +2036,9 @@ public void testAliasResolutionNotAllowingMultipleIndices() {\n                     .putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(randomFrom(test0WriteIndex == false, null)))\n             )\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(\n             project,\n             \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n             resolvedExpressionsSet(\"test-0\", \"test-1\", \"test-alias\")\n         );\n         Arrays.sort(strings);\ndiff --git a/x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java b/x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java\nindex d1ae6abc70125..39b08ddea69bf 100644\n--- a/x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java\n+++ b/x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java\n@@ -105,7 +105,7 @@ public void setup() throws IOException {\n         upsertRole(Strings.format(\"\"\"\n             {\n               \"cluster\": [\"all\"],\n-              \"indices\": [{\"names\": [\"test*\"], \"privileges\": [\"write\", \"auto_configure\"]}]\n+              \"indices\": [{\"names\": [\"test*\", \"other*\"], \"privileges\": [\"write\", \"auto_configure\"]}]\n             }\"\"\"), WRITE_ACCESS);\n     }\n \n@@ -1921,6 +1921,245 @@ public void testFailureStoreAccess() throws Exception {\n         }\n     }\n \n+    public void testAliasBasedAccess() throws Exception {\n+        List<String> docIds = setupDataStream();\n+        assertThat(docIds.size(), equalTo(2));\n+        assertThat(docIds, hasItem(\"1\"));\n+        String dataDocId = \"1\";\n+        String failuresDocId = docIds.stream().filter(id -> false == id.equals(dataDocId)).findFirst().get();\n+\n+        List<String> otherDocIds = setupOtherDataStream();\n+        assertThat(otherDocIds.size(), equalTo(2));\n+        assertThat(otherDocIds, hasItem(\"3\"));\n+        String otherDataDocId = \"3\";\n+        String otherFailuresDocId = otherDocIds.stream().filter(id -> false == id.equals(otherDataDocId)).findFirst().get();\n+\n+        final Tuple<String, String> backingIndices = getSingleDataAndFailureIndices(\"test1\");\n+        final String dataIndexName = backingIndices.v1();\n+        final String failureIndexName = backingIndices.v2();\n+\n+        final String aliasName = \"my-alias\";\n+        final String username = \"user\";\n+        final String roleName = \"role\";\n+\n+        createUser(username, PASSWORD, roleName);\n+        // manage is required to add the alias to the data stream\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test1\", \"%s\", \"other1\"],\n+                  \"privileges\": [\"manage\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+\n+        addAlias(username, \"test1\", aliasName, \"\");\n+        addAlias(username, \"other1\", aliasName, \"\");\n+        assertThat(fetchAliases(username, \"test1\"), containsInAnyOrder(aliasName));\n+        expectSearchThrows(username, new Search(randomFrom(aliasName + \"::data\", aliasName)), 403);\n+        expectSearchThrows(username, new Search(randomFrom(aliasName + \"::failures\")), 403);\n+\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"%s\"],\n+                  \"privileges\": [\"read_failure_store\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+        expectSearch(username, new Search(aliasName + \"::failures\"), failuresDocId, otherFailuresDocId);\n+        expectSearchThrows(\n+            username,\n+            new Search(randomFrom(aliasName + \"::data\", \"my-alias::failures\", dataIndexName, failureIndexName)),\n+            403\n+        );\n+\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"%s\"],\n+                  \"privileges\": [\"read\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+        expectSearch(username, new Search(randomFrom(aliasName + \"::data\")), dataDocId, otherDataDocId);\n+        expectSearchThrows(username, new Search(aliasName + \"::failures\"), 403);\n+\n+        expectThrows(() -> removeAlias(username, \"test1\", aliasName), 403);\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test1\", \"%s\", \"other1\"],\n+                  \"privileges\": [\"manage\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+        removeAlias(username, \"test1\", aliasName);\n+        removeAlias(username, \"other1\", aliasName);\n+\n+        final String filteredAliasName = \"my-filtered-alias\";\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test1\", \"%s\", \"other1\"],\n+                  \"privileges\": [\"manage\"]\n+                }\n+              ]\n+            }\n+            \"\"\", filteredAliasName));\n+        addAlias(username, \"test1\", filteredAliasName, \"\"\"\n+            {\n+              \"term\": {\n+                \"document.source.name\": \"jack\"\n+              }\n+            }\n+            \"\"\");\n+        addAlias(username, \"other1\", filteredAliasName, \"\"\"\n+            {\n+              \"term\": {\n+                \"document.source.name\": \"jack\"\n+              }\n+            }\n+            \"\"\");\n+        assertThat(fetchAliases(username, \"test1\"), containsInAnyOrder(filteredAliasName));\n+        assertThat(fetchAliases(username, \"other1\"), containsInAnyOrder(filteredAliasName));\n+\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"%s\"],\n+                  \"privileges\": [\"read\", \"read_failure_store\"]\n+                }\n+              ]\n+            }\n+            \"\"\", filteredAliasName));\n+\n+        expectSearch(username, new Search(randomFrom(filteredAliasName + \"::data\", filteredAliasName)));\n+        // the alias filter is not applied to the failure store\n+        expectSearch(username, new Search(filteredAliasName + \"::failures\"), failuresDocId, otherFailuresDocId);\n+    }\n+\n+    private void createOrUpdateRoleAndApiKey(String username, String roleName, String roleDescriptor) throws IOException {\n+        upsertRole(roleDescriptor, roleName);\n+        createOrUpdateApiKey(username, randomBoolean() ? null : Strings.format(\"\"\"\n+            {\n+              \"%s\": %s\n+            }\n+            \"\"\", roleName, roleDescriptor));\n+    }\n+\n+    private void addAlias(String user, String dataStream, String alias, String filter) throws IOException {\n+        aliasAction(user, \"add\", dataStream, alias, filter);\n+    }\n+\n+    private void removeAlias(String user, String dataStream, String alias) throws IOException {\n+        aliasAction(user, \"remove\", dataStream, alias, \"\");\n+    }\n+\n+    private void aliasAction(String user, String action, String dataStream, String alias, String filter) throws IOException {\n+        Request request = new Request(\"POST\", \"/_aliases\");\n+        if (filter == null || filter.isEmpty()) {\n+            request.setJsonEntity(Strings.format(\"\"\"\n+                {\n+                  \"actions\": [\n+                    {\n+                      \"%s\": {\n+                        \"index\": \"%s\",\n+                        \"alias\": \"%s\"\n+                      }\n+                    }\n+                  ]\n+                }\n+                \"\"\", action, dataStream, alias));\n+        } else {\n+            request.setJsonEntity(Strings.format(\"\"\"\n+                {\n+                  \"actions\": [\n+                    {\n+                      \"%s\": {\n+                        \"index\": \"%s\",\n+                        \"alias\": \"%s\",\n+                        \"filter\": %s\n+                      }\n+                    }\n+                  ]\n+                }\n+                \"\"\", action, dataStream, alias, filter));\n+        }\n+        Response response = performRequestMaybeUsingApiKey(user, request);\n+        var path = assertOKAndCreateObjectPath(response);\n+        assertThat(path.evaluate(\"acknowledged\"), is(true));\n+        assertThat(path.evaluate(\"errors\"), is(false));\n+\n+    }\n+\n+    private Set<String> fetchAliases(String user, String dataStream) throws IOException {\n+        Response response = performRequestMaybeUsingApiKey(user, new Request(\"GET\", dataStream + \"/_alias\"));\n+        ObjectPath path = assertOKAndCreateObjectPath(response);\n+        Map<String, Object> aliases = path.evaluate(dataStream + \".aliases\");\n+        return aliases.keySet();\n+    }\n+\n+    public void testPatternExclusions() throws Exception {\n+        List<String> docIds = setupDataStream();\n+        assertThat(docIds.size(), equalTo(2));\n+        assertThat(docIds, hasItem(\"1\"));\n+        String dataDocId = \"1\";\n+        String failuresDocId = docIds.stream().filter(id -> false == id.equals(dataDocId)).findFirst().get();\n+\n+        List<String> otherDocIds = setupOtherDataStream();\n+        assertThat(otherDocIds.size(), equalTo(2));\n+        assertThat(otherDocIds, hasItem(\"3\"));\n+        String otherDataDocId = \"3\";\n+        String otherFailuresDocId = otherDocIds.stream().filter(id -> false == id.equals(otherDataDocId)).findFirst().get();\n+\n+        createUser(\"user\", PASSWORD, \"role\");\n+        upsertRole(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test*\", \"other*\"],\n+                  \"privileges\": [\"read\", \"read_failure_store\"]\n+                }\n+              ]\n+            }\n+            \"\"\", \"role\");\n+        createAndStoreApiKey(\"user\", randomBoolean() ? null : \"\"\"\n+            {\n+              \"role\": {\n+                \"cluster\": [\"all\"],\n+                \"indices\": [\n+                  {\n+                    \"names\": [\"*\"],\n+                    \"privileges\": [\"read\", \"read_failure_store\"]\n+                  }\n+                ]\n+              }\n+            }\n+            \"\"\");\n+\n+        // no exclusion -> should return two failure docs\n+        expectSearch(\"user\", new Search(\"*::failures\"), failuresDocId, otherFailuresDocId);\n+        expectSearch(\"user\", new Search(\"*::failures,-other*::failures\"), failuresDocId);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     private void expectEsql(String user, Search search, String... docIds) throws Exception {\n         var response = performRequestMaybeUsingApiKey(user, search.toEsqlRequest());\n@@ -2734,9 +2973,13 @@ private static void expectSearch(Response response, String... docIds) throws IOE\n         final SearchResponse searchResponse = SearchResponseUtils.parseSearchResponse(responseAsParser(response));\n         try {\n             SearchHit[] hits = searchResponse.getHits().getHits();\n-            assertThat(hits.length, equalTo(docIds.length));\n-            List<String> actualDocIds = Arrays.stream(hits).map(SearchHit::getId).toList();\n-            assertThat(actualDocIds, containsInAnyOrder(docIds));\n+            if (docIds != null) {\n+                assertThat(Arrays.toString(hits), hits.length, equalTo(docIds.length));\n+                List<String> actualDocIds = Arrays.stream(hits).map(SearchHit::getId).toList();\n+                assertThat(actualDocIds, containsInAnyOrder(docIds));\n+            } else {\n+                assertThat(hits.length, equalTo(0));\n+            }\n         } finally {\n             searchResponse.decRef();\n         }\n@@ -2780,6 +3023,32 @@ private List<String> setupDataStream() throws IOException {\n         return randomBoolean() ? populateDataStreamWithBulkRequest() : populateDataStreamWithDocRequests();\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    private List<String> setupOtherDataStream() throws IOException {\n+        createOtherTemplates();\n+\n+        var bulkRequest = new Request(\"POST\", \"/_bulk?refresh=true\");\n+        bulkRequest.setJsonEntity(\"\"\"\n+            { \"create\" : { \"_index\" : \"other1\", \"_id\" : \"3\" } }\n+            { \"@timestamp\": 3, \"age\" : 1, \"name\" : \"jane\", \"email\" : \"jane@example.com\" }\n+            { \"create\" : { \"_index\" : \"other1\", \"_id\" : \"4\" } }\n+            { \"@timestamp\": 4, \"age\" : \"this should be an int\", \"name\" : \"jane\", \"email\" : \"jane@example.com\" }\n+            \"\"\");\n+        Response response = performRequest(WRITE_ACCESS, bulkRequest);\n+        assertOK(response);\n+        // we need this dance because the ID for the failed document is random, **not** 4\n+        Map<String, Object> stringObjectMap = responseAsMap(response);\n+        List<Object> items = (List<Object>) stringObjectMap.get(\"items\");\n+        List<String> ids = new ArrayList<>();\n+        for (Object item : items) {\n+            Map<String, Object> itemMap = (Map<String, Object>) item;\n+            Map<String, Object> create = (Map<String, Object>) itemMap.get(\"create\");\n+            assertThat(create.get(\"status\"), equalTo(201));\n+            ids.add((String) create.get(\"_id\"));\n+        }\n+        return ids;\n+    }\n+\n     private void createTemplates() throws IOException {\n         var componentTemplateRequest = new Request(\"PUT\", \"/_component_template/component1\");\n         componentTemplateRequest.setJsonEntity(\"\"\"\n@@ -2823,6 +3092,49 @@ private void createTemplates() throws IOException {\n         assertOK(adminClient().performRequest(indexTemplateRequest));\n     }\n \n+    private void createOtherTemplates() throws IOException {\n+        var componentTemplateRequest = new Request(\"PUT\", \"/_component_template/component2\");\n+        componentTemplateRequest.setJsonEntity(\"\"\"\n+            {\n+                \"template\": {\n+                    \"mappings\": {\n+                        \"properties\": {\n+                            \"@timestamp\": {\n+                                \"type\": \"date\"\n+                            },\n+                            \"age\": {\n+                                \"type\": \"integer\"\n+                            },\n+                            \"email\": {\n+                                \"type\": \"keyword\"\n+                            },\n+                            \"name\": {\n+                                \"type\": \"text\"\n+                            }\n+                        }\n+                    },\n+                    \"data_stream_options\": {\n+                      \"failure_store\": {\n+                        \"enabled\": true\n+                      }\n+                    }\n+                }\n+            }\n+            \"\"\");\n+        assertOK(adminClient().performRequest(componentTemplateRequest));\n+\n+        var indexTemplateRequest = new Request(\"PUT\", \"/_index_template/template2\");\n+        indexTemplateRequest.setJsonEntity(\"\"\"\n+            {\n+                \"index_patterns\": [\"other*\"],\n+                \"data_stream\": {},\n+                \"priority\": 500,\n+                \"composed_of\": [\"component1\"]\n+            }\n+            \"\"\");\n+        assertOK(adminClient().performRequest(indexTemplateRequest));\n+    }\n+\n     private List<String> populateDataStreamWithDocRequests() throws IOException {\n         List<String> ids = new ArrayList<>();\n \n@@ -2942,6 +3254,11 @@ protected String createAndStoreApiKey(String username, @Nullable String roleDesc\n         return apiKeys.get(username);\n     }\n \n+    protected String createOrUpdateApiKey(String username, @Nullable String roleDescriptors) throws IOException {\n+        apiKeys.put(username, createApiKey(username, roleDescriptors));\n+        return apiKeys.get(username);\n+    }\n+\n     private String createApiKey(String username, String roleDescriptors) throws IOException {\n         var request = new Request(\"POST\", \"/_security/api_key\");\n         if (roleDescriptors == null) {\n",
  "files_changed": 5,
  "additions": 454,
  "deletions": 99,
  "commit_count": 4,
  "mergeable_state": "",
  "base_commit_sha": "f1f790069d40399647bf1ee5d0b161347eba5f13",
  "base_commit_link": "https://github.com/elastic/elasticsearch/commit/f1f790069d40399647bf1ee5d0b161347eba5f13",
  "last_processed_time": "2025-04-29T01:29:00",
  "comments": [
    {
      "id": 2834935763,
      "pr_id": 2485565973,
      "body": "Pinging @elastic/es-data-management (Team:Data Management)",
      "created_at": "2025-04-28T11:27:17",
      "user_login": "elasticsearchmachine",
      "path": "",
      "position": 0
    },
    {
      "id": 2064880180,
      "pr_id": 2485565973,
      "body": "This one is on me. Not sure how `my-alias::failures` ended up in this assertion.   It should be `aliasName` instead. Using `::failures` selector with alias is the only authorized. \r\n```suggestion\r\n            new Search(randomFrom(aliasName + \"::data\", aliasName, dataIndexName, failureIndexName)),\r\n```",
      "created_at": "2025-04-28T22:17:07",
      "user_login": "slobodanadamovic",
      "path": "x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java",
      "position": 68
    }
  ],
  "github_reviews": [
    {
      "id": 2801125225,
      "pr_id": 2485565973,
      "body": "LGTM \ud83d\udc4d \r\n\r\nThank you for fixing this!",
      "state": "APPROVED",
      "created_at": "2025-04-28T22:54:55",
      "user_login": "slobodanadamovic"
    }
  ],
  "patches": [
    {
      "id": 1916,
      "pr_id": 2485565973,
      "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java",
      "patch": "@@ -25,7 +25,6 @@\n import org.elasticsearch.cluster.routing.ShardIterator;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.service.ClusterService;\n-import org.elasticsearch.core.Predicates;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.injection.guice.Inject;\n@@ -105,14 +104,7 @@ protected void masterOperation(\n         Set<ResolvedExpression> indicesAndAliases = indexNameExpressionResolver.resolveExpressions(project.metadata(), request.indices());\n         for (String index : concreteIndices) {\n             final AliasFilter aliasFilter = indicesService.buildAliasFilter(project, index, indicesAndAliases);\n-            final String[] aliases = indexNameExpressionResolver.indexAliases(\n-                project.metadata(),\n-                index,\n-                Predicates.always(),\n-                Predicates.always(),\n-                true,\n-                indicesAndAliases\n-            );\n+            final String[] aliases = indexNameExpressionResolver.allIndexAliases(project.metadata(), index, indicesAndAliases);\n             indicesAndFilters.put(index, AliasFilter.of(aliasFilter.getQueryBuilder(), aliases));\n         }\n ",
      "filename": "server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java",
      "status": "modified",
      "changes": 10,
      "additions": 1,
      "deletions": 9
    },
    {
      "id": 1918,
      "pr_id": 2485565973,
      "path": "server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java",
      "patch": "@@ -62,7 +62,6 @@\n import org.elasticsearch.common.util.Maps;\n import org.elasticsearch.common.util.concurrent.CountDown;\n import org.elasticsearch.common.util.concurrent.EsExecutors;\n-import org.elasticsearch.core.Predicates;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.IndexNotFoundException;\n@@ -232,14 +231,7 @@ private Map<String, OriginalIndices> buildPerIndexOriginalIndices(\n                 blocks.indexBlockedRaiseException(projectState.projectId(), ClusterBlockLevel.READ, index);\n             }\n \n-            String[] aliases = indexNameExpressionResolver.indexAliases(\n-                projectState.metadata(),\n-                index,\n-                Predicates.always(),\n-                Predicates.always(),\n-                true,\n-                indicesAndAliases\n-            );\n+            String[] aliases = indexNameExpressionResolver.allIndexAliases(projectState.metadata(), index, indicesAndAliases);\n             String[] finalIndices = Strings.EMPTY_ARRAY;\n             if (aliases == null\n                 || aliases.length == 0",
      "filename": "server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java",
      "status": "modified",
      "changes": 10,
      "additions": 1,
      "deletions": 9
    },
    {
      "id": 1920,
      "pr_id": 2485565973,
      "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java",
      "patch": "@@ -59,6 +59,7 @@\n import java.util.Set;\n import java.util.SortedMap;\n import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n import java.util.function.Function;\n import java.util.function.LongSupplier;\n import java.util.function.Predicate;\n@@ -80,6 +81,13 @@ public class IndexNameExpressionResolver {\n     public static final String EXCLUDED_DATA_STREAMS_KEY = \"es.excluded_ds\";\n     public static final IndexVersion SYSTEM_INDEX_ENFORCEMENT_INDEX_VERSION = IndexVersions.V_8_0_0;\n \n+    private static final BiPredicate<DataStreamAlias, Boolean> ALL_DATA_STREAM_ALIASES = (ignoredAlias, ignoredIsData) -> true;\n+    // Alias filters are not applied against indices in an abstraction's failure component.\n+    // They do not match the mapping of the data stream nor are the documents mapped for searching.\n+    private static final BiPredicate<DataStreamAlias, Boolean> ONLY_FILTERING_DATA_STREAM_ALIASES = (\n+        dataStreamAlias,\n+        isData) -> dataStreamAlias.filteringRequired() && isData;\n+\n     private final ThreadContext threadContext;\n     private final SystemIndices systemIndices;\n     private final ProjectResolver projectResolver;\n@@ -1054,12 +1062,21 @@ public String[] filteringAliases(ProjectMetadata project, String index, Set<Reso\n             project,\n             index,\n             AliasMetadata::filteringRequired,\n-            DataStreamAlias::filteringRequired,\n+            ONLY_FILTERING_DATA_STREAM_ALIASES,\n             false,\n             resolvedExpressions\n         );\n     }\n \n+    /**\n+     * Iterates through the list of indices and selects the effective list of all aliases for the\n+     * given index. Aliases are returned even if the index is included in the resolved expressions.\n+     * <b>NOTE</b>: The provided expressions must have been resolved already via {@link #resolveExpressions}.\n+     */\n+    public String[] allIndexAliases(ProjectMetadata project, String index, Set<ResolvedExpression> resolvedExpressions) {\n+        return indexAliases(project, index, Predicates.always(), ALL_DATA_STREAM_ALIASES, true, resolvedExpressions);\n+    }\n+\n     /**\n      * Whether to generate the candidate set from index aliases, or from the set of resolved expressions.\n      * @param indexAliasesSize        the number of aliases of the index\n@@ -1080,7 +1097,7 @@ public String[] indexAliases(\n         ProjectMetadata project,\n         String index,\n         Predicate<AliasMetadata> requiredAlias,\n-        Predicate<DataStreamAlias> requiredDataStreamAlias,\n+        BiPredicate<DataStreamAlias, Boolean> requiredDataStreamAlias,\n         boolean skipIdentity,\n         Set<ResolvedExpression> resolvedExpressions\n     ) {\n@@ -1107,13 +1124,8 @@ public String[] indexAliases(\n         IndexAbstraction ia = project.getIndicesLookup().get(index);\n         DataStream dataStream = ia.getParentDataStream();\n         if (dataStream != null) {\n-            if (dataStream.getFailureComponent().containsIndex(index)) {\n-                // Alias filters are not applied against indices in an abstraction's failure component.\n-                // They do not match the mapping of the data stream nor are the documents mapped for searching.\n-                return null;\n-            }\n-\n-            if (skipIdentity == false && resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStream.getName())) {\n+            boolean isData = dataStream.isFailureStoreIndex(index) == false;\n+            if (skipIdentity == false && resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStream.getName(), isData)) {\n                 // skip the filters when the request targets the data stream name + selector directly\n                 return null;\n             }\n@@ -1122,12 +1134,14 @@ public String[] indexAliases(\n             if (iterateIndexAliases(dataStreamAliases.size(), resolvedExpressions.size())) {\n                 aliasesForDataStream = dataStreamAliases.values()\n                     .stream()\n-                    .filter(dataStreamAlias -> resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStreamAlias.getName()))\n+                    .filter(\n+                        dataStreamAlias -> resolvedExpressionsContainsAbstraction(resolvedExpressions, dataStreamAlias.getName(), isData)\n+                    )\n                     .filter(dataStreamAlias -> dataStreamAlias.getDataStreams().contains(dataStream.getName()))\n                     .toList();\n             } else {\n                 aliasesForDataStream = resolvedExpressions.stream()\n-                    .filter(expression -> expression.selector() == null || expression.selector().shouldIncludeData())\n+                    .filter(expression -> (expression.selector() == null || expression.selector().shouldIncludeData()) == isData)\n                     .map(ResolvedExpression::resource)\n                     .map(dataStreamAliases::get)\n                     .filter(dataStreamAlias -> dataStreamAlias != null && dataStreamAlias.getDataStreams().contains(dataStream.getName()))\n@@ -1136,11 +1150,12 @@ public String[] indexAliases(\n \n             List<String> requiredAliases = null;\n             for (DataStreamAlias dataStreamAlias : aliasesForDataStream) {\n-                if (requiredDataStreamAlias.test(dataStreamAlias)) {\n+                if (requiredDataStreamAlias.test(dataStreamAlias, isData)) {\n                     if (requiredAliases == null) {\n                         requiredAliases = new ArrayList<>(aliasesForDataStream.size());\n                     }\n-                    requiredAliases.add(dataStreamAlias.getName());\n+                    String alias = isData ? dataStreamAlias.getName() : dataStreamAlias.getName() + \"::failures\";\n+                    requiredAliases.add(alias);\n                 } else {\n                     // we have a non-required alias for this data stream so no need to check further\n                     return null;\n@@ -1162,7 +1177,7 @@ public String[] indexAliases(\n                 // Indices can only be referenced with a data selector, or a null selector if selectors are disabled\n                 for (AliasMetadata aliasMetadata : indexAliases.values()) {\n                     var alias = aliasMetadata.alias();\n-                    if (resolvedExpressionsContainsAbstraction(resolvedExpressions, alias)) {\n+                    if (resolvedExpressionsContainsAbstraction(resolvedExpressions, alias, true)) {\n                         if (requiredAlias.test(aliasMetadata) == false) {\n                             return null;\n                         }\n@@ -1185,9 +1200,16 @@ public String[] indexAliases(\n         }\n     }\n \n-    private static boolean resolvedExpressionsContainsAbstraction(Set<ResolvedExpression> resolvedExpressions, String abstractionName) {\n-        return resolvedExpressions.contains(new ResolvedExpression(abstractionName))\n-            || resolvedExpressions.contains(new ResolvedExpression(abstractionName, IndexComponentSelector.DATA));\n+    private static boolean resolvedExpressionsContainsAbstraction(\n+        Set<ResolvedExpression> resolvedExpressions,\n+        String abstractionName,\n+        boolean isData\n+    ) {\n+        if (isData) {\n+            return resolvedExpressions.contains(new ResolvedExpression(abstractionName))\n+                || resolvedExpressions.contains(new ResolvedExpression(abstractionName, IndexComponentSelector.DATA));\n+        }\n+        return resolvedExpressions.contains(new ResolvedExpression(abstractionName, IndexComponentSelector.FAILURES));\n     }\n \n     /**",
      "filename": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java",
      "status": "modified",
      "changes": 56,
      "additions": 39,
      "deletions": 17
    },
    {
      "id": 1922,
      "pr_id": 2485565973,
      "path": "server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java",
      "patch": "@@ -1668,15 +1668,15 @@ public void testIndexAliases() {\n             .build();\n         Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"test-*\");\n \n-        String[] strings = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, true, resolvedExpressions);\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(project, \"test-0\", resolvedExpressions);\n         Arrays.sort(strings);\n         assertArrayEquals(new String[] { \"test-alias-0\", \"test-alias-1\", \"test-alias-non-filtering\" }, strings);\n \n         strings = indexNameExpressionResolver.indexAliases(\n             project,\n             \"test-0\",\n             x -> x.alias().equals(\"test-alias-1\"),\n-            x -> false,\n+            (x, y) -> randomBoolean(),\n             true,\n             resolvedExpressions\n         );\n@@ -1700,52 +1700,52 @@ public void testIndexAliasesDataStreamAliases() {\n         projectBuilder.put(\"logs_baz2\", dataStreamName2, null, null);\n         ProjectMetadata project = projectBuilder.build();\n         {\n-            // Only resolve aliases with with that refer to dataStreamName1\n+            // Only resolve aliases that refer to dataStreamName1\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex1.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(project, index, x -> true, x -> true, true, resolvedExpressions);\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n             assertThat(result, arrayContainingInAnyOrder(\"logs_foo\", \"logs\", \"logs_bar\"));\n         }\n         {\n-            // Only resolve aliases with with that refer to dataStreamName2\n+            // Only resolve aliases that refer to dataStreamName2\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex2.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(project, index, x -> true, x -> true, true, resolvedExpressions);\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n             assertThat(result, arrayContainingInAnyOrder(\"logs_baz\", \"logs_baz2\"));\n         }\n         {\n             // Null is returned, because skipping identity check and resolvedExpressions contains the backing index name\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex2.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(project, index, x -> true, x -> true, false, resolvedExpressions);\n+            String[] result = indexNameExpressionResolver.indexAliases(\n+                project,\n+                index,\n+                x -> randomBoolean(),\n+                (x, y) -> true,\n+                false,\n+                resolvedExpressions\n+            );\n             assertThat(result, nullValue());\n         }\n         {\n             // Null is returned, because the wildcard expands to a list of aliases containing an unfiltered alias for dataStreamName1\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*\");\n             String index = backingIndex1.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(\n-                project,\n-                index,\n-                x -> true,\n-                DataStreamAlias::filteringRequired,\n-                true,\n-                resolvedExpressions\n-            );\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n             assertThat(result, nullValue());\n         }\n         {\n             // Null is returned, because an unfiltered alias is targeting the same data stream\n             Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"logs_bar\", \"logs\");\n             String index = backingIndex1.getIndex().getName();\n-            String[] result = indexNameExpressionResolver.indexAliases(\n-                project,\n-                index,\n-                x -> true,\n-                DataStreamAlias::filteringRequired,\n-                true,\n-                resolvedExpressions\n-            );\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n+        {\n+            // Null is returned because we target the data stream name and skipIdentity is false\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, dataStreamName1, \"logs\");\n+            String index = backingIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n             assertThat(result, nullValue());\n         }\n         {\n@@ -1756,26 +1756,74 @@ public void testIndexAliasesDataStreamAliases() {\n                 project,\n                 index,\n                 x -> true,\n-                DataStreamAlias::filteringRequired,\n+                (alias, isData) -> alias.filteringRequired() && isData,\n                 true,\n                 resolvedExpressions\n             );\n             assertThat(result, arrayContainingInAnyOrder(\"logs\"));\n         }\n+    }\n+\n+    public void testIndexAliasesDataStreamFailureStoreAndAliases() {\n+        final String dataStreamName1 = \"logs-foobar\";\n+        final String dataStreamName2 = \"logs-barbaz\";\n+        IndexMetadata backingIndex1 = createBackingIndex(dataStreamName1, 1).build();\n+        IndexMetadata failureIndex1 = createFailureStore(dataStreamName1, 2).build();\n+        IndexMetadata backingIndex2 = createBackingIndex(dataStreamName2, 1).build();\n+        ProjectMetadata.Builder projectBuilder = ProjectMetadata.builder(Metadata.DEFAULT_PROJECT_ID)\n+            .put(backingIndex1, false)\n+            .put(backingIndex2, false)\n+            .put(failureIndex1, false)\n+            .put(newInstance(dataStreamName1, List.of(backingIndex1.getIndex()), List.of(failureIndex1.getIndex())))\n+            .put(newInstance(dataStreamName2, List.of(backingIndex2.getIndex())));\n+        projectBuilder.put(\"logs_foo\", dataStreamName1, null, \"{ \\\"term\\\": \\\"foo\\\"}\");\n+        projectBuilder.put(\"logs\", dataStreamName1, null, \"{ \\\"term\\\": \\\"logs\\\"}\");\n+        projectBuilder.put(\"logs_bar\", dataStreamName1, null, null);\n+        projectBuilder.put(\"logs_baz\", dataStreamName2, null, \"{ \\\"term\\\": \\\"logs\\\"}\");\n+        projectBuilder.put(\"logs_baz2\", dataStreamName2, null, null);\n+        ProjectMetadata project = projectBuilder.build();\n         {\n-            // Null is returned because we target the data stream name and skipIdentity is false\n-            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, dataStreamName1, \"logs\");\n-            String index = backingIndex1.getIndex().getName();\n+            // Resolving the failure component with a backing index should return null\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = randomBoolean() ? backingIndex1.getIndex().getName() : backingIndex2.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n+        {\n+            // Only resolve aliases that refer to dataStreamName1 failure store\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = failureIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.allIndexAliases(project, index, resolvedExpressions);\n+            assertThat(result, arrayContainingInAnyOrder(\"logs_foo::failures\", \"logs::failures\", \"logs_bar::failures\"));\n+        }\n+        {\n+            // Null is returned, because we perform the identity check and resolvedExpressions contains the failure index name\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = failureIndex1.getIndex().getName();\n             String[] result = indexNameExpressionResolver.indexAliases(\n                 project,\n                 index,\n                 x -> true,\n-                DataStreamAlias::filteringRequired,\n+                (x, y) -> true,\n                 false,\n                 resolvedExpressions\n             );\n             assertThat(result, nullValue());\n         }\n+        {\n+            // Null is returned, because the wildcard expands to a list of aliases containing an unfiltered alias for dataStreamName1\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"l*::failures\");\n+            String index = failureIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n+        {\n+            // Null is returned because we target the failure store of the data stream\n+            Set<ResolvedExpression> resolvedExpressions = indexNameExpressionResolver.resolveExpressions(project, \"logs::failures\");\n+            String index = failureIndex1.getIndex().getName();\n+            String[] result = indexNameExpressionResolver.filteringAliases(project, index, resolvedExpressions);\n+            assertThat(result, nullValue());\n+        }\n     }\n \n     public void testIndexAliasesSkipIdentity() {\n@@ -1788,15 +1836,22 @@ public void testIndexAliasesSkipIdentity() {\n             .build();\n \n         Set<ResolvedExpression> resolvedExpressions = resolvedExpressionsSet(\"test-0\", \"test-alias\");\n-        String[] aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, false, resolvedExpressions);\n+        String[] aliases = indexNameExpressionResolver.indexAliases(\n+            project,\n+            \"test-0\",\n+            x -> true,\n+            (x, y) -> true,\n+            false,\n+            resolvedExpressions\n+        );\n         assertNull(aliases);\n-        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, true, resolvedExpressions);\n+        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, (x, y) -> true, true, resolvedExpressions);\n         assertArrayEquals(new String[] { \"test-alias\" }, aliases);\n \n         resolvedExpressions = Collections.singleton(new ResolvedExpression(\"other-alias\"));\n-        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, false, resolvedExpressions);\n+        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, (x, y) -> true, false, resolvedExpressions);\n         assertArrayEquals(new String[] { \"other-alias\" }, aliases);\n-        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, x -> true, true, resolvedExpressions);\n+        aliases = indexNameExpressionResolver.indexAliases(project, \"test-0\", x -> true, (x, y) -> true, true, resolvedExpressions);\n         assertArrayEquals(new String[] { \"other-alias\" }, aliases);\n     }\n \n@@ -1809,14 +1864,7 @@ public void testConcreteWriteIndexSuccessful() {\n             )\n             .build();\n \n-        String[] strings = indexNameExpressionResolver.indexAliases(\n-            project,\n-            \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n-            resolvedExpressionsSet(\"test-0\", \"test-alias\")\n-        );\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(project, \"test-0\", resolvedExpressionsSet(\"test-0\", \"test-alias\"));\n         Arrays.sort(strings);\n         assertArrayEquals(new String[] { \"test-alias\" }, strings);\n         IndicesRequest request = new IndicesRequest() {\n@@ -1888,12 +1936,9 @@ public void testConcreteWriteIndexWithWildcardExpansion() {\n                     .putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(testZeroWriteIndex ? randomFrom(false, null) : true))\n             )\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(\n             project,\n             \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n             resolvedExpressionsSet(\"test-0\", \"test-1\", \"test-alias\")\n         );\n         Arrays.sort(strings);\n@@ -1926,14 +1971,7 @@ public void testConcreteWriteIndexWithNoWriteIndexWithSingleIndex() {\n         ProjectMetadata project = ProjectMetadata.builder(Metadata.DEFAULT_PROJECT_ID)\n             .put(indexBuilder(\"test-0\").state(State.OPEN).putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(false)))\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n-            project,\n-            \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n-            resolvedExpressionsSet(\"test-0\", \"test-alias\")\n-        );\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(project, \"test-0\", resolvedExpressionsSet(\"test-0\", \"test-alias\"));\n         Arrays.sort(strings);\n         assertArrayEquals(new String[] { \"test-alias\" }, strings);\n         DocWriteRequest<?> request = randomFrom(\n@@ -1960,12 +1998,9 @@ public void testConcreteWriteIndexWithNoWriteIndexWithMultipleIndices() {\n             .put(indexBuilder(\"test-0\").state(State.OPEN).putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(randomFrom(false, null))))\n             .put(indexBuilder(\"test-1\").state(State.OPEN).putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(randomFrom(false, null))))\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(\n             project,\n             \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n             Set.of(new ResolvedExpression(\"test-0\"), new ResolvedExpression(\"test-1\"), new ResolvedExpression(\"test-alias\"))\n         );\n         Arrays.sort(strings);\n@@ -2001,12 +2036,9 @@ public void testAliasResolutionNotAllowingMultipleIndices() {\n                     .putAlias(AliasMetadata.builder(\"test-alias\").writeIndex(randomFrom(test0WriteIndex == false, null)))\n             )\n             .build();\n-        String[] strings = indexNameExpressionResolver.indexAliases(\n+        String[] strings = indexNameExpressionResolver.allIndexAliases(\n             project,\n             \"test-0\",\n-            x -> true,\n-            x -> true,\n-            true,\n             resolvedExpressionsSet(\"test-0\", \"test-1\", \"test-alias\")\n         );\n         Arrays.sort(strings);",
      "filename": "server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java",
      "status": "modified",
      "changes": 152,
      "additions": 92,
      "deletions": 60
    },
    {
      "id": 1925,
      "pr_id": 2485565973,
      "path": "x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java",
      "patch": "@@ -105,7 +105,7 @@ public void setup() throws IOException {\n         upsertRole(Strings.format(\"\"\"\n             {\n               \"cluster\": [\"all\"],\n-              \"indices\": [{\"names\": [\"test*\"], \"privileges\": [\"write\", \"auto_configure\"]}]\n+              \"indices\": [{\"names\": [\"test*\", \"other*\"], \"privileges\": [\"write\", \"auto_configure\"]}]\n             }\"\"\"), WRITE_ACCESS);\n     }\n \n@@ -1921,6 +1921,245 @@ public void testFailureStoreAccess() throws Exception {\n         }\n     }\n \n+    public void testAliasBasedAccess() throws Exception {\n+        List<String> docIds = setupDataStream();\n+        assertThat(docIds.size(), equalTo(2));\n+        assertThat(docIds, hasItem(\"1\"));\n+        String dataDocId = \"1\";\n+        String failuresDocId = docIds.stream().filter(id -> false == id.equals(dataDocId)).findFirst().get();\n+\n+        List<String> otherDocIds = setupOtherDataStream();\n+        assertThat(otherDocIds.size(), equalTo(2));\n+        assertThat(otherDocIds, hasItem(\"3\"));\n+        String otherDataDocId = \"3\";\n+        String otherFailuresDocId = otherDocIds.stream().filter(id -> false == id.equals(otherDataDocId)).findFirst().get();\n+\n+        final Tuple<String, String> backingIndices = getSingleDataAndFailureIndices(\"test1\");\n+        final String dataIndexName = backingIndices.v1();\n+        final String failureIndexName = backingIndices.v2();\n+\n+        final String aliasName = \"my-alias\";\n+        final String username = \"user\";\n+        final String roleName = \"role\";\n+\n+        createUser(username, PASSWORD, roleName);\n+        // manage is required to add the alias to the data stream\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test1\", \"%s\", \"other1\"],\n+                  \"privileges\": [\"manage\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+\n+        addAlias(username, \"test1\", aliasName, \"\");\n+        addAlias(username, \"other1\", aliasName, \"\");\n+        assertThat(fetchAliases(username, \"test1\"), containsInAnyOrder(aliasName));\n+        expectSearchThrows(username, new Search(randomFrom(aliasName + \"::data\", aliasName)), 403);\n+        expectSearchThrows(username, new Search(randomFrom(aliasName + \"::failures\")), 403);\n+\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"%s\"],\n+                  \"privileges\": [\"read_failure_store\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+        expectSearch(username, new Search(aliasName + \"::failures\"), failuresDocId, otherFailuresDocId);\n+        expectSearchThrows(\n+            username,\n+            new Search(randomFrom(aliasName + \"::data\", \"my-alias::failures\", dataIndexName, failureIndexName)),\n+            403\n+        );\n+\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"%s\"],\n+                  \"privileges\": [\"read\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+        expectSearch(username, new Search(randomFrom(aliasName + \"::data\")), dataDocId, otherDataDocId);\n+        expectSearchThrows(username, new Search(aliasName + \"::failures\"), 403);\n+\n+        expectThrows(() -> removeAlias(username, \"test1\", aliasName), 403);\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test1\", \"%s\", \"other1\"],\n+                  \"privileges\": [\"manage\"]\n+                }\n+              ]\n+            }\n+            \"\"\", aliasName));\n+        removeAlias(username, \"test1\", aliasName);\n+        removeAlias(username, \"other1\", aliasName);\n+\n+        final String filteredAliasName = \"my-filtered-alias\";\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test1\", \"%s\", \"other1\"],\n+                  \"privileges\": [\"manage\"]\n+                }\n+              ]\n+            }\n+            \"\"\", filteredAliasName));\n+        addAlias(username, \"test1\", filteredAliasName, \"\"\"\n+            {\n+              \"term\": {\n+                \"document.source.name\": \"jack\"\n+              }\n+            }\n+            \"\"\");\n+        addAlias(username, \"other1\", filteredAliasName, \"\"\"\n+            {\n+              \"term\": {\n+                \"document.source.name\": \"jack\"\n+              }\n+            }\n+            \"\"\");\n+        assertThat(fetchAliases(username, \"test1\"), containsInAnyOrder(filteredAliasName));\n+        assertThat(fetchAliases(username, \"other1\"), containsInAnyOrder(filteredAliasName));\n+\n+        createOrUpdateRoleAndApiKey(username, roleName, Strings.format(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"%s\"],\n+                  \"privileges\": [\"read\", \"read_failure_store\"]\n+                }\n+              ]\n+            }\n+            \"\"\", filteredAliasName));\n+\n+        expectSearch(username, new Search(randomFrom(filteredAliasName + \"::data\", filteredAliasName)));\n+        // the alias filter is not applied to the failure store\n+        expectSearch(username, new Search(filteredAliasName + \"::failures\"), failuresDocId, otherFailuresDocId);\n+    }\n+\n+    private void createOrUpdateRoleAndApiKey(String username, String roleName, String roleDescriptor) throws IOException {\n+        upsertRole(roleDescriptor, roleName);\n+        createOrUpdateApiKey(username, randomBoolean() ? null : Strings.format(\"\"\"\n+            {\n+              \"%s\": %s\n+            }\n+            \"\"\", roleName, roleDescriptor));\n+    }\n+\n+    private void addAlias(String user, String dataStream, String alias, String filter) throws IOException {\n+        aliasAction(user, \"add\", dataStream, alias, filter);\n+    }\n+\n+    private void removeAlias(String user, String dataStream, String alias) throws IOException {\n+        aliasAction(user, \"remove\", dataStream, alias, \"\");\n+    }\n+\n+    private void aliasAction(String user, String action, String dataStream, String alias, String filter) throws IOException {\n+        Request request = new Request(\"POST\", \"/_aliases\");\n+        if (filter == null || filter.isEmpty()) {\n+            request.setJsonEntity(Strings.format(\"\"\"\n+                {\n+                  \"actions\": [\n+                    {\n+                      \"%s\": {\n+                        \"index\": \"%s\",\n+                        \"alias\": \"%s\"\n+                      }\n+                    }\n+                  ]\n+                }\n+                \"\"\", action, dataStream, alias));\n+        } else {\n+            request.setJsonEntity(Strings.format(\"\"\"\n+                {\n+                  \"actions\": [\n+                    {\n+                      \"%s\": {\n+                        \"index\": \"%s\",\n+                        \"alias\": \"%s\",\n+                        \"filter\": %s\n+                      }\n+                    }\n+                  ]\n+                }\n+                \"\"\", action, dataStream, alias, filter));\n+        }\n+        Response response = performRequestMaybeUsingApiKey(user, request);\n+        var path = assertOKAndCreateObjectPath(response);\n+        assertThat(path.evaluate(\"acknowledged\"), is(true));\n+        assertThat(path.evaluate(\"errors\"), is(false));\n+\n+    }\n+\n+    private Set<String> fetchAliases(String user, String dataStream) throws IOException {\n+        Response response = performRequestMaybeUsingApiKey(user, new Request(\"GET\", dataStream + \"/_alias\"));\n+        ObjectPath path = assertOKAndCreateObjectPath(response);\n+        Map<String, Object> aliases = path.evaluate(dataStream + \".aliases\");\n+        return aliases.keySet();\n+    }\n+\n+    public void testPatternExclusions() throws Exception {\n+        List<String> docIds = setupDataStream();\n+        assertThat(docIds.size(), equalTo(2));\n+        assertThat(docIds, hasItem(\"1\"));\n+        String dataDocId = \"1\";\n+        String failuresDocId = docIds.stream().filter(id -> false == id.equals(dataDocId)).findFirst().get();\n+\n+        List<String> otherDocIds = setupOtherDataStream();\n+        assertThat(otherDocIds.size(), equalTo(2));\n+        assertThat(otherDocIds, hasItem(\"3\"));\n+        String otherDataDocId = \"3\";\n+        String otherFailuresDocId = otherDocIds.stream().filter(id -> false == id.equals(otherDataDocId)).findFirst().get();\n+\n+        createUser(\"user\", PASSWORD, \"role\");\n+        upsertRole(\"\"\"\n+            {\n+              \"cluster\": [\"all\"],\n+              \"indices\": [\n+                {\n+                  \"names\": [\"test*\", \"other*\"],\n+                  \"privileges\": [\"read\", \"read_failure_store\"]\n+                }\n+              ]\n+            }\n+            \"\"\", \"role\");\n+        createAndStoreApiKey(\"user\", randomBoolean() ? null : \"\"\"\n+            {\n+              \"role\": {\n+                \"cluster\": [\"all\"],\n+                \"indices\": [\n+                  {\n+                    \"names\": [\"*\"],\n+                    \"privileges\": [\"read\", \"read_failure_store\"]\n+                  }\n+                ]\n+              }\n+            }\n+            \"\"\");\n+\n+        // no exclusion -> should return two failure docs\n+        expectSearch(\"user\", new Search(\"*::failures\"), failuresDocId, otherFailuresDocId);\n+        expectSearch(\"user\", new Search(\"*::failures,-other*::failures\"), failuresDocId);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     private void expectEsql(String user, Search search, String... docIds) throws Exception {\n         var response = performRequestMaybeUsingApiKey(user, search.toEsqlRequest());\n@@ -2734,9 +2973,13 @@ private static void expectSearch(Response response, String... docIds) throws IOE\n         final SearchResponse searchResponse = SearchResponseUtils.parseSearchResponse(responseAsParser(response));\n         try {\n             SearchHit[] hits = searchResponse.getHits().getHits();\n-            assertThat(hits.length, equalTo(docIds.length));\n-            List<String> actualDocIds = Arrays.stream(hits).map(SearchHit::getId).toList();\n-            assertThat(actualDocIds, containsInAnyOrder(docIds));\n+            if (docIds != null) {\n+                assertThat(Arrays.toString(hits), hits.length, equalTo(docIds.length));\n+                List<String> actualDocIds = Arrays.stream(hits).map(SearchHit::getId).toList();\n+                assertThat(actualDocIds, containsInAnyOrder(docIds));\n+            } else {\n+                assertThat(hits.length, equalTo(0));\n+            }\n         } finally {\n             searchResponse.decRef();\n         }\n@@ -2780,6 +3023,32 @@ private List<String> setupDataStream() throws IOException {\n         return randomBoolean() ? populateDataStreamWithBulkRequest() : populateDataStreamWithDocRequests();\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    private List<String> setupOtherDataStream() throws IOException {\n+        createOtherTemplates();\n+\n+        var bulkRequest = new Request(\"POST\", \"/_bulk?refresh=true\");\n+        bulkRequest.setJsonEntity(\"\"\"\n+            { \"create\" : { \"_index\" : \"other1\", \"_id\" : \"3\" } }\n+            { \"@timestamp\": 3, \"age\" : 1, \"name\" : \"jane\", \"email\" : \"jane@example.com\" }\n+            { \"create\" : { \"_index\" : \"other1\", \"_id\" : \"4\" } }\n+            { \"@timestamp\": 4, \"age\" : \"this should be an int\", \"name\" : \"jane\", \"email\" : \"jane@example.com\" }\n+            \"\"\");\n+        Response response = performRequest(WRITE_ACCESS, bulkRequest);\n+        assertOK(response);\n+        // we need this dance because the ID for the failed document is random, **not** 4\n+        Map<String, Object> stringObjectMap = responseAsMap(response);\n+        List<Object> items = (List<Object>) stringObjectMap.get(\"items\");\n+        List<String> ids = new ArrayList<>();\n+        for (Object item : items) {\n+            Map<String, Object> itemMap = (Map<String, Object>) item;\n+            Map<String, Object> create = (Map<String, Object>) itemMap.get(\"create\");\n+            assertThat(create.get(\"status\"), equalTo(201));\n+            ids.add((String) create.get(\"_id\"));\n+        }\n+        return ids;\n+    }\n+\n     private void createTemplates() throws IOException {\n         var componentTemplateRequest = new Request(\"PUT\", \"/_component_template/component1\");\n         componentTemplateRequest.setJsonEntity(\"\"\"\n@@ -2823,6 +3092,49 @@ private void createTemplates() throws IOException {\n         assertOK(adminClient().performRequest(indexTemplateRequest));\n     }\n \n+    private void createOtherTemplates() throws IOException {\n+        var componentTemplateRequest = new Request(\"PUT\", \"/_component_template/component2\");\n+        componentTemplateRequest.setJsonEntity(\"\"\"\n+            {\n+                \"template\": {\n+                    \"mappings\": {\n+                        \"properties\": {\n+                            \"@timestamp\": {\n+                                \"type\": \"date\"\n+                            },\n+                            \"age\": {\n+                                \"type\": \"integer\"\n+                            },\n+                            \"email\": {\n+                                \"type\": \"keyword\"\n+                            },\n+                            \"name\": {\n+                                \"type\": \"text\"\n+                            }\n+                        }\n+                    },\n+                    \"data_stream_options\": {\n+                      \"failure_store\": {\n+                        \"enabled\": true\n+                      }\n+                    }\n+                }\n+            }\n+            \"\"\");\n+        assertOK(adminClient().performRequest(componentTemplateRequest));\n+\n+        var indexTemplateRequest = new Request(\"PUT\", \"/_index_template/template2\");\n+        indexTemplateRequest.setJsonEntity(\"\"\"\n+            {\n+                \"index_patterns\": [\"other*\"],\n+                \"data_stream\": {},\n+                \"priority\": 500,\n+                \"composed_of\": [\"component1\"]\n+            }\n+            \"\"\");\n+        assertOK(adminClient().performRequest(indexTemplateRequest));\n+    }\n+\n     private List<String> populateDataStreamWithDocRequests() throws IOException {\n         List<String> ids = new ArrayList<>();\n \n@@ -2942,6 +3254,11 @@ protected String createAndStoreApiKey(String username, @Nullable String roleDesc\n         return apiKeys.get(username);\n     }\n \n+    protected String createOrUpdateApiKey(String username, @Nullable String roleDescriptors) throws IOException {\n+        apiKeys.put(username, createApiKey(username, roleDescriptors));\n+        return apiKeys.get(username);\n+    }\n+\n     private String createApiKey(String username, String roleDescriptors) throws IOException {\n         var request = new Request(\"POST\", \"/_security/api_key\");\n         if (roleDescriptors == null) {",
      "filename": "x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java",
      "status": "modified",
      "changes": 325,
      "additions": 321,
      "deletions": 4
    }
  ],
  "ai_reviews": [
    {
      "id": 15,
      "pr_id": 2485565973,
      "summary": "This pull request addresses issues related to the retrieval of resolved aliases for failure indices in Elasticsearch. The primary goal is to enhance the functionality and reliability of the failure store mechanism.\n\nSignificant modifications include:\n- In `TransportClusterSearchShardsAction.java` and `TransportSearchAction.java`, minor adjustments were made, resulting in a net reduction of code, which may indicate a cleanup or optimization effort.\n- The `IndexNameExpressionResolver.java` file saw substantial changes, with 39 additions and 17 deletions, suggesting a significant overhaul of how index names and aliases are resolved.\n- The test suite for `IndexNameExpressionResolver` was extensively updated, with 92 additions and 60 deletions, indicating a comprehensive revision of test cases to ensure robust coverage of the new functionality.\n- The `FailureStoreSecurityRestIT.java` file experienced a major update with 321 additions, likely introducing new integration tests to validate the changes in the failure store's behavior.\n\nPotential concerns include the large number of modifications in the test files, which may introduce complexity and require thorough review to ensure that all edge cases are covered. Additionally, the impact of these changes on existing functionality should be carefully monitored to avoid regressions. Overall, the PR appears to be a significant step towards improving the failure store's alias resolution capabilities.",
      "full_review": "# AI Review \ud83e\udd16\n\n## Summary\nThis pull request addresses issues related to the retrieval of resolved aliases for failure indices in Elasticsearch. The primary goal is to enhance the functionality and reliability of the failure store mechanism.\n\nSignificant modifications include:\n- In `TransportClusterSearchShardsAction.java` and `TransportSearchAction.java`, minor adjustments were made, resulting in a net reduction of code, which may indicate a cleanup or optimization effort.\n- The `IndexNameExpressionResolver.java` file saw substantial changes, with 39 additions and 17 deletions, suggesting a significant overhaul of how index names and aliases are resolved.\n- The test suite for `IndexNameExpressionResolver` was extensively updated, with 92 additions and 60 deletions, indicating a comprehensive revision of test cases to ensure robust coverage of the new functionality.\n- The `FailureStoreSecurityRestIT.java` file experienced a major update with 321 additions, likely introducing new integration tests to validate the changes in the failure store's behavior.\n\nPotential concerns include the large number of modifications in the test files, which may introduce complexity and require thorough review to ensure that all edge cases are covered. Additionally, the impact of these changes on existing functionality should be carefully monitored to avoid regressions. Overall, the PR appears to be a significant step towards improving the failure store's alias resolution capabilities.\n\n## Detailed Review\n\n### server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java\nOverall Assessment:\nThe code diff shows a modification where the `Predicates` import and usage have been removed in favor of a more straightforward method call to `allIndexAliases`. This change simplifies the code and reduces unnecessary complexity. However, it's important to ensure that the new method behaves as expected and that no functionality is lost in the process.\n\nSpecific Issues:\n1. **Line 6**: The removal of the `Predicates` import is appropriate if it is no longer used. Ensure that there are no other parts of the code that still rely on it.\n2. **Line 104**: The change from using `indexAliases` with predicates to `allIndexAliases` should be verified to ensure that it provides the same or expected results. If `allIndexAliases` does not filter aliases in the same way as the previous method, it could lead to unintended behavior.\n3. **Performance**: The new method `allIndexAliases` should be checked for performance implications. If it retrieves more data than necessary, it could impact performance negatively, especially if this method is called frequently or in a loop.\n4. **Code Style**: The code style is consistent with Java conventions. However, consider adding comments to clarify the purpose of the change, especially if the new method has different behavior.\n5. **Edge Cases**: Ensure that the new method handles edge cases appropriately, such as when there are no aliases or when the index does not exist. Testing should cover these scenarios to prevent runtime exceptions.\n\nIn summary, while the change appears to simplify the code, it is crucial to validate the behavior of the new method and ensure that it meets the original intent without introducing bugs or performance issues.\n### server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java\nOverall, the code diff appears to be a straightforward refactor, replacing a method call to `indexAliases` with `allIndexAliases`. This change simplifies the code by removing unnecessary predicates. However, there are a few points worth noting:\n\n1. **Bugs or Logical Errors**:\n   - Ensure that the new method `allIndexAliases` behaves as expected and returns the same type of data as the previous method. If there are any differences in how aliases are retrieved or filtered, it could lead to logical errors in the application.\n\n2. **Performance Issues**:\n   - If `allIndexAliases` is less efficient than `indexAliases` due to its implementation, it could introduce performance issues. It would be prudent to review the implementation of `allIndexAliases` to ensure it is optimized for performance, especially if this method is called frequently.\n\n3. **Security Vulnerabilities**:\n   - There are no apparent security vulnerabilities introduced by this change. However, ensure that the new method does not expose any sensitive information or allow for unintended access to indices.\n\n4. **Code Style and Best Practices**:\n   - The code style is consistent with Java conventions. However, consider adding comments to clarify the purpose of the change, especially if the new method has different implications or behavior compared to the old one.\n\n5. **Potential Edge Cases**:\n   - Verify how `allIndexAliases` handles edge cases, such as when there are no aliases or when the index does not exist. Ensure that the rest of the code can handle these scenarios gracefully.\n\nIn summary, while the change seems to simplify the code, it is essential to validate the behavior of the new method and ensure that it meets the same requirements as the previous implementation. \n\nOverall, the diff looks good, but further validation is recommended.\n### server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\nOverall, the code diff appears to be well-structured and introduces new functionality related to data stream aliases. However, there are a few areas that could benefit from further consideration or improvement. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 1122-1123**: The logic for filtering `dataStreamAlias` based on `resolvedExpressionsContainsAbstraction` could lead to incorrect results if `isData` is not handled properly. Ensure that the filtering logic aligns with the intended behavior for both data and failure indices.\n\n2. **Performance Issues**:\n   - **Line 1122-1123**: The use of `stream()` and `filter()` can be less efficient than using a traditional loop, especially if the size of `dataStreamAliases` is large. Consider using a for-each loop if performance is a concern in this context.\n\n3. **Code Style and Best Practices**:\n   - **Line 81**: The comment above the `ONLY_FILTERING_DATA_STREAM_ALIASES` variable could be more concise. Consider rephrasing to improve clarity and reduce verbosity.\n   - **Line 1080**: The method signature for `indexAliases` is quite long. Consider breaking it into multiple lines for better readability, especially for the parameters.\n\n4. **Potential Edge Cases**:\n   - **Line 1107**: The check for `dataStream.getFailureComponent().containsIndex(index)` is commented out. Ensure that this logic is still valid and that the absence of this check does not introduce any edge cases where indices in the failure component are incorrectly processed.\n   - **Line 1185**: The method `resolvedExpressionsContainsAbstraction` now has a boolean parameter `isData`. Ensure that all calls to this method are correctly passing the appropriate value for `isData` to avoid logical errors.\n\n5. **Documentation**:\n   - The new method `allIndexAliases` has a good Javadoc comment, but consider adding similar comments for other methods that have been modified to clarify their behavior, especially regarding the new `isData` parameter.\n\nIn summary, while the changes introduce useful functionality, careful attention should be paid to the logical flow, performance considerations, and documentation to ensure the code remains robust and maintainable.\n### server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\nOverall, the code diff appears to be a refactor of the `IndexNameExpressionResolverTests` class, with a focus on improving the clarity and functionality of alias resolution methods. The changes seem to enhance readability and maintainability. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - **Line 1700**: The comment states \"Only resolve aliases that refer to dataStreamName1,\" but the previous implementation was also resolving aliases. Ensure that the logic aligns with the comment to avoid confusion.\n\n2. **Code Style and Best Practices**:\n   - **Line 1700 and 1710**: The comments could be more concise. For example, \"Only resolve aliases that refer to dataStreamName1\" could be simplified to \"Resolve aliases for dataStreamName1.\"\n   - **Line 1756**: The lambda `(alias, isData) -> alias.filteringRequired() && isData` could be extracted into a named method for better readability and reusability.\n\n3. **Potential Edge Cases**:\n   - **Line 1756**: The use of `randomBoolean()` in the alias filtering could lead to non-deterministic test results. This could make tests flaky. Consider using a more controlled approach to ensure consistent test outcomes.\n   - **Line 1756**: Ensure that the logic for filtering aliases is robust against unexpected input. For instance, if `resolvedExpressions` is empty or null, the method should handle these cases gracefully.\n\n4. **Performance Issues**:\n   - The changes do not introduce any obvious performance issues, but ensure that the new methods (`allIndexAliases`, `filteringAliases`) are optimized for performance, especially if they will be called frequently in production scenarios.\n\n5. **Security Vulnerabilities**:\n   - No immediate security vulnerabilities are apparent in the diff. However, ensure that any user input or external data used in alias resolution is properly validated and sanitized to prevent injection attacks or other security issues.\n\nIn summary, while the refactor improves clarity, attention should be paid to the comments for accuracy, the potential for non-deterministic test results, and ensuring robust handling of edge cases. \n\nOverall, the changes look promising, but consider the points above for further refinement.\n### x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java\nOverall, the code diff appears to be well-structured and follows good practices for testing in Java. However, there are a few areas that could be improved or warrant further attention. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 1921**: The method `setupDataStream()` is called, but it is unclear what it does. Ensure that it correctly sets up the data stream and that the expected document IDs are indeed present. If this method fails or does not behave as expected, it could lead to misleading test results.\n\n2. **Performance Issues**:\n   - **Line 1950**: The method `fetchAliases()` is called multiple times with the same parameters. If the underlying implementation of `fetchAliases()` involves network calls or heavy computations, consider caching the results to avoid redundant calls.\n\n3. **Security Vulnerabilities**:\n   - **Line 1980**: The `createOrUpdateRoleAndApiKey()` method allows for dynamic role creation based on user input. Ensure that the role descriptor does not allow for privilege escalation or unintended access. Consider validating the role descriptor against a whitelist of allowed actions and indices.\n\n4. **Code Style and Best Practices**:\n   - **Line 1955**: The use of `Strings.format()` for JSON construction is good, but consider using a dedicated JSON library (like Jackson or Gson) for building JSON objects. This can help avoid issues with malformed JSON and improve readability.\n   - **Line 1985**: The method `aliasAction()` has a lot of duplicated code for constructing the request JSON. Consider refactoring this to reduce duplication and improve maintainability.\n\n5. **Potential Edge Cases**:\n   - **Line 1970**: The method `removeAlias()` is called with a 403 expectation. Ensure that the test setup correctly simulates the conditions under which the alias removal should fail. If the alias does not exist, this could lead to false positives in the test.\n   - **Line 1990**: The `fetchAliases()` method should handle cases where the user does not have permission to view aliases. Ensure that the test accounts for this scenario to avoid misleading results.\n\nIn summary, while the code is generally well-structured, attention should be paid to potential logical errors, performance optimizations, security considerations, and edge cases. Addressing these points will help ensure the robustness and reliability of the tests.\n\n\n---\n*This review was automatically generated by an AI assistant.*",
      "created_at": "2025-04-29T01:29:00",
      "file_reviews": [
        {
          "id": 135,
          "review_id": 15,
          "pr_id": 2485565973,
          "filename": "server/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java",
          "content": "Overall Assessment:\nThe code diff shows a modification where the `Predicates` import and usage have been removed in favor of a more straightforward method call to `allIndexAliases`. This change simplifies the code and reduces unnecessary complexity. However, it's important to ensure that the new method behaves as expected and that no functionality is lost in the process.\n\nSpecific Issues:\n1. **Line 6**: The removal of the `Predicates` import is appropriate if it is no longer used. Ensure that there are no other parts of the code that still rely on it.\n2. **Line 104**: The change from using `indexAliases` with predicates to `allIndexAliases` should be verified to ensure that it provides the same or expected results. If `allIndexAliases` does not filter aliases in the same way as the previous method, it could lead to unintended behavior.\n3. **Performance**: The new method `allIndexAliases` should be checked for performance implications. If it retrieves more data than necessary, it could impact performance negatively, especially if this method is called frequently or in a loop.\n4. **Code Style**: The code style is consistent with Java conventions. However, consider adding comments to clarify the purpose of the change, especially if the new method has different behavior.\n5. **Edge Cases**: Ensure that the new method handles edge cases appropriately, such as when there are no aliases or when the index does not exist. Testing should cover these scenarios to prevent runtime exceptions.\n\nIn summary, while the change appears to simplify the code, it is crucial to validate the behavior of the new method and ensure that it meets the original intent without introducing bugs or performance issues.",
          "created_at": "2025-04-29T01:29:00"
        },
        {
          "id": 136,
          "review_id": 15,
          "pr_id": 2485565973,
          "filename": "server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java",
          "content": "Overall, the code diff appears to be a straightforward refactor, replacing a method call to `indexAliases` with `allIndexAliases`. This change simplifies the code by removing unnecessary predicates. However, there are a few points worth noting:\n\n1. **Bugs or Logical Errors**:\n   - Ensure that the new method `allIndexAliases` behaves as expected and returns the same type of data as the previous method. If there are any differences in how aliases are retrieved or filtered, it could lead to logical errors in the application.\n\n2. **Performance Issues**:\n   - If `allIndexAliases` is less efficient than `indexAliases` due to its implementation, it could introduce performance issues. It would be prudent to review the implementation of `allIndexAliases` to ensure it is optimized for performance, especially if this method is called frequently.\n\n3. **Security Vulnerabilities**:\n   - There are no apparent security vulnerabilities introduced by this change. However, ensure that the new method does not expose any sensitive information or allow for unintended access to indices.\n\n4. **Code Style and Best Practices**:\n   - The code style is consistent with Java conventions. However, consider adding comments to clarify the purpose of the change, especially if the new method has different implications or behavior compared to the old one.\n\n5. **Potential Edge Cases**:\n   - Verify how `allIndexAliases` handles edge cases, such as when there are no aliases or when the index does not exist. Ensure that the rest of the code can handle these scenarios gracefully.\n\nIn summary, while the change seems to simplify the code, it is essential to validate the behavior of the new method and ensure that it meets the same requirements as the previous implementation. \n\nOverall, the diff looks good, but further validation is recommended.",
          "created_at": "2025-04-29T01:29:00"
        },
        {
          "id": 137,
          "review_id": 15,
          "pr_id": 2485565973,
          "filename": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java",
          "content": "Overall, the code diff appears to be well-structured and introduces new functionality related to data stream aliases. However, there are a few areas that could benefit from further consideration or improvement. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 1122-1123**: The logic for filtering `dataStreamAlias` based on `resolvedExpressionsContainsAbstraction` could lead to incorrect results if `isData` is not handled properly. Ensure that the filtering logic aligns with the intended behavior for both data and failure indices.\n\n2. **Performance Issues**:\n   - **Line 1122-1123**: The use of `stream()` and `filter()` can be less efficient than using a traditional loop, especially if the size of `dataStreamAliases` is large. Consider using a for-each loop if performance is a concern in this context.\n\n3. **Code Style and Best Practices**:\n   - **Line 81**: The comment above the `ONLY_FILTERING_DATA_STREAM_ALIASES` variable could be more concise. Consider rephrasing to improve clarity and reduce verbosity.\n   - **Line 1080**: The method signature for `indexAliases` is quite long. Consider breaking it into multiple lines for better readability, especially for the parameters.\n\n4. **Potential Edge Cases**:\n   - **Line 1107**: The check for `dataStream.getFailureComponent().containsIndex(index)` is commented out. Ensure that this logic is still valid and that the absence of this check does not introduce any edge cases where indices in the failure component are incorrectly processed.\n   - **Line 1185**: The method `resolvedExpressionsContainsAbstraction` now has a boolean parameter `isData`. Ensure that all calls to this method are correctly passing the appropriate value for `isData` to avoid logical errors.\n\n5. **Documentation**:\n   - The new method `allIndexAliases` has a good Javadoc comment, but consider adding similar comments for other methods that have been modified to clarify their behavior, especially regarding the new `isData` parameter.\n\nIn summary, while the changes introduce useful functionality, careful attention should be paid to the logical flow, performance considerations, and documentation to ensure the code remains robust and maintainable.",
          "created_at": "2025-04-29T01:29:00"
        },
        {
          "id": 138,
          "review_id": 15,
          "pr_id": 2485565973,
          "filename": "server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java",
          "content": "Overall, the code diff appears to be a refactor of the `IndexNameExpressionResolverTests` class, with a focus on improving the clarity and functionality of alias resolution methods. The changes seem to enhance readability and maintainability. However, there are a few points worth noting:\n\n1. **Logical Errors**:\n   - **Line 1700**: The comment states \"Only resolve aliases that refer to dataStreamName1,\" but the previous implementation was also resolving aliases. Ensure that the logic aligns with the comment to avoid confusion.\n\n2. **Code Style and Best Practices**:\n   - **Line 1700 and 1710**: The comments could be more concise. For example, \"Only resolve aliases that refer to dataStreamName1\" could be simplified to \"Resolve aliases for dataStreamName1.\"\n   - **Line 1756**: The lambda `(alias, isData) -> alias.filteringRequired() && isData` could be extracted into a named method for better readability and reusability.\n\n3. **Potential Edge Cases**:\n   - **Line 1756**: The use of `randomBoolean()` in the alias filtering could lead to non-deterministic test results. This could make tests flaky. Consider using a more controlled approach to ensure consistent test outcomes.\n   - **Line 1756**: Ensure that the logic for filtering aliases is robust against unexpected input. For instance, if `resolvedExpressions` is empty or null, the method should handle these cases gracefully.\n\n4. **Performance Issues**:\n   - The changes do not introduce any obvious performance issues, but ensure that the new methods (`allIndexAliases`, `filteringAliases`) are optimized for performance, especially if they will be called frequently in production scenarios.\n\n5. **Security Vulnerabilities**:\n   - No immediate security vulnerabilities are apparent in the diff. However, ensure that any user input or external data used in alias resolution is properly validated and sanitized to prevent injection attacks or other security issues.\n\nIn summary, while the refactor improves clarity, attention should be paid to the comments for accuracy, the potential for non-deterministic test results, and ensuring robust handling of edge cases. \n\nOverall, the changes look promising, but consider the points above for further refinement.",
          "created_at": "2025-04-29T01:29:00"
        },
        {
          "id": 139,
          "review_id": 15,
          "pr_id": 2485565973,
          "filename": "x-pack/plugin/security/qa/security-trial/src/javaRestTest/java/org/elasticsearch/xpack/security/failurestore/FailureStoreSecurityRestIT.java",
          "content": "Overall, the code diff appears to be well-structured and follows good practices for testing in Java. However, there are a few areas that could be improved or warrant further attention. Here are the specific points:\n\n1. **Logical Errors**:\n   - **Line 1921**: The method `setupDataStream()` is called, but it is unclear what it does. Ensure that it correctly sets up the data stream and that the expected document IDs are indeed present. If this method fails or does not behave as expected, it could lead to misleading test results.\n\n2. **Performance Issues**:\n   - **Line 1950**: The method `fetchAliases()` is called multiple times with the same parameters. If the underlying implementation of `fetchAliases()` involves network calls or heavy computations, consider caching the results to avoid redundant calls.\n\n3. **Security Vulnerabilities**:\n   - **Line 1980**: The `createOrUpdateRoleAndApiKey()` method allows for dynamic role creation based on user input. Ensure that the role descriptor does not allow for privilege escalation or unintended access. Consider validating the role descriptor against a whitelist of allowed actions and indices.\n\n4. **Code Style and Best Practices**:\n   - **Line 1955**: The use of `Strings.format()` for JSON construction is good, but consider using a dedicated JSON library (like Jackson or Gson) for building JSON objects. This can help avoid issues with malformed JSON and improve readability.\n   - **Line 1985**: The method `aliasAction()` has a lot of duplicated code for constructing the request JSON. Consider refactoring this to reduce duplication and improve maintainability.\n\n5. **Potential Edge Cases**:\n   - **Line 1970**: The method `removeAlias()` is called with a 403 expectation. Ensure that the test setup correctly simulates the conditions under which the alias removal should fail. If the alias does not exist, this could lead to false positives in the test.\n   - **Line 1990**: The `fetchAliases()` method should handle cases where the user does not have permission to view aliases. Ensure that the test accounts for this scenario to avoid misleading results.\n\nIn summary, while the code is generally well-structured, attention should be paid to potential logical errors, performance optimizations, security considerations, and edge cases. Addressing these points will help ensure the robustness and reliability of the tests.",
          "created_at": "2025-04-29T01:29:00"
        }
      ]
    }
  ]
}